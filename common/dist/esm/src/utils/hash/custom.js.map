{"version":3,"sources":["../../../../../src/utils/hash.ts"],"sourcesContent":["import { ethers } from 'ethers';\n// @ts-ignore - ESLint incorrectly flags this as needing default import, but TypeScript definitions use named export\nimport { sha1 } from 'js-sha1';\nimport { sha224, sha256 } from 'js-sha256';\nimport { sha384, sha512 } from 'js-sha512';\nimport * as forge from 'node-forge';\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from 'poseidon-lite';\n\nimport { hexToSignedBytes, packBytesArray } from './bytes.js';\n\nexport function calculateUserIdentifierHash(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): BigInt {\n  const solidityPackedUserContextData = getSolidityPackedUserContextData(\n    destChainID,\n    userID,\n    userDefinedData\n  );\n  const inputBytes = Buffer.from(solidityPackedUserContextData.slice(2), 'hex');\n  const sha256Hash = ethers.sha256(inputBytes);\n  const ripemdHash = ethers.ripemd160(sha256Hash);\n  return BigInt(ripemdHash);\n}\n\nexport function customHasher(pubKeyFormatted: string[]) {\n  if (pubKeyFormatted.length < 16) {\n    // if k is less than 16, we can use a single poseidon hash\n    return flexiblePoseidon(pubKeyFormatted.map(BigInt)).toString();\n  } else {\n    const rounds = Math.ceil(pubKeyFormatted.length / 16); // do up to 16 rounds of poseidon\n    if (rounds > 16) {\n      throw new Error('Number of rounds is greater than 16');\n    }\n    const hash = new Array(rounds);\n    for (let i = 0; i < rounds; i++) {\n      hash[i] = { inputs: new Array(16).fill(BigInt(0)) };\n    }\n    for (let i = 0; i < rounds; i++) {\n      for (let j = 0; j < 16; j++) {\n        if (i * 16 + j < pubKeyFormatted.length) {\n          hash[i].inputs[j] = BigInt(pubKeyFormatted[i * 16 + j]);\n        }\n      }\n    }\n    const finalHash = flexiblePoseidon(hash.map((h) => poseidon16(h.inputs)));\n    return finalHash.toString();\n  }\n}\n\nexport function flexiblePoseidon(inputs: bigint[]): bigint {\n  switch (inputs.length) {\n    case 1:\n      return poseidon1(inputs);\n    case 2:\n      return poseidon2(inputs);\n    case 3:\n      return poseidon3(inputs);\n    case 4:\n      return poseidon4(inputs);\n    case 5:\n      return poseidon5(inputs);\n    case 6:\n      return poseidon6(inputs);\n    case 7:\n      return poseidon7(inputs);\n    case 8:\n      return poseidon8(inputs);\n    case 9:\n      return poseidon9(inputs);\n    case 10:\n      return poseidon10(inputs);\n    case 11:\n      return poseidon11(inputs);\n    case 12:\n      return poseidon12(inputs);\n    case 13:\n      return poseidon13(inputs);\n    case 14:\n      return poseidon14(inputs);\n    case 15:\n      return poseidon15(inputs);\n    case 16:\n      return poseidon16(inputs);\n    default:\n      throw new Error(`Unsupported number of inputs: ${inputs.length}`);\n  }\n}\n\nexport function getHashLen(hashFunction: string) {\n  switch (hashFunction) {\n    case 'sha1':\n      return 20;\n    case 'sha224':\n      return 28;\n    case 'sha256':\n      return 32;\n    case 'sha384':\n      return 48;\n    case 'sha512':\n      return 64;\n    default:\n      console.log(`${hashFunction} not found in getHashLen`);\n      return 32;\n  }\n}\n\nexport function getSolidityPackedUserContextData(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): string {\n  const userIdHex = userID.replace(/-/g, '');\n  return ethers.solidityPacked(\n    ['bytes32', 'bytes32', 'bytes'],\n    [\n      ethers.zeroPadValue(ethers.toBeHex(destChainID), 32),\n      ethers.zeroPadValue('0x' + userIdHex, 32),\n      ethers.toUtf8Bytes(userDefinedData),\n    ]\n  );\n}\n\n// hash function - crypto is not supported in react native\nexport function hash(\n  hashFunction: string,\n  bytesArray: number[],\n  format: string = 'bytes'\n): string | number[] {\n  const unsignedBytesArray = bytesArray.map((byte) => byte & 0xff);\n  let hashResult: string;\n\n  switch (hashFunction) {\n    case 'sha1':\n      hashResult = sha1(unsignedBytesArray);\n      break;\n    case 'sha224':\n      hashResult = sha224(unsignedBytesArray);\n      break;\n    case 'sha256':\n      hashResult = sha256(unsignedBytesArray);\n      break;\n    case 'sha384':\n      hashResult = sha384(unsignedBytesArray);\n      break;\n    case 'sha512':\n      hashResult = sha512(unsignedBytesArray);\n      break;\n    default:\n      console.log('\\x1b[31m%s\\x1b[0m', `${hashFunction} not found in hash`); // Log in red\n      hashResult = sha256(unsignedBytesArray); // Default to sha256\n  }\n  if (format === 'hex') {\n    return hashResult;\n  }\n  if (format === 'bytes') {\n    return hexToSignedBytes(hashResult);\n  }\n  const actualForgeUtil = forge.util ? forge.util : (forge as any).default.util;\n  if (format === 'binary') {\n    return actualForgeUtil.binary.raw.encode(new Uint8Array(hexToSignedBytes(hashResult)));\n  }\n  throw new Error(`Invalid format: ${format}`);\n}\n\nexport function packBytesAndPoseidon(unpacked: number[]) {\n  const packed = packBytesArray(unpacked);\n  return customHasher(packed.map(String)).toString();\n}\n"],"mappings":"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","names":[]}