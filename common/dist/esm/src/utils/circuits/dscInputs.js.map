{"version":3,"sources":["../../../../../src/constants/constants.ts","../../../../../src/utils/hash.ts","../../../../../src/utils/bytes.ts","../../../../../src/utils/passports/passport.ts","../../../../../src/utils/certificate_parsing/parseCertificateSimple.ts","../../../../../src/utils/csca.ts","../../../../../src/utils/shaPad.ts","../../../../../src/utils/trees.ts","../../../../../src/utils/circuits/generateInputs.ts"],"sourcesContent":["export type Country3LetterCode = keyof typeof countryCodes;\nexport type document_type = 'passport' | 'id_card';\nexport type hashAlgosTypes = 'sha512' | 'sha384' | 'sha256' | 'sha224' | 'sha1';\nexport const API_URL = 'https://api.self.xyz';\nexport const API_URL_STAGING = 'https://api.staging.self.xyz';\n\nexport const CHAIN_NAME = 'celo';\n\n// possible values because of sha1 constaints: 192,320,384, 448, 576, 640\nexport const CIRCUIT_CONSTANTS = {\n  REGISTER_NULLIFIER_INDEX: 0,\n  REGISTER_COMMITMENT_INDEX: 1,\n  REGISTER_MERKLE_ROOT_INDEX: 2,\n\n  DSC_TREE_LEAF_INDEX: 0,\n  DSC_CSCA_ROOT_INDEX: 1,\n\n  VC_AND_DISCLOSE_REVEALED_DATA_PACKED_INDEX: 0,\n  VC_AND_DISCLOSE_FORBIDDEN_COUNTRIES_LIST_PACKED_INDEX: 3,\n  VC_AND_DISCLOSE_NULLIFIER_INDEX: 7,\n  VC_AND_DISCLOSE_ATTESTATION_ID_INDEX: 8,\n  VC_AND_DISCLOSE_MERKLE_ROOT_INDEX: 9,\n  VC_AND_DISCLOSE_CURRENT_DATE_INDEX: 10,\n  VC_AND_DISCLOSE_PASSPORT_NO_SMT_ROOT_INDEX: 16,\n  VC_AND_DISCLOSE_NAME_DOB_SMT_ROOT_INDEX: 17,\n  VC_AND_DISCLOSE_NAME_YOB_SMT_ROOT_INDEX: 18,\n  VC_AND_DISCLOSE_SCOPE_INDEX: 19,\n  VC_AND_DISCLOSE_USER_IDENTIFIER_INDEX: 20,\n};\n\nexport const CIRCUIT_TYPES = ['dsc', 'register', 'vc_and_disclose'];\n\nexport const COMMITMENT_TREE_DEPTH = 33;\n\nexport const CSCA_TREE_DEPTH = 12;\n\nexport const CSCA_TREE_URL = 'https://tree.self.xyz/csca';\n\nexport const CSCA_TREE_URL_ID_CARD = 'https://tree.self.xyz/csca-id';\n\nexport const CSCA_TREE_URL_STAGING = 'https://tree.staging.self.xyz/csca';\n\nexport const CSCA_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/csca-id';\n\nexport const DEFAULT_MAJORITY = '18';\n\nexport const DEFAULT_RPC_URL = 'https://mainnet.optimism.io';\n\nexport const DEFAULT_USER_ID_TYPE = 'uuid';\n\nexport const DEVELOPMENT_MODE = true;\n\nexport const DSC_TREE_DEPTH = 21;\n\nexport const DSC_TREE_URL = 'https://tree.self.xyz/dsc';\n\nexport const DSC_TREE_URL_ID_CARD = 'https://tree.self.xyz/dsc-id';\n\nexport const DSC_TREE_URL_STAGING = 'https://tree.staging.self.xyz/dsc';\n\nexport const DSC_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/dsc-id';\n\nexport enum DscVerifierId {\n  dsc_sha1_ecdsa_brainpoolP256r1 = 0,\n  dsc_sha1_rsa_65537_4096 = 1,\n  dsc_sha256_ecdsa_brainpoolP256r1 = 2,\n  dsc_sha256_ecdsa_brainpoolP384r1 = 3,\n  dsc_sha256_ecdsa_secp256r1 = 4,\n  dsc_sha256_ecdsa_secp384r1 = 5,\n  dsc_sha256_ecdsa_secp521r1 = 6,\n  dsc_sha256_rsa_65537_4096 = 7,\n  dsc_sha256_rsapss_3_32_3072 = 8,\n  dsc_sha256_rsapss_65537_32_3072 = 9,\n  dsc_sha256_rsapss_65537_32_4096 = 10,\n  dsc_sha384_ecdsa_brainpoolP384r1 = 11,\n  dsc_sha384_ecdsa_brainpoolP512r1 = 12,\n  dsc_sha384_ecdsa_secp384r1 = 13,\n  dsc_sha512_ecdsa_brainpoolP512r1 = 14,\n  dsc_sha512_ecdsa_secp521r1 = 15,\n  dsc_sha512_rsa_65537_4096 = 16,\n  dsc_sha512_rsapss_65537_64_4096 = 17,\n  dsc_sha256_rsapss_3_32_4096 = 18,\n  dsc_sha1_ecdsa_secp256r1 = 19,\n}\n\nexport const ECDSA_K_LENGTH_FACTOR = 2;\n\nexport const IDENTITY_TREE_URL = 'https://tree.self.xyz/identity';\n\n//\"8518753152044246090169372947057357973469996808638122125210848696986717482788\"\nexport const IDENTITY_TREE_URL_ID_CARD = 'https://tree.self.xyz/identity-id';\n\nexport const IDENTITY_TREE_URL_STAGING = 'https://tree.staging.self.xyz/identity';\n\nexport const IDENTITY_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/identity-id';\n\nexport const ID_CARD_ATTESTATION_ID = '2';\n\nexport const MAX_BYTES_IN_FIELD = 31;\n\nexport const MAX_CERT_BYTES: Partial<Record<keyof typeof SignatureAlgorithmIndex, number>> = {\n  rsa_sha256_65537_4096: 512,\n  rsa_sha1_65537_4096: 640,\n  rsapss_sha256_65537_2048: 640,\n  rsapss_sha256_65537_3072: 640,\n  rsapss_sha256_65537_4096: 768,\n  rsapss_sha256_3_3072: 768,\n  rsapss_sha256_3_4096: 768,\n  rsapss_sha384_65537_3072: 768,\n};\n\n/**\n * Maximum number of countries in the forbidden countries list.\n *\n * IMPORTANT: This value must match in both backend and frontend SDK.\n * Any mismatch will result in an INVALID_FORBIDDEN_COUNTRIES error.\n */\nexport const MAX_DATAHASHES_LEN = 320;\n\nexport const MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n\nexport const MAX_PADDED_ECONTENT_LEN: Partial<Record<(typeof hashAlgos)[number], number>> = {\n  sha1: 384,\n  sha224: 512,\n  sha256: 512,\n  sha384: 768,\n  sha512: 896,\n};\n\nexport const MAX_PADDED_SIGNED_ATTR_LEN: Record<(typeof hashAlgos)[number], number> = {\n  sha1: 128,\n  sha224: 128,\n  sha256: 128,\n  sha384: 256,\n  sha512: 256,\n};\n\n// Note: Circuit lists are now managed through RegisterVerifierId and DscVerifierId enums below\n// instead of separate arrays for better type safety and maintainability\nexport const MAX_PUBKEY_DSC_BYTES = 525;\n\nexport const OFAC_TREE_LEVELS = 64;\n\n// we make it global here because passing it to generateCircuitInputsRegister caused trouble\nexport const PASSPORT_ATTESTATION_ID = '1';\n\nexport const PCR0_MANAGER_ADDRESS = '0xE36d4EE5Fd3916e703A46C21Bb3837dB7680C8B8';\n\nexport const REDIRECT_URL = 'https://redirect.self.xyz';\n\nexport const REGISTER_CONTRACT_ADDRESS = '0x3F346FFdC5d583e4126AF01A02Ac5b9CdB3f1909';\n\nexport const RPC_URL = 'https://forno.celo.org';\n\nexport enum RegisterVerifierId {\n  register_sha256_sha256_sha256_rsa_65537_4096 = 0,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 1,\n  register_sha256_sha256_sha256_ecdsa_secp256r1 = 2,\n  register_sha256_sha256_sha256_ecdsa_secp384r1 = 3,\n  register_sha256_sha256_sha256_rsa_3_4096 = 4,\n  register_sha256_sha256_sha256_rsapss_3_32_2048 = 5,\n  register_sha256_sha256_sha256_rsapss_65537_32_2048 = 6,\n  register_sha256_sha256_sha256_rsapss_65537_32_3072 = 7,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 8,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 9,\n  register_sha384_sha384_sha384_ecdsa_secp384r1 = 10,\n  register_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 11,\n  register_sha512_sha512_sha512_rsa_65537_4096 = 12,\n  register_sha512_sha512_sha512_rsapss_65537_64_2048 = 13,\n  register_sha1_sha1_sha1_rsa_65537_4096 = 14,\n  register_sha1_sha256_sha256_rsa_65537_4096 = 15,\n  register_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 16,\n  register_sha256_sha224_sha224_ecdsa_secp224r1 = 17,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 18,\n  register_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 19,\n  register_sha384_sha384_sha384_rsapss_65537_48_2048 = 20,\n  register_sha1_sha1_sha1_ecdsa_secp256r1 = 21,\n  register_sha256_sha256_sha256_rsapss_65537_64_2048 = 22,\n  register_sha512_sha512_sha256_rsa_65537_4096 = 23,\n  register_sha512_sha512_sha512_ecdsa_secp521r1 = 24,\n  register_id_sha256_sha256_sha256_rsa_65537_4096 = 25,\n  register_sha256_sha256_sha224_ecdsa_secp224r1 = 26,\n  register_id_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 27,\n  register_id_sha1_sha1_sha1_ecdsa_secp256r1 = 28,\n  register_id_sha1_sha1_sha1_rsa_65537_4096 = 29,\n  register_id_sha1_sha256_sha256_rsa_65537_4096 = 30,\n  register_id_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 31,\n  register_id_sha256_sha224_sha224_ecdsa_secp224r1 = 32,\n  register_id_sha256_sha256_sha224_ecdsa_secp224r1 = 33,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 34,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 35,\n  register_id_sha256_sha256_sha256_ecdsa_secp256r1 = 36,\n  register_id_sha256_sha256_sha256_ecdsa_secp384r1 = 37,\n  register_id_sha256_sha256_sha256_rsa_3_4096 = 38,\n  register_id_sha256_sha256_sha256_rsapss_3_32_2048 = 39,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_2048 = 40,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_3072 = 41,\n  register_id_sha256_sha256_sha256_rsapss_65537_64_2048 = 42,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 43,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 44,\n  register_id_sha384_sha384_sha384_ecdsa_secp384r1 = 45,\n  register_id_sha384_sha384_sha384_rsapss_65537_48_2048 = 46,\n  register_id_sha512_sha512_sha256_rsa_65537_4096 = 47,\n  register_id_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 48,\n  register_id_sha512_sha512_sha512_ecdsa_secp521r1 = 49,\n  register_id_sha512_sha512_sha512_rsa_65537_4096 = 50,\n  register_id_sha512_sha512_sha512_rsapss_65537_64_2048 = 51,\n}\n\nexport const SBT_CONTRACT_ADDRESS = '0x601Fd54FD11C5E77DE84d877e55B829aff20f0A6';\n\nexport enum SignatureAlgorithmIndex {\n  rsa_sha256_65537_2048 = 1,\n  rsa_sha1_65537_2048 = 3,\n  rsapss_sha256_65537_2048 = 4,\n  ecdsa_sha1_secp256r1_256 = 7,\n  ecdsa_sha256_secp256r1_256 = 8,\n  ecdsa_sha384_secp384r1_384 = 9,\n  rsa_sha256_65537_4096 = 10,\n  rsa_sha1_65537_4096 = 11,\n  rsapss_sha256_65537_4096 = 12,\n  rsa_sha256_3_2048 = 13,\n  rsa_sha256_65537_3072 = 14,\n  rsa_sha512_65537_4096 = 15,\n  rsapss_sha256_3_3072 = 16,\n  rsapss_sha256_3_4096 = 17,\n  rsapss_sha384_65537_3072 = 18,\n  rsapss_sha256_65537_3072 = 19,\n  ecdsa_sha256_brainpoolP256r1_256 = 21,\n  ecdsa_sha384_brainpoolP384r1_384 = 22,\n  ecdsa_sha256_secp384r1_384 = 23,\n  ecdsa_sha384_brainpoolP256r1_256 = 24,\n  ecdsa_sha512_brainpoolP256r1_256 = 25,\n  ecdsa_sha512_brainpoolP384r1_384 = 26,\n  ecdsa_sha1_brainpoolP224r1_224 = 27,\n  ecdsa_sha256_brainpoolP224r1_224 = 28,\n  ecdsa_sha512_brainpoolP512r1_512 = 29,\n  ecdsa_sha224_brainpoolP224r1_224 = 30,\n  rsa_sha256_3_4096 = 32,\n  rsa_sha1_3_4096 = 33,\n  rsa_sha384_65537_4096 = 34,\n  rsapss_sha384_65537_4096 = 35,\n  ecdsa_sha1_brainpoolP256r1_256 = 36,\n  ecdsa_sha512_secp521r1_521 = 41,\n}\n\nexport const TREE_TRACKER_URL = 'https://tree.self.xyz';\n\nexport const TREE_URL = 'https://tree.self.xyz';\nexport const TREE_URL_STAGING = 'https://tree.staging.self.xyz';\n\nexport const WS_DB_RELAYER = 'wss://websocket.self.xyz';\n\nexport const WS_DB_RELAYER_STAGING = 'wss://websocket.staging.self.xyz';\n\nexport const WS_RPC_URL_VC_AND_DISCLOSE = 'ws://disclose.proving.self.xyz:8888/';\n\nexport const attributeToPosition = {\n  issuing_state: [2, 4],\n  name: [5, 43],\n  passport_number: [44, 52],\n  nationality: [54, 56],\n  date_of_birth: [57, 62],\n  gender: [64, 64],\n  expiry_date: [65, 70],\n  older_than: [88, 89],\n  ofac: [90, 90],\n};\nexport const attributeToPosition_ID = {\n  issuing_state: [2, 4],\n  name: [60, 89],\n  passport_number: [5, 13],\n  nationality: [45, 47],\n  date_of_birth: [30, 35],\n  gender: [37, 37],\n  expiry_date: [38, 43],\n  older_than: [90, 91],\n  ofac: [92, 92],\n};\n\nexport const circuitNameFromMode = {\n  prove: 'prove',\n  prove_onchain: 'prove',\n  prove_offchain: 'prove',\n  register: 'prove',\n  vc_and_disclose: 'vc_and_disclose',\n  dsc: 'dsc',\n};\nexport const circuitToSelectorMode = {\n  register: [0, 0],\n  prove_onchain: [1, 0],\n  prove_offchain: [1, 1],\n};\n\nexport const contribute_publicKey = `-----BEGIN RSA PUBLIC KEY-----\nMIICCgKCAgEAv/hm7FZZ2KBmaeDHmLoRwuWmCcNKT561RqbsW8ZuYSyPWJUldE9U\nCf0lW3K1H5lsSDkl0Cq84cooL9f6X59Mffb/N24ZKTdL0xdcPwjk4LbcrVm8qubL\n0a/4uCNoZZ1my4nxbpLxYtbr8CNmUGvBOVKf8IcjsY6VghIZrO63G6BN/G44su1Z\nWcHpboGt9SDQK4enCyKxnCD+PbDYlewSA0n3GRajFfZex1bj1EvrS2hTLv8oNH5e\n9H+3TUke0uO6Ttl0bZepoMmPlpAXhJByISqC6SLth4WFIH+G1I/xt9AEM7hOfLMl\nKQv/3wlLEgEueRryKAHB2tqkaDKVJyw+tOyWj2iWA+nVgQKAxO4hOw01ljyVbcx6\nKboXwnamlZPFIx4tjEaZ+ClXCFqvXhE9LDFK11QsYzJZl0aRVfTNqcurhEt7SK0f\nqzOBhID0Nxk4k9sW1uT6ocW1xp1SB2WotORssOKIAOLJM8IbPl6n/DkYNcfvyXI7\n4BlUrf6M2DgZMYATabIy94AvopHJOyiRfh4NpQPDntWnShiI1em2MmtXiWFCdVFV\n6/QfJTKVixJpVfDh386ALXc97EPWDMWIalUwYoV/eRSMnuV8nZ0+Ctp3Qrtk/JYd\n+FWhKbtlPeRjmGVr6mVlvDJ7KqtY5/RqqwfWeXhXezGhQqQ/OoQQCRkCAwEAAQ==\n-----END RSA PUBLIC KEY-----`;\n\n// not using a library for this as the entry countries use can be differnt than the ISO 3166-1 alpha-3 standard\nexport const countryCodes = {\n  AFG: 'Afghanistan',\n  ALA: 'Aland Islands',\n  ALB: 'Albania',\n  DZA: 'Algeria',\n  ASM: 'American Samoa',\n  AND: 'Andorra',\n  AGO: 'Angola',\n  AIA: 'Anguilla',\n  ATA: 'Antarctica',\n  ATG: 'Antigua and Barbuda',\n  ARG: 'Argentina',\n  ARM: 'Armenia',\n  ABW: 'Aruba',\n  AUS: 'Australia',\n  AUT: 'Austria',\n  AZE: 'Azerbaijan',\n  BHS: 'Bahamas',\n  BHR: 'Bahrain',\n  BGD: 'Bangladesh',\n  BRB: 'Barbados',\n  BLR: 'Belarus',\n  BEL: 'Belgium',\n  BLZ: 'Belize',\n  BEN: 'Benin',\n  BMU: 'Bermuda',\n  BTN: 'Bhutan',\n  BOL: 'Bolivia (Plurinational State of)',\n  BES: 'Bonaire, Sint Eustatius and Saba',\n  BIH: 'Bosnia and Herzegovina',\n  BWA: 'Botswana',\n  BVT: 'Bouvet Island',\n  BRA: 'Brazil',\n  IOT: 'British Indian Ocean Territory',\n  BRN: 'Brunei Darussalam',\n  BGR: 'Bulgaria',\n  BFA: 'Burkina Faso',\n  BDI: 'Burundi',\n  CPV: 'Cabo Verde',\n  KHM: 'Cambodia',\n  CMR: 'Cameroon',\n  CAN: 'Canada',\n  CYM: 'Cayman Islands',\n  CAF: 'Central African Republic',\n  TCD: 'Chad',\n  CHL: 'Chile',\n  CHN: 'China',\n  CXR: 'Christmas Island',\n  CCK: 'Cocos (Keeling) Islands',\n  COL: 'Colombia',\n  COM: 'Comoros',\n  COG: 'Congo',\n  COD: 'Congo, Democratic Republic of the',\n  COK: 'Cook Islands',\n  CRI: 'Costa Rica',\n  CIV: \"Cote d'Ivoire\",\n  HRV: 'Croatia',\n  CUB: 'Cuba',\n  CUW: 'Curacao',\n  CYP: 'Cyprus',\n  CZE: 'Czechia',\n  DNK: 'Denmark',\n  DJI: 'Djibouti',\n  DMA: 'Dominica',\n  DOM: 'Dominican Republic',\n  ECU: 'Ecuador',\n  EGY: 'Egypt',\n  SLV: 'El Salvador',\n  GNQ: 'Equatorial Guinea',\n  ERI: 'Eritrea',\n  EST: 'Estonia',\n  SWZ: 'Eswatini',\n  ETH: 'Ethiopia',\n  FLK: 'Falkland Islands (Malvinas)',\n  FRO: 'Faroe Islands',\n  FJI: 'Fiji',\n  FIN: 'Finland',\n  FRA: 'France',\n  GUF: 'French Guiana',\n  PYF: 'French Polynesia',\n  ATF: 'French Southern Territories',\n  GAB: 'Gabon',\n  GMB: 'Gambia',\n  GEO: 'Georgia',\n  DEU: 'Germany',\n  'D<<': 'Germany', // Bundesrepublik Deutschland uses this in passports instead of DEU\n  GHA: 'Ghana',\n  GIB: 'Gibraltar',\n  GRC: 'Greece',\n  GRL: 'Greenland',\n  GRD: 'Grenada',\n  GLP: 'Guadeloupe',\n  GUM: 'Guam',\n  GTM: 'Guatemala',\n  GGY: 'Guernsey',\n  GIN: 'Guinea',\n  GNB: 'Guinea-Bissau',\n  GUY: 'Guyana',\n  HTI: 'Haiti',\n  HMD: 'Heard Island and McDonald Islands',\n  VAT: 'Holy See',\n  HND: 'Honduras',\n  HKG: 'Hong Kong',\n  HUN: 'Hungary',\n  ISL: 'Iceland',\n  IND: 'India',\n  IDN: 'Indonesia',\n  IRN: 'Iran (Islamic Republic of)',\n  IRQ: 'Iraq',\n  IRL: 'Ireland',\n  IMN: 'Isle of Man',\n  ISR: 'Israel',\n  ITA: 'Italy',\n  JAM: 'Jamaica',\n  JPN: 'Japan',\n  JEY: 'Jersey',\n  JOR: 'Jordan',\n  KAZ: 'Kazakhstan',\n  KEN: 'Kenya',\n  KIR: 'Kiribati',\n  PRK: \"Korea (Democratic People's Republic of)\",\n  KOR: 'Korea, Republic of',\n  KWT: 'Kuwait',\n  KGZ: 'Kyrgyzstan',\n  LAO: \"Lao People's Democratic Republic\",\n  LVA: 'Latvia',\n  LBN: 'Lebanon',\n  LSO: 'Lesotho',\n  LBR: 'Liberia',\n  LBY: 'Libya',\n  LIE: 'Liechtenstein',\n  LTU: 'Lithuania',\n  LUX: 'Luxembourg',\n  MAC: 'Macao',\n  MDG: 'Madagascar',\n  MWI: 'Malawi',\n  MYS: 'Malaysia',\n  MDV: 'Maldives',\n  MLI: 'Mali',\n  MLT: 'Malta',\n  MHL: 'Marshall Islands',\n  MTQ: 'Martinique',\n  MRT: 'Mauritania',\n  MUS: 'Mauritius',\n  MYT: 'Mayotte',\n  MEX: 'Mexico',\n  FSM: 'Micronesia (Federated States of)',\n  MDA: 'Moldova, Republic of',\n  MCO: 'Monaco',\n  MNG: 'Mongolia',\n  MNE: 'Montenegro',\n  MSR: 'Montserrat',\n  MAR: 'Morocco',\n  MOZ: 'Mozambique',\n  MMR: 'Myanmar',\n  NAM: 'Namibia',\n  NRU: 'Nauru',\n  NPL: 'Nepal',\n  NLD: 'Netherlands',\n  NCL: 'New Caledonia',\n  NZL: 'New Zealand',\n  NIC: 'Nicaragua',\n  NER: 'Niger',\n  NGA: 'Nigeria',\n  NIU: 'Niue',\n  NFK: 'Norfolk Island',\n  MKD: 'North Macedonia',\n  MNP: 'Northern Mariana Islands',\n  NOR: 'Norway',\n  OMN: 'Oman',\n  PAK: 'Pakistan',\n  PLW: 'Palau',\n  PSE: 'Palestine, State of',\n  PAN: 'Panama',\n  PNG: 'Papua New Guinea',\n  PRY: 'Paraguay',\n  PER: 'Peru',\n  PHL: 'Philippines',\n  PCN: 'Pitcairn',\n  POL: 'Poland',\n  PRT: 'Portugal',\n  PRI: 'Puerto Rico',\n  QAT: 'Qatar',\n  REU: 'Reunion',\n  ROU: 'Romania',\n  RUS: 'Russian Federation',\n  RWA: 'Rwanda',\n  BLM: 'Saint Barthelemy',\n  SHN: 'Saint Helena, Ascension and Tristan da Cunha',\n  KNA: 'Saint Kitts and Nevis',\n  LCA: 'Saint Lucia',\n  MAF: 'Saint Martin (French part)',\n  SPM: 'Saint Pierre and Miquelon',\n  VCT: 'Saint Vincent and the Grenadines',\n  WSM: 'Samoa',\n  SMR: 'San Marino',\n  STP: 'Sao Tome and Principe',\n  SAU: 'Saudi Arabia',\n  SEN: 'Senegal',\n  SRB: 'Serbia',\n  SYC: 'Seychelles',\n  SLE: 'Sierra Leone',\n  SGP: 'Singapore',\n  SXM: 'Sint Maarten (Dutch part)',\n  SVK: 'Slovakia',\n  SVN: 'Slovenia',\n  SLB: 'Solomon Islands',\n  SOM: 'Somalia',\n  ZAF: 'South Africa',\n  SGS: 'South Georgia and the South Sandwich Islands',\n  SSD: 'South Sudan',\n  ESP: 'Spain',\n  LKA: 'Sri Lanka',\n  SDN: 'Sudan',\n  SUR: 'Suriname',\n  SJM: 'Svalbard and Jan Mayen',\n  SWE: 'Sweden',\n  CHE: 'Switzerland',\n  SYR: 'Syrian Arab Republic',\n  TWN: 'Taiwan, Province of China',\n  TJK: 'Tajikistan',\n  TZA: 'Tanzania, United Republic of',\n  THA: 'Thailand',\n  TLS: 'Timor-Leste',\n  TGO: 'Togo',\n  TKL: 'Tokelau',\n  TON: 'Tonga',\n  TTO: 'Trinidad and Tobago',\n  TUN: 'Tunisia',\n  TUR: 'Turkey',\n  TKM: 'Turkmenistan',\n  TCA: 'Turks and Caicos Islands',\n  TUV: 'Tuvalu',\n  UGA: 'Uganda',\n  UKR: 'Ukraine',\n  ARE: 'United Arab Emirates',\n  GBR: 'United Kingdom of Great Britain and Northern Ireland',\n  USA: 'United States of America',\n  UMI: 'United States Minor Outlying Islands',\n  URY: 'Uruguay',\n  UZB: 'Uzbekistan',\n  VUT: 'Vanuatu',\n  VEN: 'Venezuela (Bolivarian Republic of)',\n  VNM: 'Viet Nam',\n  VGB: 'Virgin Islands (British)',\n  VIR: 'Virgin Islands (U.S.)',\n  WLF: 'Wallis and Futuna',\n  ESH: 'Western Sahara',\n  YEM: 'Yemen',\n  ZMB: 'Zambia',\n  ZWE: 'Zimbabwe',\n};\n\nexport function getCountryCode(countryName: string): string {\n  const entries = Object.entries(countryCodes);\n  const found = entries.find(([_, name]) => name.toLowerCase() === countryName.toLowerCase());\n  return found ? found[0] : 'undefined';\n}\n\nexport const hashAlgos = ['sha512', 'sha384', 'sha256', 'sha224', 'sha1'];\n\nexport const k_csca = 35;\n\nexport const k_dsc = 35;\n\n//48;\nexport const k_dsc_3072 = 35;\n\nexport const k_dsc_4096 = 35;\n\nexport const k_dsc_ecdsa = 4;\n\nexport const max_csca_bytes = 1792;\n\nexport const max_dsc_bytes = 1792;\n\nexport const n_csca = 120;\n\nexport const n_dsc = 120;\n\nexport const n_dsc_3072 = 120;\n\nexport const n_dsc_4096 = 120;\n\nexport const n_dsc_ecdsa = 64;\n\n// max formatted and concatenated datagroup hashes length in bytes\nexport const revealedDataTypes = {\n  issuing_state: 0,\n  name: 1,\n  passport_number: 2,\n  nationality: 3,\n  date_of_birth: 4,\n  gender: 5,\n  expiry_date: 6,\n  older_than: 7,\n  passport_no_ofac: 8,\n  name_and_dob_ofac: 9,\n  name_and_yob_ofac: 10,\n};\n\nexport const saltLengths = [64, 48, 32];\n","import { ethers } from 'ethers';\n// @ts-ignore - ESLint incorrectly flags this as needing default import, but TypeScript definitions use named export\nimport { sha1 } from 'js-sha1';\nimport { sha224, sha256 } from 'js-sha256';\nimport { sha384, sha512 } from 'js-sha512';\nimport * as forge from 'node-forge';\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from 'poseidon-lite';\n\nimport { hexToSignedBytes, packBytesArray } from './bytes.js';\n\nexport function calculateUserIdentifierHash(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): BigInt {\n  const solidityPackedUserContextData = getSolidityPackedUserContextData(\n    destChainID,\n    userID,\n    userDefinedData\n  );\n  const inputBytes = Buffer.from(solidityPackedUserContextData.slice(2), 'hex');\n  const sha256Hash = ethers.sha256(inputBytes);\n  const ripemdHash = ethers.ripemd160(sha256Hash);\n  return BigInt(ripemdHash);\n}\n\nexport function customHasher(pubKeyFormatted: string[]) {\n  if (pubKeyFormatted.length < 16) {\n    // if k is less than 16, we can use a single poseidon hash\n    return flexiblePoseidon(pubKeyFormatted.map(BigInt)).toString();\n  } else {\n    const rounds = Math.ceil(pubKeyFormatted.length / 16); // do up to 16 rounds of poseidon\n    if (rounds > 16) {\n      throw new Error('Number of rounds is greater than 16');\n    }\n    const hash = new Array(rounds);\n    for (let i = 0; i < rounds; i++) {\n      hash[i] = { inputs: new Array(16).fill(BigInt(0)) };\n    }\n    for (let i = 0; i < rounds; i++) {\n      for (let j = 0; j < 16; j++) {\n        if (i * 16 + j < pubKeyFormatted.length) {\n          hash[i].inputs[j] = BigInt(pubKeyFormatted[i * 16 + j]);\n        }\n      }\n    }\n    const finalHash = flexiblePoseidon(hash.map((h) => poseidon16(h.inputs)));\n    return finalHash.toString();\n  }\n}\n\nexport function flexiblePoseidon(inputs: bigint[]): bigint {\n  switch (inputs.length) {\n    case 1:\n      return poseidon1(inputs);\n    case 2:\n      return poseidon2(inputs);\n    case 3:\n      return poseidon3(inputs);\n    case 4:\n      return poseidon4(inputs);\n    case 5:\n      return poseidon5(inputs);\n    case 6:\n      return poseidon6(inputs);\n    case 7:\n      return poseidon7(inputs);\n    case 8:\n      return poseidon8(inputs);\n    case 9:\n      return poseidon9(inputs);\n    case 10:\n      return poseidon10(inputs);\n    case 11:\n      return poseidon11(inputs);\n    case 12:\n      return poseidon12(inputs);\n    case 13:\n      return poseidon13(inputs);\n    case 14:\n      return poseidon14(inputs);\n    case 15:\n      return poseidon15(inputs);\n    case 16:\n      return poseidon16(inputs);\n    default:\n      throw new Error(`Unsupported number of inputs: ${inputs.length}`);\n  }\n}\n\nexport function getHashLen(hashFunction: string) {\n  switch (hashFunction) {\n    case 'sha1':\n      return 20;\n    case 'sha224':\n      return 28;\n    case 'sha256':\n      return 32;\n    case 'sha384':\n      return 48;\n    case 'sha512':\n      return 64;\n    default:\n      console.log(`${hashFunction} not found in getHashLen`);\n      return 32;\n  }\n}\n\nexport function getSolidityPackedUserContextData(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): string {\n  const userIdHex = userID.replace(/-/g, '');\n  return ethers.solidityPacked(\n    ['bytes32', 'bytes32', 'bytes'],\n    [\n      ethers.zeroPadValue(ethers.toBeHex(destChainID), 32),\n      ethers.zeroPadValue('0x' + userIdHex, 32),\n      ethers.toUtf8Bytes(userDefinedData),\n    ]\n  );\n}\n\n// hash function - crypto is not supported in react native\nexport function hash(\n  hashFunction: string,\n  bytesArray: number[],\n  format: string = 'bytes'\n): string | number[] {\n  const unsignedBytesArray = bytesArray.map((byte) => byte & 0xff);\n  let hashResult: string;\n\n  switch (hashFunction) {\n    case 'sha1':\n      hashResult = sha1(unsignedBytesArray);\n      break;\n    case 'sha224':\n      hashResult = sha224(unsignedBytesArray);\n      break;\n    case 'sha256':\n      hashResult = sha256(unsignedBytesArray);\n      break;\n    case 'sha384':\n      hashResult = sha384(unsignedBytesArray);\n      break;\n    case 'sha512':\n      hashResult = sha512(unsignedBytesArray);\n      break;\n    default:\n      console.log('\\x1b[31m%s\\x1b[0m', `${hashFunction} not found in hash`); // Log in red\n      hashResult = sha256(unsignedBytesArray); // Default to sha256\n  }\n  if (format === 'hex') {\n    return hashResult;\n  }\n  if (format === 'bytes') {\n    return hexToSignedBytes(hashResult);\n  }\n  const actualForgeUtil = forge.util ? forge.util : (forge as any).default.util;\n  if (format === 'binary') {\n    return actualForgeUtil.binary.raw.encode(new Uint8Array(hexToSignedBytes(hashResult)));\n  }\n  throw new Error(`Invalid format: ${format}`);\n}\n\nexport function packBytesAndPoseidon(unpacked: number[]) {\n  const packed = packBytesArray(unpacked);\n  return customHasher(packed.map(String)).toString();\n}\n","import { MAX_BYTES_IN_FIELD } from '../constants/constants.js';\n\nexport function bigIntToChunkedBytes(\n  num: BigInt | bigint,\n  bytesPerChunk: number,\n  numChunks: number\n) {\n  const res: string[] = [];\n  const bigintNum: bigint = typeof num == 'bigint' ? num : num.valueOf();\n  const msk = (1n << BigInt(bytesPerChunk)) - 1n;\n  for (let i = 0; i < numChunks; ++i) {\n    res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());\n  }\n  return res;\n}\nexport function bytesToBigDecimal(arr: number[]): string {\n  let result = BigInt(0);\n  for (let i = 0; i < arr.length; i++) {\n    result = result * BigInt(256) + BigInt(arr[i] & 0xff);\n  }\n  return result.toString();\n}\n\nexport function computeIntChunkLength(byteLength: number) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const remain = byteLength % packSize;\n  let numChunks = (byteLength - remain) / packSize;\n  if (remain > 0) {\n    numChunks += 1;\n  }\n  return numChunks;\n}\n\nexport function derToBytes(derValue: string) {\n  const bytes = [];\n  for (let i = 0; i < derValue.length; i++) {\n    bytes.push(derValue.charCodeAt(i));\n  }\n  return bytes;\n}\n\nexport function hexStringToSignedIntArray(hexString: string) {\n  const result = [];\n  for (let i = 0; i < hexString.length; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    result.push(byte > 127 ? byte - 256 : byte);\n  }\n  return result;\n}\n\nexport function hexToBin(n: string): string {\n  let bin = Number(`0x${n[0]}`).toString(2);\n  for (let i = 1; i < n.length; i += 1) {\n    bin += Number(`0x${n[i]}`).toString(2).padStart(4, '0');\n  }\n  return bin;\n}\n\nexport function hexToDecimal(hex: string): string {\n  return BigInt(`0x${hex}`).toString();\n}\n\nexport function hexToSignedBytes(hexString: string): number[] {\n  const bytes = [];\n  for (let i = 0; i < hexString.length - 1; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    bytes.push(byte >= 128 ? byte - 256 : byte);\n  }\n  return bytes;\n}\n\nexport function num2Bits(n: number, inValue: bigint): bigint[] {\n  const out: bigint[] = new Array(n).fill(BigInt(0));\n  let lc1: bigint = BigInt(0);\n  let e2: bigint = BigInt(1);\n\n  for (let i = 0; i < n; i++) {\n    out[i] = (inValue >> BigInt(i)) & BigInt(1);\n\n    if (out[i] !== BigInt(0) && out[i] !== BigInt(1)) {\n      throw new Error('Bit value is not binary.');\n    }\n\n    lc1 += out[i] * e2;\n    e2 = e2 << BigInt(1);\n  }\n\n  if (lc1 !== inValue) {\n    throw new Error('Reconstructed value does not match the input.');\n  }\n  return out;\n}\n\nexport function packBytes(unpacked) {\n  const bytesCount = [31, 31, 31];\n  const packed = [0n, 0n, 0n];\n\n  let byteIndex = 0;\n  for (let i = 0; i < bytesCount.length; i++) {\n    for (let j = 0; j < bytesCount[i]; j++) {\n      if (byteIndex < unpacked.length) {\n        packed[i] |= BigInt(unpacked[byteIndex]) << (BigInt(j) * 8n);\n      }\n      byteIndex++;\n    }\n  }\n  return packed;\n}\n\nexport function packBytesArray(unpacked: number[]) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const maxBytes = unpacked.length;\n  const maxInts = computeIntChunkLength(maxBytes);\n  const out: bigint[] = new Array(maxInts).fill(0n);\n\n  for (let i = 0; i < maxInts; i++) {\n    let sum = 0n;\n    for (let j = 0; j < packSize; j++) {\n      const idx = packSize * i + j;\n\n      // Copy previous value if out of bounds\n      if (idx >= maxBytes) {\n        continue;\n      }\n      // First item of chunk is byte itself\n      else if (j === 0) {\n        sum = BigInt(unpacked[idx]);\n      }\n      // Every other item is 256^j * byte\n      else {\n        sum += (1n << BigInt(8 * j)) * BigInt(unpacked[idx]);\n      }\n    }\n    out[i] = sum;\n  }\n\n  return out;\n}\n\nexport function splitToWords(number: bigint, wordsize: number, numberElement: number) {\n  let t = number;\n  const words: string[] = [];\n  for (let i = 0; i < numberElement; ++i) {\n    const baseTwo = BigInt(2);\n\n    words.push(`${t % BigInt(Math.pow(Number(baseTwo), wordsize))}`);\n    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), wordsize)));\n  }\n  if (!(t == BigInt(0))) {\n    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;\n  }\n  return words;\n}\n\nexport const toBinaryString = (byte: any) => {\n  const binary = (parseInt(byte, 10) & 0xff).toString(2).padStart(8, '0');\n  return binary;\n};\n\nexport function toSigned(byte: number) {\n  return byte > 127 ? byte - 256 : byte;\n}\nexport function toUnsigned(byte: number) {\n  return byte & 0xff;\n}\nexport function toUnsignedByte(signedByte: number) {\n  return signedByte < 0 ? signedByte + 256 : signedByte;\n}\n","import * as forge from 'node-forge';\nimport { poseidon5 } from 'poseidon-lite';\n\nimport type { hashAlgos } from '../../constants/constants.js';\nimport {\n  k_csca,\n  k_dsc,\n  k_dsc_3072,\n  k_dsc_4096,\n  k_dsc_ecdsa,\n  n_csca,\n  n_dsc,\n  n_dsc_3072,\n  n_dsc_4096,\n  n_dsc_ecdsa,\n} from '../../constants/constants.js';\nimport { bytesToBigDecimal, hexToDecimal, splitToWords } from '../bytes.js';\nimport type {\n  CertificateData,\n  PublicKeyDetailsECDSA,\n  PublicKeyDetailsRSA,\n} from '../certificate_parsing/dataStructure.js';\nimport {\n  getCertificateFromPem,\n  parseCertificateSimple,\n} from '../certificate_parsing/parseCertificateSimple.js';\nimport { formatInput } from '../circuits/generateInputs.js';\nimport { findStartIndex, findStartIndexEC } from '../csca.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { sha384_512Pad, shaPad } from '../shaPad.js';\nimport { getLeafDscTree } from '../trees.js';\nimport type { PassportData, SignatureAlgorithm } from '../types.js';\nimport { formatMrz } from './format.js';\nimport { parsePassportData } from './passport_parsing/parsePassportData.js';\n\nexport function extractRSFromSignature(signatureBytes: number[]): { r: string; s: string } {\n  const derSignature = Buffer.from(signatureBytes).toString('binary');\n  const asn1 = forge.asn1.fromDer(derSignature);\n  const signatureAsn1 = asn1.value;\n\n  if (signatureAsn1.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n\n  if (!Array.isArray(asn1.value) || asn1.value.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n  const r = forge.util.createBuffer(asn1.value[0].value as string).toHex();\n  const s = forge.util.createBuffer(asn1.value[1].value as string).toHex();\n\n  return { r, s };\n}\n\nexport function extractSignatureFromDSC(dscCertificate: string) {\n  const cert = getCertificateFromPem(dscCertificate);\n  const dscSignature = cert.signatureValue.valueBlock.valueHexView;\n  return Array.from(dscSignature);\n}\n\nexport function findStartPubKeyIndex(\n  certificateData: CertificateData,\n  rawCert: any,\n  signatureAlgorithm: string\n): [number, number] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const [x_index, x_totalLength] = findStartIndexEC(x, rawCert);\n    const [y_index, y_totalLength] = findStartIndexEC(y, rawCert);\n\n    return [x_index, x_totalLength + y_totalLength];\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return findStartIndex(modulus, rawCert);\n  }\n}\n\n/// @notice Get the public key from the certificate padded as per the DSC circuit's requirements.\nexport function formatCertificatePubKeyDSC(\n  certificateData: CertificateData,\n  signatureAlgorithm: string\n): string[] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    // const normalizedX = x.length % 2 === 0 ? x : '0' + x;\n    // const normalizedY = y.length % 2 === 0 ? y : '0' + y;\n    const fullPubKey = x + y;\n\n    // Splits to 525 words of 8 bits each\n    return splitToWords(BigInt(hexToDecimal(fullPubKey)), 8, 525);\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), 8, 525);\n  }\n}\n\nexport function formatSignatureDSCCircuit(\n  cscaSignatureAlgorithm: string,\n  cscaHashFunction: string,\n  cscaCertificateData: CertificateData,\n  signature: number[]\n): string[] {\n  const cscaSignatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    cscaCertificateData,\n    cscaSignatureAlgorithm,\n    cscaHashFunction\n  );\n  const { n, k } = getNAndK(cscaSignatureAlgorithmFullName as SignatureAlgorithm);\n  if (cscaSignatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(signature);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return formatInput(splitToWords(BigInt(bytesToBigDecimal(signature)), n, k));\n  }\n}\n\nexport function generateCommitment(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData\n) {\n  const passportMetadata = passportData.passportMetadata;\n\n  const dg1_packed_hash = packBytesAndPoseidon(formatMrz(passportData.mrz));\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(passportData.eContent),\n    'bytes'\n  );\n\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_hash = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n  // Log the values used to generate the commitment\n\n  return poseidon5([\n    secret,\n    attestation_id,\n    dg1_packed_hash,\n    eContent_packed_hash,\n    dsc_hash,\n  ]).toString();\n}\n\nfunction getPassportSignature(passportData: PassportData, n: number, k: number): any {\n  const { signatureAlgorithm } = passportData.dsc_parsed;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(passportData.encryptedDigest);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return splitToWords(BigInt(bytesToBigDecimal(passportData.encryptedDigest)), n, k);\n  }\n}\n\nexport function generateNullifier(passportData: PassportData) {\n  const signedAttr_shaBytes = hash(\n    passportData.passportMetadata.signedAttrHashFunction,\n    Array.from(passportData.signedAttr),\n    'bytes'\n  );\n  const signedAttr_packed_hash = packBytesAndPoseidon(\n    (signedAttr_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n  return signedAttr_packed_hash;\n}\n\n/// @notice Get the public key from the certificate\n/// @dev valid for both DSC and CSCA\nexport function getCertificatePubKey(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashFunction: string\n): any {\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    certificateData,\n    signatureAlgorithm,\n    hashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const x_dsc = splitToWords(BigInt(hexToDecimal(x)), n, k);\n    const y_dsc = splitToWords(BigInt(hexToDecimal(y)), n, k);\n    return [...x_dsc, ...y_dsc];\n  } else {\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), n, k);\n  }\n}\n\nexport function getNAndK(sigAlg: SignatureAlgorithm) {\n  if (sigAlg === 'rsa_sha256_65537_3072') {\n    return { n: n_dsc_3072, k: k_dsc }; // 3072/32 = 96\n  }\n\n  if (sigAlg.startsWith('ecdsa_')) {\n    if (sigAlg.endsWith('224')) {\n      return { n: 32, k: 7 };\n    } else if (sigAlg.endsWith('256')) {\n      return { n: n_dsc_ecdsa, k: 4 };\n    } else if (sigAlg.endsWith('384')) {\n      return { n: n_dsc_ecdsa, k: 6 };\n    } else if (sigAlg.endsWith('512')) {\n      return { n: n_dsc_ecdsa, k: 8 };\n    } else if (sigAlg.endsWith('521')) {\n      return { n: 66, k: 8 };\n    } else {\n      throw new Error('invalid key size');\n    }\n  }\n\n  if (sigAlg.startsWith('rsapss_')) {\n    const keyLength = parseInt(sigAlg.split('_')[3]);\n\n    if (keyLength === 3072) {\n      return { n: n_dsc_3072, k: k_dsc_3072 }; // 3072/32 = 96\n    }\n\n    if (keyLength === 4096) {\n      return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n    }\n    return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n  }\n\n  if (sigAlg === 'rsa_sha256_65537_4096' || sigAlg === 'rsa_sha512_65537_4096') {\n    return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n  }\n\n  return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n}\n\nexport function getNAndKCSCA(sigAlg: 'rsa' | 'ecdsa' | 'rsapss') {\n  const n = sigAlg === 'ecdsa' ? n_dsc_ecdsa : n_csca;\n  const k = sigAlg === 'ecdsa' ? k_dsc_ecdsa : k_csca;\n  return { n, k };\n}\n\n/// @notice Get the signature of the passport and the public key of the DSC\n/// @dev valid for only for the passport/dsc chain\nexport function getPassportSignatureInfos(passportData: PassportData) {\n  const passportMetadata = passportData.passportMetadata;\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    passportData.dsc_parsed,\n    passportMetadata.signatureAlgorithm,\n    passportMetadata.signedAttrHashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n\n  return {\n    pubKey: getCertificatePubKey(\n      passportData.dsc_parsed,\n      passportMetadata.signatureAlgorithm,\n      passportMetadata.signedAttrHashFunction\n    ),\n    signature: getPassportSignature(passportData, n, k),\n    signatureAlgorithmFullName: signatureAlgorithmFullName,\n  };\n}\n\n/// @notice Get the signature algorithm full name\n/// @dev valid for both DSC and CSCA\nexport function getSignatureAlgorithmFullName(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashAlgorithm: string\n): string {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    return `${signatureAlgorithm}_${hashAlgorithm}_${(publicKeyDetails as PublicKeyDetailsECDSA).curve}_${publicKeyDetails.bits}`;\n  } else {\n    const { exponent } = publicKeyDetails as PublicKeyDetailsRSA;\n    return `${signatureAlgorithm}_${hashAlgorithm}_${exponent}_${publicKeyDetails.bits}`;\n  }\n}\n\n/// @dev will bruteforce passport and dsc signature\nexport function initPassportDataParsing(passportData: PassportData, skiPem: any = null) {\n  const passportMetadata = parsePassportData(passportData, skiPem);\n  passportData.passportMetadata = passportMetadata;\n  const dscParsed = parseCertificateSimple(passportData.dsc);\n  passportData.dsc_parsed = dscParsed;\n  if (passportData.passportMetadata.csca) {\n    const cscaParsed = parseCertificateSimple(passportData.passportMetadata.csca);\n    passportData.csca_parsed = cscaParsed;\n  }\n  return passportData;\n}\n\nexport function pad(hashFunction: (typeof hashAlgos)[number]) {\n  return hashFunction === 'sha1' || hashFunction === 'sha224' || hashFunction === 'sha256'\n    ? shaPad\n    : sha384_512Pad;\n}\n\nexport function padWithZeroes(bytes: number[], length: number) {\n  return bytes.concat(new Array(length - bytes.length).fill(0));\n}\n","import * as asn1js from 'asn1js';\nimport { Certificate, RSAPublicKey, RSASSAPSSParams } from 'pkijs';\n\nimport { circuitNameFromMode } from '../../constants/constants.js';\nimport type { Mode } from '../appType.js';\nimport type { StandardCurve } from './curves.js';\nimport { getCurveForElliptic, getECDSACurveBits, identifyCurve } from './curves.js';\nimport type {\n  CertificateData,\n  PublicKeyDetailsECDSA,\n  PublicKeyDetailsRSA,\n  PublicKeyDetailsRSAPSS,\n} from './dataStructure.js';\nimport { initElliptic } from './elliptic.js';\nimport { getFriendlyName, getSecpFromNist } from './oids.js';\nimport { getIssuerCountryCode, getSubjectKeyIdentifier } from './utils.js';\n\nexport const getAuthorityKeyIdentifier = (cert: Certificate): string => {\n  const authorityKeyIdentifier = cert.extensions.find((ext) => ext.extnID === '2.5.29.35');\n  if (authorityKeyIdentifier) {\n    let akiValue = Buffer.from(authorityKeyIdentifier.extnValue.valueBlock.valueHexView).toString(\n      'hex'\n    );\n\n    // Match the ASN.1 sequence header pattern: 30 followed by length\n    const sequenceMatch = akiValue.match(/^30([0-9a-f]{2}|8[0-9a-f][0-9a-f])/i);\n    if (sequenceMatch) {\n      // console.log('Sequence length indicator:', sequenceMatch[1]);\n    }\n\n    // Match the keyIdentifier pattern: 80 followed by length (usually 14)\n    const keyIdMatch = akiValue.match(/80([0-9a-f]{2})/i);\n    if (keyIdMatch) {\n      const keyIdLength = parseInt(keyIdMatch[1], 16);\n      // Extract the actual key ID (length * 2 because hex)\n      const startIndex = akiValue.indexOf(keyIdMatch[0]) + 4;\n      akiValue = akiValue.slice(startIndex, startIndex + keyIdLength * 2);\n      return akiValue.toUpperCase();\n    }\n  }\n  return null;\n};\n\nfunction getParamsRSA(cert: Certificate): PublicKeyDetailsRSA {\n  const publicKeyValue = cert.subjectPublicKeyInfo.parsedKey as RSAPublicKey;\n  const modulusBytes = publicKeyValue.modulus.valueBlock.valueHexView;\n  const modulusHex = Buffer.from(modulusBytes).toString('hex');\n  const exponentBigInt = publicKeyValue.publicExponent.toBigInt();\n  const exponentDecimal = exponentBigInt.toString();\n  const actualBits = modulusBytes.length * 8;\n\n  return {\n    modulus: modulusHex,\n    exponent: exponentDecimal,\n    bits: actualBits.toString(),\n  };\n}\n\nfunction getParamsRSAPSS(cert: Certificate): PublicKeyDetailsRSAPSS {\n  // Get the subjectPublicKey BitString\n  const spki = cert.subjectPublicKeyInfo;\n  const spkiValueHex = spki.subjectPublicKey.valueBlock.valueHexView;\n\n  // Parse the public key ASN.1 structure\n  const asn1PublicKey = asn1js.fromBER(spkiValueHex);\n  if (asn1PublicKey.offset === -1) {\n    throw new Error('Error parsing public key ASN.1 structure');\n  }\n\n  // The public key is an RSAPublicKey structure\n  const rsaPublicKey = new RSAPublicKey({ schema: asn1PublicKey.result });\n  const modulusBytes = rsaPublicKey.modulus.valueBlock.valueHexView;\n  const modulusHex = Buffer.from(modulusBytes).toString('hex');\n  const exponentBigInt = rsaPublicKey.publicExponent.toBigInt();\n  const exponentDecimal = exponentBigInt.toString();\n  const actualBits = modulusBytes.length * 8;\n\n  const sigAlgParams = cert.signatureAlgorithm.algorithmParams;\n  const pssParams = new RSASSAPSSParams({ schema: sigAlgParams });\n  const hashAlgorithm = getFriendlyName(pssParams.hashAlgorithm.algorithmId);\n  const mgf = getFriendlyName(pssParams.maskGenAlgorithm.algorithmId);\n\n  return {\n    modulus: modulusHex,\n    exponent: exponentDecimal,\n    bits: actualBits.toString(),\n    hashAlgorithm: hashAlgorithm,\n    mgf: mgf,\n    saltLength: pssParams.saltLength.toString(),\n  };\n}\n\nexport function getCertificateFromPem(pemContent: string): Certificate {\n  const pemFormatted = pemContent.replace(/(-----(BEGIN|END) CERTIFICATE-----|\\n|\\r)/g, '');\n  const binary = Buffer.from(pemFormatted, 'base64');\n  const arrayBuffer = new ArrayBuffer(binary.length);\n  const view = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < binary.length; i++) {\n    view[i] = binary[i];\n  }\n\n  const asn1 = asn1js.fromBER(arrayBuffer);\n  if (asn1.offset === -1) {\n    throw new Error(`ASN.1 parsing error: ${asn1.result.error}`);\n  }\n\n  return new Certificate({ schema: asn1.result });\n}\n\nexport const getCircuitName = (\n  circuitMode: 'prove' | 'dsc' | 'vc_and_disclose',\n  signatureAlgorithm: string,\n  hashFunction: string,\n  domainParameter: string,\n  keyLength: string\n) => {\n  const circuit = circuitNameFromMode[circuitMode];\n  if (circuit == 'vc_and_disclose') {\n    return 'vc_and_disclose';\n  }\n  if (circuit == 'dsc') {\n    return (\n      circuit +\n      '_' +\n      signatureAlgorithm +\n      '_' +\n      hashFunction +\n      '_' +\n      domainParameter +\n      '_' +\n      keyLength\n    );\n  }\n  return (\n    circuit +\n    '_' +\n    signatureAlgorithm +\n    '_' +\n    hashFunction +\n    '_' +\n    domainParameter +\n    '_' +\n    keyLength\n  );\n};\n\nexport const getCircuitNameOld = (\n  circuitMode: Mode,\n  signatureAlgorithm: string,\n  hashFunction: string\n) => {\n  const circuit = circuitNameFromMode[circuitMode];\n  if (circuit == 'vc_and_disclose') {\n    return 'vc_and_disclose';\n  } else if (signatureAlgorithm === 'ecdsa') {\n    return circuit + '_' + signatureAlgorithm + '_secp256r1_' + hashFunction;\n  } else {\n    return circuit + '_' + signatureAlgorithm + '_65537_' + hashFunction;\n  }\n};\nexport function getHashAlgorithm(rawSignatureAlgorithm: string) {\n  const input = rawSignatureAlgorithm.toLowerCase();\n  const patterns = [/sha-?1/i, /sha-?224/i, /sha-?256/i, /sha-?384/i, /sha-?512/i];\n\n  for (const pattern of patterns) {\n    const match = input.match(pattern);\n    if (match) {\n      // Remove any hyphens and return standardized format\n      return match[0].replace('-', '');\n    }\n  }\n\n  return 'unknown';\n}\n\nexport function getParamsECDSA(cert: Certificate): PublicKeyDetailsECDSA {\n  try {\n    const algorithmParams = cert.subjectPublicKeyInfo.algorithm.algorithmParams;\n\n    if (!algorithmParams) {\n      console.error('No algorithm params found');\n      return {\n        curve: 'Unknown',\n        params: {} as StandardCurve,\n        bits: 'Unknown',\n        x: 'Unknown',\n        y: 'Unknown',\n      };\n    }\n\n    let curveName,\n      bits,\n      x,\n      y = 'Unknown';\n    const curveParams: StandardCurve = {} as StandardCurve;\n\n    // Try to get the curve name from the OID\n    if (algorithmParams instanceof asn1js.ObjectIdentifier) {\n      const curveOid = algorithmParams.valueBlock.toString();\n      curveName = getSecpFromNist(getFriendlyName(curveOid)) || 'Unknown';\n      bits = getECDSACurveBits(curveName);\n    }\n\n    // If the OID of the curve is not present, we try to get the curve parameters and identify the curve from them\n    else {\n      const params = asn1js.fromBER(algorithmParams.valueBeforeDecodeView).result;\n      const valueBlock: any = params.valueBlock;\n      if (valueBlock.value && valueBlock.value.length >= 5) {\n        const curveParams: StandardCurve = {} as StandardCurve;\n        // Field ID (index 1)\n        const fieldId = valueBlock.value[1];\n        if (fieldId && fieldId.valueBlock && fieldId.valueBlock.value) {\n          const fieldType = fieldId.valueBlock.value[0];\n          const prime = fieldId.valueBlock.value[1];\n          //curveParams.fieldType = fieldType.valueBlock.toString();\n          curveParams.p = Buffer.from(prime.valueBlock.valueHexView).toString('hex');\n        }\n\n        // Curve Coefficients (index 2)\n        const curveCoefficients = valueBlock.value[2];\n        if (\n          curveCoefficients &&\n          curveCoefficients.valueBlock &&\n          curveCoefficients.valueBlock.value\n        ) {\n          const a = curveCoefficients.valueBlock.value[0];\n          const b = curveCoefficients.valueBlock.value[1];\n          curveParams.a = Buffer.from(a.valueBlock.valueHexView).toString('hex');\n          curveParams.b = Buffer.from(b.valueBlock.valueHexView).toString('hex');\n        }\n\n        // Base Point G (index 3)\n        const basePoint = valueBlock.value[3];\n        if (basePoint && basePoint.valueBlock) {\n          curveParams.G = Buffer.from(basePoint.valueBlock.valueHexView).toString('hex');\n        }\n\n        // Order n (index 4)\n        const order = valueBlock.value[4];\n        if (order && order.valueBlock) {\n          curveParams.n = Buffer.from(order.valueBlock.valueHexView).toString('hex');\n        }\n\n        if (valueBlock.value.length >= 6) {\n          // Cofactor h (index 5)\n          const cofactor = valueBlock.value[5];\n          if (cofactor && cofactor.valueBlock) {\n            curveParams.h = Buffer.from(cofactor.valueBlock.valueHexView).toString('hex');\n          }\n        } else {\n          curveParams.h = '01';\n        }\n        const identifiedCurve = identifyCurve(curveParams);\n        curveName = identifiedCurve;\n        bits = getECDSACurveBits(curveName);\n      } else {\n        if (valueBlock.value) {\n          console.log(valueBlock.value);\n        } else {\n          console.log('No value block found');\n        }\n      }\n    }\n\n    // Get the public key x and y parameters\n    const publicKeyBuffer = cert.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView;\n    if (publicKeyBuffer && curveName !== 'Unknown') {\n      const elliptic = initElliptic();\n      const ec = new elliptic.ec(getCurveForElliptic(curveName));\n      const key = ec.keyFromPublic(publicKeyBuffer);\n      const x_point = key.getPublic().getX().toString('hex');\n      const y_point = key.getPublic().getY().toString('hex');\n\n      // For 521 bit curves, pad to expected length of 132 hex chars (66 bytes)\n      if (curveName === 'secp521r1' || curveName === 'brainpoolP521r1') {\n        x = x_point.padStart(132, '0');\n        y = y_point.padStart(132, '0');\n      } else {\n        // For other curves, ensure even length\n        x = x_point.length % 2 === 0 ? x_point : '0' + x_point;\n        y = y_point.length % 2 === 0 ? y_point : '0' + y_point;\n      }\n    }\n    return { curve: curveName, params: curveParams, bits: bits, x: x, y: y };\n  } catch (error) {\n    console.error('Error parsing EC parameters:', error);\n    return {\n      curve: 'Error',\n      params: {} as StandardCurve,\n      bits: 'Unknown',\n      x: 'Unknown',\n      y: 'Unknown',\n    };\n  }\n}\n\nexport function getTBSBytesForge(certificate: Certificate): number[] {\n  return Array.from(certificate.tbsView.map((byte) => parseInt(byte.toString(16), 16)));\n}\n\nexport function parseCertificateSimple(pem: string): CertificateData {\n  const certificateData: CertificateData = {\n    id: '',\n    issuer: '',\n    validity: {\n      notBefore: '',\n      notAfter: '',\n    },\n    subjectKeyIdentifier: '',\n    authorityKeyIdentifier: '',\n    signatureAlgorithm: '',\n    hashAlgorithm: '',\n    publicKeyDetails: undefined,\n    tbsBytes: undefined,\n    tbsBytesLength: '',\n    rawPem: '',\n    rawTxt: '',\n    publicKeyAlgoOID: '',\n  };\n  try {\n    const cert = getCertificateFromPem(pem);\n    certificateData.tbsBytes = getTBSBytesForge(cert);\n    certificateData.tbsBytesLength = certificateData.tbsBytes.length.toString();\n\n    const publicKeyAlgoOID = cert.subjectPublicKeyInfo.algorithm.algorithmId;\n    const publicKeyAlgoFN = getFriendlyName(publicKeyAlgoOID);\n    const signatureAlgoOID = cert.signatureAlgorithm.algorithmId;\n    const signatureAlgoFN = getFriendlyName(signatureAlgoOID);\n    certificateData.hashAlgorithm = getHashAlgorithm(signatureAlgoFN);\n    certificateData.publicKeyAlgoOID = publicKeyAlgoOID;\n    let params;\n    if (publicKeyAlgoFN === 'RSA' && signatureAlgoFN != 'RSASSA_PSS') {\n      certificateData.signatureAlgorithm = 'rsa';\n      params = getParamsRSA(cert);\n    } else if (publicKeyAlgoFN === 'ECC') {\n      certificateData.signatureAlgorithm = 'ecdsa';\n      params = getParamsECDSA(cert);\n    } else if (publicKeyAlgoFN === 'RSASSA_PSS' || signatureAlgoFN === 'RSASSA_PSS') {\n      certificateData.signatureAlgorithm = 'rsapss';\n      params = getParamsRSAPSS(cert);\n    } else {\n      console.log(publicKeyAlgoFN);\n    }\n    certificateData.publicKeyDetails = params;\n    certificateData.issuer = getIssuerCountryCode(cert);\n    certificateData.validity = {\n      notBefore: cert.notBefore.value.toString(),\n      notAfter: cert.notAfter.value.toString(),\n    };\n    const ski = getSubjectKeyIdentifier(cert);\n    certificateData.id = ski.slice(0, 12);\n    certificateData.subjectKeyIdentifier = ski;\n    certificateData.rawPem = pem;\n\n    const authorityKeyIdentifier = getAuthorityKeyIdentifier(cert);\n    certificateData.authorityKeyIdentifier = authorityKeyIdentifier;\n\n    // corner case for rsapss\n    if (\n      certificateData.signatureAlgorithm === 'rsapss' &&\n      (!certificateData.hashAlgorithm || certificateData.hashAlgorithm === 'unknown')\n    ) {\n      certificateData.hashAlgorithm = (\n        certificateData.publicKeyDetails as PublicKeyDetailsRSAPSS\n      ).hashAlgorithm;\n    }\n\n    return certificateData;\n  } catch (error) {\n    console.error(`Error processing certificate`, error);\n    throw error;\n  }\n}\n","import { API_URL, API_URL_STAGING } from '../constants/constants.js';\nimport { SKI_PEM, SKI_PEM_DEV } from '../constants/skiPem.js';\n\nexport function findOIDPosition(\n  oid: string,\n  message: number[]\n): { oid_index: number; oid_length: number } {\n  // Convert OID string like \"1.2.840.113549\" to byte array\n  const oidParts = oid.split('.').map(Number);\n\n  // First byte is 40 * first number + second number\n  const oidBytes = [40 * oidParts[0] + oidParts[1]];\n\n  // Convert remaining parts to ASN.1 DER encoding\n  for (let i = 2; i < oidParts.length; i++) {\n    let value = oidParts[i];\n    const bytes = [];\n\n    // Handle multi-byte values\n    if (value >= 128) {\n      const tempBytes = [];\n      while (value > 0) {\n        tempBytes.unshift(value & 0x7f);\n        value = value >>> 7;\n      }\n      // Set MSB for all bytes except last\n      for (let j = 0; j < tempBytes.length - 1; j++) {\n        bytes.push(tempBytes[j] | 0x80);\n      }\n      bytes.push(tempBytes[tempBytes.length - 1]);\n    } else {\n      bytes.push(value);\n    }\n    oidBytes.push(...bytes);\n  }\n\n  console.log(\n    '\\x1b[33m%s\\x1b[0m',\n    'OID bytes (hex):',\n    oidBytes.map((b) => b.toString(16).padStart(2, '0')).join(' ')\n  );\n\n  // Search for OID in message\n  // OID will be preceded by 0x06 (ASN.1 OID tag) and length byte\n  for (let i = 0; i < message.length - oidBytes.length; i++) {\n    if (message[i] === 0x06) {\n      // OID tag\n      const len = message[i + 1];\n      if (len === oidBytes.length) {\n        let found = true;\n        for (let j = 0; j < len; j++) {\n          if (message[i + 2 + j] !== oidBytes[j]) {\n            found = false;\n            break;\n          }\n        }\n        if (found) {\n          const result = {\n            oid_index: i,\n            oid_length: len + 2, // Add 2 for tag and length bytes\n          };\n          console.log('\\x1b[32m%s\\x1b[0m', 'Found OID at:', result); // Green color\n          return result;\n        }\n      }\n    }\n  }\n\n  throw new Error('OID not found in message');\n}\n\n// @returns [startIndex, length] where startIndex is the index of the first byte of the modulus in the message and length is the length of the modulus in bytes\nexport function findStartIndex(modulus: string, messagePaddedNumber: number[]): [number, number] {\n  const modulusNumArray = [];\n  for (let i = 0; i < modulus.length; i += 2) {\n    const hexPair = modulus.slice(i, i + 2);\n    const number = parseInt(hexPair, 16);\n    modulusNumArray.push(number);\n  }\n\n  // console.log('Modulus length:', modulusNumArray.length);\n  // console.log('Message length:', messagePaddedNumber.length);\n  // console.log('Modulus (hex):', modulusNumArray.map(n => n.toString(16).padStart(2, '0')).join(''));\n  // console.log('Message (hex):', messagePaddedNumber.map(n => n.toString(16).padStart(2, '0')).join(''));\n\n  for (let i = 0; i < messagePaddedNumber.length - modulusNumArray.length + 1; i++) {\n    let matched = true;\n    for (let j = 0; j < modulusNumArray.length; j++) {\n      if (modulusNumArray[j] !== messagePaddedNumber[i + j]) {\n        matched = false;\n        break;\n      }\n    }\n    if (matched) {\n      return [i, modulusNumArray.length];\n    }\n  }\n\n  throw new Error('DSC Pubkey not found in certificate');\n}\n\nexport function findStartIndexEC(point: string, messagePadded: number[]): [number, number] {\n  const pointNumArray = [];\n  for (let i = 0; i < point.length; i += 2) {\n    pointNumArray.push(parseInt(point.slice(i, i + 2), 16));\n  }\n\n  let startIndex = -1;\n\n  for (let i = 0; i < messagePadded.length - pointNumArray.length + 1; i++) {\n    const isMatch = pointNumArray.every((byte, j) => messagePadded[i + j] === byte);\n    if (isMatch) {\n      startIndex = i;\n      break;\n    }\n  }\n\n  if (startIndex === -1) {\n    throw new Error('DSC Pubkey not found in CSCA certificate');\n  }\n  return [startIndex, pointNumArray.length];\n}\n\nexport function getCSCAFromSKI(ski: string, skiPem: any = null): string {\n  const normalizedSki = ski.replace(/\\s+/g, '').toLowerCase();\n  const isSkiProvided = skiPem !== null;\n  console.log('SKI-PEM provided');\n  const cscaPemPROD = (SKI_PEM as any)[normalizedSki];\n  const cscaPemDEV = (SKI_PEM_DEV as any)[normalizedSki];\n  let cscaPem = null;\n  if (isSkiProvided) {\n    cscaPem = skiPem[normalizedSki];\n  } else {\n    cscaPem = cscaPemDEV || cscaPemPROD;\n  }\n  if (!cscaPem) {\n    console.log(\n      '\\x1b[33m%s\\x1b[0m',\n      `[WRN] CSCA with SKI ${ski} not found`,\n      'isSkiProvided: ',\n      isSkiProvided\n    );\n    throw new Error(\n      `CSCA not found, authorityKeyIdentifier: ${ski}, isSkiProvided: ${isSkiProvided}`\n    );\n  }\n  if (!cscaPem.includes('-----BEGIN CERTIFICATE-----')) {\n    cscaPem = `-----BEGIN CERTIFICATE-----\\n${cscaPem}\\n-----END CERTIFICATE-----`;\n  }\n  return cscaPem;\n}\n\nexport async function getSKIPEM(\n  environment: 'staging' | 'production'\n): Promise<{ [key: string]: string }> {\n  const skiPemUrl = (environment === 'staging' ? API_URL_STAGING : API_URL) + '/ski-pem';\n  console.log('Fetching SKI-PEM mapping from:', skiPemUrl);\n  try {\n    const response = await fetch(skiPemUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP error fetching ${skiPemUrl}! status: ${response.status}`);\n    }\n\n    const responseText = await response.text();\n    const jsonData = JSON.parse(responseText);\n\n    if (\n      !jsonData ||\n      typeof jsonData !== 'object' ||\n      !jsonData.data ||\n      typeof jsonData.data !== 'object'\n    ) {\n      console.error('Unexpected JSON structure received:', jsonData);\n      throw new Error('Unexpected JSON structure received from SKI-PEM endpoint.');\n    }\n\n    console.log('Parsed SKI-PEM data received.');\n\n    return jsonData.data;\n  } catch (error) {\n    console.error('Error fetching or parsing ski-pem:', error);\n    throw new Error(\n      `Failed to get SKIPEM: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n","export function assert(cond: boolean, errorMessage: string) {\n  if (!cond) {\n    throw new Error(errorMessage);\n  }\n}\n\n// Works only on 32 bit sha text lengths\nexport function int64toBytes(num: number): Uint8Array {\n  const arr = new ArrayBuffer(8); // an Int32 takes 4 bytes\n  const view = new DataView(arr);\n  view.setInt32(4, num, false); // byteOffset = 0; litteEndian = false\n  return new Uint8Array(arr);\n}\n\n// Helper function to convert 128-bit length to bytes\nfunction int128toBytes(x: number): Uint8Array {\n  const buffer = new ArrayBuffer(16);\n  const view = new DataView(buffer);\n\n  // Write high 64 bits\n  view.setBigUint64(0, BigInt(0), false);\n  // Write low 64 bits\n  view.setBigUint64(8, BigInt(x), false);\n\n  return new Uint8Array(buffer);\n}\n\n// Works only on 32 bit sha text lengths\nexport function int8toBytes(num: number): Uint8Array {\n  const arr = new ArrayBuffer(1); // an Int8 takes 4 bytes\n  const view = new DataView(arr);\n  view.setUint8(0, num); // byteOffset = 0; litteEndian = false\n  return new Uint8Array(arr);\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n  // sum of individual array lengths\n  const mergedArray = new Uint8Array(a1.length + a2.length);\n  mergedArray.set(a1);\n  mergedArray.set(a2, a1.length);\n  return mergedArray;\n}\n\nexport function sha384_512Pad(\n  prehash_prepad_m_array: number[],\n  maxShaBytes: number\n): [number[], number] {\n  let prehash_prepad_m: Uint8Array = new Uint8Array(prehash_prepad_m_array);\n  // Length in bits before padding\n  const length_bits = prehash_prepad_m.length * 8;\n\n  // For SHA-384, length is stored in 128 bits (16 bytes)\n  const length_in_bytes = int128toBytes(length_bits);\n\n  // Add the 1 bit (as a byte with value 128)\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(2 ** 7));\n\n  // Add padding zeros until total length is congruent to 896 mod 1024\n  while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 1024 !== 0) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(0));\n  }\n\n  // Append the length\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, length_in_bytes);\n\n  // Verify padding is correct (multiple of 1024 bits)\n  assert((prehash_prepad_m.length * 8) % 1024 === 0, 'Padding did not complete properly!');\n\n  const messageLen = prehash_prepad_m.length;\n\n  // Pad to max length if needed\n  while (prehash_prepad_m.length < maxShaBytes) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int128toBytes(0));\n  }\n\n  assert(\n    prehash_prepad_m.length === maxShaBytes,\n    `Padding to max length did not complete properly! Your padded message is ${prehash_prepad_m.length} long but max is ${maxShaBytes}!`\n  );\n\n  return [Array.from(prehash_prepad_m), messageLen];\n}\n\n// Copied from zk-email cuz it uses crypto so can't import it here.\n// Puts an end selector, a bunch of 0s, then the length, then fill the rest with 0s.\nexport function shaPad(prehash_prepad_m_array: number[], maxShaBytes: number): [number[], number] {\n  let prehash_prepad_m: Uint8Array = new Uint8Array(prehash_prepad_m_array);\n  const length_bits = prehash_prepad_m.length * 8; // bytes to bits\n  const length_in_bytes = int64toBytes(length_bits);\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(2 ** 7)); // Add the 1 on the end, length 505\n  while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 512 !== 0) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(0));\n  }\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, length_in_bytes);\n  assert((prehash_prepad_m.length * 8) % 512 === 0, 'Padding did not complete properly!');\n  const messageLen = prehash_prepad_m.length;\n  while (prehash_prepad_m.length < maxShaBytes) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int64toBytes(0));\n  }\n  assert(\n    prehash_prepad_m.length === maxShaBytes,\n    `Padding to max length did not complete properly! Your padded message is ${prehash_prepad_m.length} long but max is ${maxShaBytes}!`\n  );\n  return [Array.from(prehash_prepad_m), messageLen];\n}\n","import countries from 'i18n-iso-countries';\n// @ts-ignore\nimport en from 'i18n-iso-countries/langs/en.json' with { type: 'json' };\nimport { poseidon2, poseidon3, poseidon6, poseidon10, poseidon12, poseidon13 } from 'poseidon-lite';\n\nimport {\n  CSCA_TREE_DEPTH,\n  DSC_TREE_DEPTH,\n  max_csca_bytes,\n  max_dsc_bytes,\n  OFAC_TREE_LEVELS,\n} from '../constants/constants.js';\nimport type { CertificateData } from './certificate_parsing/dataStructure.js';\nimport { parseCertificateSimple } from './certificate_parsing/parseCertificateSimple.js';\nimport { stringToAsciiBigIntArray } from './circuits/uuid.js';\nimport { packBytesAndPoseidon } from './hash.js';\nimport { pad } from './passports/passport.js';\nimport type { DscCertificateMetaData } from './passports/passport_parsing/parseDscCertificateData.js';\nimport { parseDscCertificateData } from './passports/passport_parsing/parseDscCertificateData.js';\n\nimport { IMT } from '@openpassport/zk-kit-imt';\nimport { LeanIMT } from '@openpassport/zk-kit-lean-imt';\nimport type { ChildNodes } from '@openpassport/zk-kit-smt';\nimport { SMT } from '@openpassport/zk-kit-smt';\n\n// SideEffect here\ncountries.registerLocale(en);\n\n// SMT trees for 3 levels of matching :\n// 1. Passport Number and Nationality tree : level 3 (Absolute Match)\n// 2. Name and date of birth combo tree : level 2 (High Probability Match)\n// 3. Name and year of birth combo tree : level 1 (Partial Match)\n// NEW: ID card specific trees\nexport function buildSMT(field: any[], treetype: string): [number, number, SMT] {\n  let count = 0;\n  const startTime = performance.now();\n\n  const hash2 = (childNodes: ChildNodes) =>\n    childNodes.length === 2 ? poseidon2(childNodes) : poseidon3(childNodes);\n  const tree = new SMT(hash2, true);\n\n  for (let i = 0; i < field.length; i++) {\n    const entry = field[i];\n\n    // Optimization: Log progress less frequently\n    if (i !== 0 && i % 100 === 0) {\n      console.log('Processing', treetype, 'number', i, 'out of', field.length);\n    }\n\n    let leaf = BigInt(0);\n    // Determine document type based on treetype for name processing\n    let docType: 'passport' | 'id_card' = 'passport'; // Default to passport\n    if (treetype.endsWith('_id_card')) {\n      docType = 'id_card';\n    }\n\n    if (treetype == 'passport_no_and_nationality') {\n      leaf = processPassportNoAndNationality(entry.Pass_No, entry.Pass_Country, i);\n    } else if (treetype == 'name_and_dob') {\n      leaf = processNameAndDob(entry, i, 'passport'); // Explicitly passport\n    } else if (treetype == 'name_and_yob') {\n      leaf = processNameAndYob(entry, i, 'passport'); // Explicitly passport\n    } else if (treetype == 'name_and_dob_id_card') {\n      // New ID card type\n      leaf = processNameAndDob(entry, i, 'id_card');\n    } else if (treetype == 'name_and_yob_id_card') {\n      // New ID card type\n      leaf = processNameAndYob(entry, i, 'id_card');\n    } else if (treetype == 'country') {\n      const keys = Object.keys(entry);\n      leaf = processCountry(keys[0], entry[keys[0]], i);\n    }\n\n    if (leaf == BigInt(0)) {\n      // Skip entries that couldn't be processed (e.g., missing data)\n      continue;\n    }\n\n    // Check for duplicates *after* processing, as different inputs might yield the same hash\n    if (tree.createProof(leaf).membership) {\n      // console.log('Duplicate leaf generated, skipping entry:', i, entry); // Optional: log duplicates\n      continue;\n    }\n\n    count += 1;\n    tree.add(leaf, BigInt(1));\n  }\n\n  console.log('Total', treetype, 'entries added:', count, 'out of', field.length);\n  console.log(treetype, 'tree built in', (performance.now() - startTime).toFixed(2), 'ms');\n  return [count, performance.now() - startTime, tree];\n}\n\nexport function formatRoot(root: string): string {\n  const rootHex = BigInt(root).toString(16);\n  return rootHex.length % 2 === 0 ? '0x' + rootHex : '0x0' + rootHex;\n}\n\nexport function generateMerkleProof(imt: LeanIMT, _index: number, maxleaf_depth: number) {\n  const { siblings: siblings, index } = imt.generateProof(_index);\n  const leaf_depth = siblings.length;\n  // The index must be converted to a list of indices, 1 for each tree level.\n  // The circuit tree leaf_depth is 20, so the number of siblings must be 20, even if\n  // the tree leaf_depth is actually 3. The missing siblings can be set to 0, as they\n  // won't be used to calculate the root in the circuit.\n  const path: number[] = [];\n\n  for (let i = 0; i < maxleaf_depth; i += 1) {\n    path.push((index >> i) & 1);\n    if (siblings[i] === undefined) {\n      siblings[i] = BigInt(0);\n    }\n  }\n  return { siblings, path, leaf_depth };\n}\n\nexport function generateSMTProof(smt: SMT, leaf: bigint) {\n  const { entry, matchingEntry, siblings, root, membership } = smt.createProof(leaf);\n  const leaf_depth = siblings.length;\n\n  let closestleaf;\n  if (!matchingEntry) {\n    // we got the 0 leaf or membership\n    // then check if entry[1] exists\n    if (!entry[1]) {\n      // non membership proof\n      closestleaf = BigInt(0); // 0 leaf\n    } else {\n      closestleaf = BigInt(entry[0]); // leaf itself (memb proof)\n    }\n  } else {\n    // non membership proof\n    closestleaf = BigInt(matchingEntry[0]); // actual closest\n  }\n\n  // PATH, SIBLINGS manipulation as per binary tree in the circuit\n  siblings.reverse();\n  while (siblings.length < OFAC_TREE_LEVELS) siblings.push(BigInt(0));\n\n  // ----- Useful for debugging hence leaving as comments -----\n  // const binary = entry[0].toString(2)\n  // const bits = binary.slice(-leaf_depth);\n  // let indices = bits.padEnd(256, \"0\").split(\"\").map(Number)\n  // const pathToMatch = num2Bits(256,BigInt(entry[0]))\n  // while(indices.length < 256) indices.push(0);\n  // // CALCULATED ROOT FOR TESTING\n  // // closestleaf, leaf_depth, siblings, indices, root : needed\n  // let calculatedNode = poseidon3([closestleaf,1,1]);\n  // console.log(\"Initial node while calculating\",calculatedNode)\n  // console.log(smt.verifyProof(smt.createProof(leaf)))\n  // for (let i= 0; i < leaf_depth ; i++) {\n  //   const childNodes: any = indices[i] ? [siblings[i], calculatedNode] : [calculatedNode, siblings[i]]\n  //   console.log(indices[i],childNodes)\n  //   calculatedNode = poseidon2(childNodes)\n  // }\n  // console.log(\"Actual node\", root)\n  // console.log(\"calculated node\", calculatedNode)\n  // -----------------------------------------------------------\n\n  return {\n    root,\n    leaf_depth,\n    closestleaf,\n    siblings,\n  };\n}\n\nexport function getCountryLeaf(\n  country_by: (bigint | number)[],\n  country_to: (bigint | number)[],\n  i?: number\n): bigint {\n  if (country_by.length !== 3 || country_to.length !== 3) {\n    console.log('parsed passport length is not 3:', i, country_to, country_by);\n    return;\n  }\n  try {\n    const country = country_by.concat(country_to);\n    return poseidon6(country);\n  } catch (err) {\n    console.log('err : sanc_country hash', err, i, country_by, country_to);\n  }\n}\n\nexport function getCscaTreeInclusionProof(leaf: string, _serialized_csca_tree: any[][]) {\n  const tree = new IMT(poseidon2, CSCA_TREE_DEPTH, 0, 2);\n  tree.setNodes(_serialized_csca_tree);\n  const index = tree.indexOf(leaf);\n  if (index === -1) {\n    throw new Error('Your public key was not found in the registry');\n  }\n  const proof = tree.createProof(index);\n  return [\n    tree.root,\n    proof.pathIndices.map((index) => index.toString()),\n    proof.siblings.flat().map((sibling) => sibling.toString()),\n  ];\n}\n\nexport function getCscaTreeRoot(serialized_csca_tree: any[][]) {\n  const tree = new IMT(poseidon2, CSCA_TREE_DEPTH, 0, 2);\n  tree.setNodes(serialized_csca_tree);\n  return tree.root;\n}\n\nexport function getDobLeaf(dobMrz: (bigint | number)[], i?: number): bigint {\n  if (dobMrz.length !== 6) {\n    // console.log('parsed dob length is not 6:', i, dobMrz); // Corrected length check message\n    return BigInt(0); // Return 0 for invalid length\n  }\n  try {\n    return poseidon6(dobMrz);\n  } catch (err) {\n    console.error('Error in getDobLeaf:', err, 'Index:', i, 'DOB MRZ:', dobMrz); // Use console.error\n    return BigInt(0); // Return 0 on error\n  }\n}\n\nexport function getDscTreeInclusionProof(\n  leaf: string,\n  serialized_dsc_tree: string\n): [string, number[], bigint[], number] {\n  const hashFunction = (a: any, b: any) => poseidon2([a, b]);\n  const tree = LeanIMT.import(hashFunction, serialized_dsc_tree);\n  const index = tree.indexOf(BigInt(leaf));\n  if (index === -1) {\n    throw new Error('Your public key was not found in the registry');\n  }\n  const { siblings, path, leaf_depth } = generateMerkleProof(tree, index, DSC_TREE_DEPTH);\n  return [tree.root, path, siblings, leaf_depth];\n}\n\n/** get leaf for DSC and CSCA Trees */\nexport function getLeaf(parsed: CertificateData, type: 'dsc' | 'csca'): string {\n  if (type === 'dsc') {\n    // for now, we pad it for sha\n    const tbsArray = Object.keys(parsed.tbsBytes).map((key) => parsed.tbsBytes[key]);\n    const [paddedTbsBytes, tbsBytesPaddedLength] = pad(parsed.hashAlgorithm)(\n      tbsArray,\n      max_dsc_bytes\n    );\n    const dsc_hash = packBytesAndPoseidon(Array.from(paddedTbsBytes));\n\n    return poseidon2([dsc_hash, tbsArray.length]).toString();\n  } else {\n    const tbsBytesArray = Array.from(parsed.tbsBytes);\n    const paddedTbsBytesArray = tbsBytesArray.concat(\n      new Array(max_csca_bytes - tbsBytesArray.length).fill(0)\n    );\n    const csca_hash = packBytesAndPoseidon(paddedTbsBytesArray);\n    return poseidon2([csca_hash, tbsBytesArray.length]).toString();\n  }\n}\n\nexport function getLeafCscaTree(csca_parsed: CertificateData): string {\n  return getLeaf(csca_parsed, 'csca');\n}\n\nexport function getLeafDscTree(dsc_parsed: CertificateData, csca_parsed: CertificateData): string {\n  const dscLeaf = getLeaf(dsc_parsed, 'dsc');\n  const cscaLeaf = getLeaf(csca_parsed, 'csca');\n  return poseidon2([dscLeaf, cscaLeaf]).toString();\n}\n\nfunction processPassportNoAndNationality(\n  passno: string,\n  nationality: string,\n  index: number\n): bigint {\n  if (passno.length > 9) {\n    console.log('passport number length is greater than 9:', index, passno);\n  } else if (passno.length < 9) {\n    while (passno.length != 9) {\n      passno += '<';\n    }\n  }\n\n  const countryCode = getCountryCode(nationality);\n  if (!countryCode) {\n    console.log('Error getting country code', index, nationality);\n    return BigInt(0);\n  }\n  console.log('nationality and countryCode', nationality, countryCode);\n\n  const leaf = getPassportNumberAndNationalityLeaf(\n    stringToAsciiBigIntArray(passno),\n    stringToAsciiBigIntArray(countryCode),\n    index\n  );\n  if (!leaf) {\n    console.log('Error creating leaf value', index, passno, nationality);\n    return BigInt(0);\n  }\n  return leaf;\n}\n\n// this is a temporary workaround for some of the country name,\n// will be removed once we parse the OFAC list better, starting from the XML file.\nconst normalizeCountryName = (country: string): string => {\n  const mapping: Record<string, string> = {\n    palestinian: 'Palestine',\n    'korea, north': 'North Korea',\n    'korea, south': 'Korea, Republic of',\n    'united kingdom': 'United Kingdom',\n    syria: 'Syrian Arab Republic',\n    burma: 'Myanmar',\n    'cabo verde': 'Cape Verde',\n    'congo, democratic republic of the': 'Democratic Republic of the Congo',\n    macau: 'Macao',\n  };\n  return mapping[country.toLowerCase()] || country;\n};\n\nconst getCountryCode = (countryName: string): string | undefined => {\n  return countries.getAlpha3Code(normalizeCountryName(countryName), 'en');\n};\n\nfunction generateSmallKey(input: bigint): bigint {\n  return input % (BigInt(1) << BigInt(OFAC_TREE_LEVELS));\n}\n\nfunction processNameAndDob(entry: any, i: number, docType: 'passport' | 'id_card'): bigint {\n  const firstName = entry.First_Name;\n  const lastName = entry.Last_Name;\n  const day = entry.day;\n  const month = entry.month;\n  const year = entry.year;\n  if (day == null || month == null || year == null || !firstName || !lastName) {\n    // Added checks for name presence\n    // console.log('Name or DOB data missing for name_and_dob', i, entry); // Optional: log missing data\n    return BigInt(0);\n  }\n  const targetLength = docType === 'passport' ? 39 : 30;\n  const nameHash = processName(firstName, lastName, targetLength, i);\n  if (nameHash === BigInt(0)) return BigInt(0); // Propagate error\n  const dobHash = processDob(day, month, year, i);\n  if (dobHash === BigInt(0)) return BigInt(0); // Propagate error\n\n  return generateSmallKey(poseidon2([dobHash, nameHash]));\n}\n\nfunction processNameAndYob(entry: any, i: number, docType: 'passport' | 'id_card'): bigint {\n  const firstName = entry.First_Name;\n  const lastName = entry.Last_Name;\n  const year = entry.year;\n  if (year == null || !firstName || !lastName) {\n    // Added checks for name presence\n    // console.log('Name or YOB data missing for name_and_yob', i, entry); // Optional: log missing data\n    return BigInt(0);\n  }\n  const targetLength = docType === 'passport' ? 39 : 30;\n  const nameHash = processName(firstName, lastName, targetLength, i);\n  if (nameHash === BigInt(0)) return BigInt(0); // Propagate error\n  const yearHash = processYear(year, i);\n  if (yearHash === BigInt(0)) return BigInt(0); // Propagate error\n\n  return generateSmallKey(poseidon2([yearHash, nameHash]));\n}\n\nfunction processYear(year: string, i: number): bigint {\n  if (!year || typeof year !== 'string' || year.length < 2) {\n    // console.log('Invalid year format for processYear', i, year); // Optional: log error\n    return BigInt(0);\n  }\n  const yearSuffix = year.slice(-2);\n  const yearArr = stringToAsciiBigIntArray(yearSuffix);\n  return getYearLeaf(yearArr);\n}\n\nfunction getYearLeaf(yearArr: (bigint | number)[]): bigint {\n  if (yearArr.length !== 2) {\n    // console.log('Invalid year array length for getYearLeaf', yearArr); // Optional: log error\n    return BigInt(0);\n  }\n  try {\n    return poseidon2(yearArr);\n  } catch (err) {\n    // console.log('err : Year hash', err, yearArr); // Optional: log error\n    return BigInt(0);\n  }\n}\n\nfunction processName(\n  firstName: string,\n  lastName: string,\n  targetLength: 30 | 39,\n  i: number\n): bigint {\n  // LASTNAME<<FIRSTNAME<MIDDLENAME<<<...\n  // Ensure names are strings before processing\n  const cleanFirstName =\n    typeof firstName === 'string'\n      ? firstName.replace(/'/g, '').replace(/\\./g, '').replace(/[- ]/g, '<')\n      : '';\n  const cleanLastName =\n    typeof lastName === 'string'\n      ? lastName.replace(/'/g, '').replace(/[- ]/g, '<').replace(/\\./g, '')\n      : '';\n\n  // Handle cases where one name might be missing\n  let arr = (cleanLastName ? cleanLastName + '<<' : '') + cleanFirstName;\n\n  if (arr.length === 0) {\n    // console.log('Cannot process empty name string', i); // Optional: log error\n    return BigInt(0);\n  }\n\n  // Pad or truncate to target length\n  if (arr.length > targetLength) {\n    arr = arr.substring(0, targetLength);\n  } else {\n    while (arr.length < targetLength) {\n      arr += '<';\n    }\n  }\n  console.log('arr', arr, 'arr.length', arr.length);\n  const nameArr = stringToAsciiBigIntArray(arr);\n  // getNameLeaf will select the correct Poseidon hash based on nameArr.length\n  return getNameLeaf(nameArr, i);\n}\n\nfunction processDob(day: string, month: string, year: string, i: number): bigint {\n  // YYMMDD\n  const monthMap: { [key: string]: string } = {\n    jan: '01',\n    feb: '02',\n    mar: '03',\n    apr: '04',\n    may: '05',\n    jun: '06',\n    jul: '07',\n    aug: '08',\n    sep: '09',\n    oct: '10',\n    nov: '11',\n    dec: '12',\n  };\n\n  const lowerMonth = typeof month === 'string' ? month.toLowerCase() : '';\n  const mappedMonth = monthMap[lowerMonth];\n\n  if (\n    !mappedMonth ||\n    !day ||\n    typeof day !== 'string' ||\n    day.length !== 2 ||\n    !year ||\n    typeof year !== 'string' ||\n    year.length < 2\n  ) {\n    // console.log('Invalid DOB component format for processDob', i, {day, month, year}); // Optional: log error\n    return BigInt(0);\n  }\n\n  const yearSuffix = year.slice(-2);\n  const dob = yearSuffix + mappedMonth + day;\n  const arr = stringToAsciiBigIntArray(dob);\n  return getDobLeaf(arr, i);\n}\n\nfunction processCountry(country1: string, country2: string, i: number) {\n  const arr = stringToAsciiBigIntArray(country1);\n  const arr2 = stringToAsciiBigIntArray(country2);\n\n  const leaf = getCountryLeaf(arr, arr2, i);\n  if (!leaf) {\n    console.log('Error creating leaf value', i, country1, country2);\n    return BigInt(0);\n  }\n  return leaf;\n}\n\nexport function getLeafDscTreeFromDscCertificateMetadata(\n  dscParsed: CertificateData,\n  dscMetaData: DscCertificateMetaData\n): string {\n  // TODO: WRONG  change this function using raw dsc and hashfunctions from passportMetadata\n  const cscaParsed = parseCertificateSimple(dscMetaData.csca);\n  return getLeafDscTree(dscParsed, cscaParsed);\n}\n\nexport function getLeafDscTreeFromParsedDsc(dscParsed: CertificateData): string {\n  return getLeafDscTreeFromDscCertificateMetadata(dscParsed, parseDscCertificateData(dscParsed));\n}\n\nexport function getNameDobLeaf(\n  nameMrz: (bigint | number)[],\n  dobMrz: (bigint | number)[],\n  i?: number\n): bigint {\n  return generateSmallKey(poseidon2([getDobLeaf(dobMrz), getNameLeaf(nameMrz)]));\n}\n\nexport function getNameLeaf(nameMrz: (bigint | number)[], i?: number): bigint {\n  const middleChunks: bigint[] = [];\n  const chunks: (number | bigint)[][] = [];\n  try {\n    // Add try-catch block\n    if (nameMrz.length == 39) {\n      // passport\n      chunks.push(nameMrz.slice(0, 13), nameMrz.slice(13, 26), nameMrz.slice(26, 39));\n      for (const chunk of chunks) {\n        if (chunk.length !== 13)\n          throw new Error(`Invalid chunk length for Poseidon13: ${chunk.length}`);\n        middleChunks.push(poseidon13(chunk));\n      }\n    } else if (nameMrz.length == 30) {\n      // id_card\n      chunks.push(nameMrz.slice(0, 10), nameMrz.slice(10, 20), nameMrz.slice(20, 30)); // Corrected comment: 30/3 for poseidon10\n      for (const chunk of chunks) {\n        if (chunk.length !== 10)\n          throw new Error(`Invalid chunk length for Poseidon10: ${chunk.length}`);\n        middleChunks.push(poseidon10(chunk));\n      }\n    } else {\n      throw new Error(`Unsupported name MRZ length: ${nameMrz.length}`); // Handle unexpected lengths\n    }\n\n    if (middleChunks.length !== 3)\n      throw new Error(`Invalid number of middle chunks: ${middleChunks.length}`);\n    return poseidon3(middleChunks);\n  } catch (err) {\n    console.error('Error in getNameLeaf:', err, 'Index:', i, 'MRZ Length:', nameMrz.length); // Use console.error for errors\n    // console.log('MRZ data:', nameMrz); // Optional: log failing data\n    return BigInt(0); // Return 0 on error\n  }\n}\n\nexport function getNameYobLeaf(\n  nameMrz: (bigint | number)[],\n  yobMrz: (bigint | number)[],\n  i?: number\n): bigint {\n  return generateSmallKey(poseidon2([getYearLeaf(yobMrz), getNameLeaf(nameMrz)]));\n}\n\nexport function getPassportNumberAndNationalityLeaf(\n  passport: (bigint | number)[],\n  nationality: (bigint | number)[],\n  i?: number\n): bigint {\n  if (passport.length !== 9) {\n    console.log('parsed passport length is not 9:', i, passport);\n    return;\n  }\n  if (nationality.length !== 3) {\n    console.log('parsed nationality length is not 3:', i, nationality);\n    return;\n  }\n  try {\n    const fullHash = poseidon12(passport.concat(nationality));\n    return generateSmallKey(fullHash);\n  } catch (err) {\n    console.log('err : passport', err, i, passport);\n  }\n}\n","import {\n  COMMITMENT_TREE_DEPTH,\n  max_csca_bytes,\n  max_dsc_bytes,\n  MAX_PADDED_ECONTENT_LEN,\n  MAX_PADDED_SIGNED_ATTR_LEN,\n  OFAC_TREE_LEVELS,\n} from '../../constants/constants.js';\nimport { getCurrentDateYYMMDD } from '../date.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { formatMrz } from '../passports/format.js';\nimport {\n  extractSignatureFromDSC,\n  findStartPubKeyIndex,\n  formatSignatureDSCCircuit,\n  generateCommitment,\n  getCertificatePubKey,\n  getPassportSignatureInfos,\n  pad,\n  padWithZeroes,\n} from '../passports/passport.js';\nimport {\n  generateMerkleProof,\n  generateSMTProof,\n  getCountryLeaf,\n  getCscaTreeInclusionProof,\n  getDscTreeInclusionProof,\n  getLeafCscaTree,\n  getLeafDscTree,\n  getNameDobLeaf,\n  getNameYobLeaf,\n  getPassportNumberAndNationalityLeaf,\n} from '../trees.js';\nimport type { PassportData } from '../types.js';\nimport { formatCountriesList } from './formatInputs.js';\nimport { stringToAsciiBigIntArray } from './uuid.js';\n\nimport type { LeanIMT } from '@openpassport/zk-kit-lean-imt';\nimport type { SMT } from '@openpassport/zk-kit-smt';\n\n// this get the commitment index whether it is a string or a bigint\n// this is necessary rn because when the tree is send from the server in a serialized form,\n// the bigints are converted to strings and I can't figure out how to use tree.import to load bigints there\nexport function findIndexInTree(tree: LeanIMT, commitment: bigint): number {\n  let index = tree.indexOf(commitment);\n  if (index === -1) {\n    index = tree.indexOf(commitment.toString() as unknown as bigint);\n  }\n  if (index === -1) {\n    throw new Error('This commitment was not found in the tree');\n  } else {\n    //  console.log(`Index of commitment in the registry: ${index}`);\n  }\n  return index;\n}\n\nexport function formatInput(input: any) {\n  if (Array.isArray(input)) {\n    return input.map((item) => BigInt(item).toString());\n  } else if (input instanceof Uint8Array) {\n    return Array.from(input).map((num) => BigInt(num).toString());\n  } else if (typeof input === 'string' && input.includes(',')) {\n    const numbers = input\n      .split(',')\n      .map((s) => s.trim())\n      .filter((s) => s !== '' && !isNaN(Number(s)))\n      .map(Number);\n\n    try {\n      return numbers.map((num) => BigInt(num).toString());\n    } catch (e) {\n      throw e;\n    }\n  } else {\n    return [BigInt(input).toString()];\n  }\n}\n\nexport function generateCircuitInputsCountryVerifier(\n  passportData: PassportData,\n  sparsemerkletree: SMT\n) {\n  const mrz_bytes = formatMrz(passportData.mrz);\n  const usa_ascii = stringToAsciiBigIntArray('USA');\n  const country_leaf = getCountryLeaf(usa_ascii, mrz_bytes.slice(7, 10));\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, country_leaf);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    hostCountry: formatInput(usa_ascii),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsDSC(\n  passportData: PassportData,\n  serializedCscaTree: string[][]\n) {\n  const passportMetadata = passportData.passportMetadata;\n  const cscaParsed = passportData.csca_parsed;\n  const dscParsed = passportData.dsc_parsed;\n  const raw_dsc = passportData.dsc;\n  // CSCA is padded with 0s to max_csca_bytes\n  const cscaTbsBytesPadded = padWithZeroes(cscaParsed.tbsBytes, max_csca_bytes);\n  const dscTbsBytes = dscParsed.tbsBytes;\n\n  // DSC is padded using sha padding because it will be hashed in the circuit\n  const [dscTbsBytesPadded, dscTbsBytesLen] = pad(passportMetadata.cscaHashFunction)(\n    dscTbsBytes,\n    max_dsc_bytes\n  );\n  const leaf = getLeafCscaTree(cscaParsed);\n  const [root, path, siblings] = getCscaTreeInclusionProof(leaf, serializedCscaTree);\n  // Parse CSCA certificate and get its public key\n  const csca_pubKey_formatted = getCertificatePubKey(\n    cscaParsed,\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction\n  );\n\n  const signatureRaw = extractSignatureFromDSC(raw_dsc);\n  const signature = formatSignatureDSCCircuit(\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction,\n    cscaParsed,\n    signatureRaw\n  );\n  // Get start index of CSCA pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    cscaParsed,\n    cscaTbsBytesPadded,\n    passportMetadata.cscaSignatureAlgorithm\n  );\n  return {\n    raw_csca: cscaTbsBytesPadded.map((x) => x.toString()),\n    raw_csca_actual_length: BigInt(cscaParsed.tbsBytes.length).toString(),\n    csca_pubKey_offset: startIndex.toString(),\n    csca_pubKey_actual_size: BigInt(keyLength).toString(),\n    raw_dsc: Array.from(dscTbsBytesPadded).map((x) => x.toString()),\n    raw_dsc_padded_length: BigInt(dscTbsBytesLen).toString(), // with the sha padding actually\n    csca_pubKey: csca_pubKey_formatted,\n    signature,\n    merkle_root: root,\n    path: path,\n    siblings: siblings,\n  };\n}\n\nexport function generateCircuitInputsOfac(\n  passportData: PassportData,\n  sparsemerkletree: SMT,\n  proofLevel: number\n) {\n  const { mrz, documentType } = passportData;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const mrz_bytes = formatMrz(mrz); // Assume formatMrz handles basic formatting\n  const nameSlice = isPassportType\n    ? mrz_bytes.slice(5 + 5, 44 + 5)\n    : mrz_bytes.slice(60 + 5, 90 + 5);\n  const dobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 63 + 5)\n    : mrz_bytes.slice(30 + 5, 36 + 5);\n  const yobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 59 + 5)\n    : mrz_bytes.slice(30 + 5, 32 + 5);\n  const nationalitySlice = isPassportType\n    ? mrz_bytes.slice(54 + 5, 57 + 5)\n    : mrz_bytes.slice(45 + 5, 48 + 5);\n  const passNoSlice = isPassportType\n    ? mrz_bytes.slice(44 + 5, 53 + 5)\n    : mrz_bytes.slice(5 + 5, 14 + 5);\n\n  let leafToProve: bigint;\n\n  if (proofLevel == 3) {\n    if (!isPassportType) {\n      throw new Error(\n        'Proof level 3 (Passport Number) is only applicable to passport document types.'\n      );\n    }\n    leafToProve = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n  } else if (proofLevel == 2) {\n    leafToProve = getNameDobLeaf(nameSlice, dobSlice);\n  } else if (proofLevel == 1) {\n    leafToProve = getNameYobLeaf(nameSlice, yobSlice);\n  } else {\n    throw new Error('Invalid proof level specified for OFAC check.');\n  }\n\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, leafToProve);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsRegister(\n  secret: string,\n  passportData: PassportData,\n  serializedDscTree: string\n) {\n  const { mrz, eContent, signedAttr } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const dscParsed = passportData.dsc_parsed;\n\n  const [dscTbsBytesPadded] = pad(dscParsed.hashAlgorithm)(dscParsed.tbsBytes, max_dsc_bytes);\n\n  const { pubKey, signature, signatureAlgorithmFullName } = getPassportSignatureInfos(passportData);\n  const mrz_formatted = formatMrz(mrz);\n\n  if (eContent.length > MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]) {\n    console.error(\n      `eContent too long (${eContent.length} bytes). Max length is ${MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]} bytes.`\n    );\n    throw new Error(\n      `This length of datagroups (${eContent.length} bytes) is currently unsupported. Please contact us so we add support!`\n    );\n  }\n\n  const [eContentPadded, eContentLen] = pad(passportMetadata.eContentHashFunction)(\n    eContent,\n    MAX_PADDED_ECONTENT_LEN[passportMetadata.dg1HashFunction]\n  );\n  const [signedAttrPadded, signedAttrPaddedLen] = pad(passportMetadata.signedAttrHashFunction)(\n    signedAttr,\n    MAX_PADDED_SIGNED_ATTR_LEN[passportMetadata.eContentHashFunction]\n  );\n\n  const dsc_leaf = getLeafDscTree(dscParsed, passportData.csca_parsed); // TODO: WRONG\n  const [root, path, siblings, leaf_depth] = getDscTreeInclusionProof(dsc_leaf, serializedDscTree);\n  const csca_tree_leaf = getLeafCscaTree(passportData.csca_parsed);\n\n  // Get start index of DSC pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    dscParsed,\n    dscTbsBytesPadded,\n    dscParsed.signatureAlgorithm\n  );\n\n  const inputs = {\n    raw_dsc: dscTbsBytesPadded.map((x) => x.toString()),\n    raw_dsc_actual_length: [BigInt(dscParsed.tbsBytes.length).toString()],\n    dsc_pubKey_offset: startIndex,\n    dsc_pubKey_actual_size: [BigInt(keyLength).toString()],\n    dg1: mrz_formatted,\n    dg1_hash_offset: passportMetadata.dg1HashOffset,\n    eContent: eContentPadded,\n    eContent_padded_length: eContentLen,\n    signed_attr: signedAttrPadded,\n    signed_attr_padded_length: signedAttrPaddedLen,\n    signed_attr_econtent_hash_offset: passportMetadata.eContentHashOffset,\n    pubKey_dsc: pubKey,\n    signature_passport: signature,\n    merkle_root: [BigInt(root).toString()],\n    leaf_depth: leaf_depth,\n    path: path,\n    siblings: siblings,\n    csca_tree_leaf: csca_tree_leaf,\n    secret: secret,\n  };\n\n  return Object.entries(inputs)\n    .map(([key, value]) => ({\n      [key]: formatInput(value),\n    }))\n    .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n}\n\nexport function generateCircuitInputsVCandDisclose(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData,\n  scope: string,\n  selector_dg1: string[],\n  selector_older_than: string | number,\n  merkletree: LeanIMT,\n  majority: string,\n  passportNo_smt: SMT | null,\n  nameAndDob_smt: SMT,\n  nameAndYob_smt: SMT,\n  selector_ofac: string | number,\n  forbidden_countries_list: string[],\n  user_identifier: string\n) {\n  const { mrz, eContent, signedAttr, documentType } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const formattedMrz = formatMrz(mrz);\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(eContent),\n    'bytes'\n  );\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_tree_leaf = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n\n  const commitment = generateCommitment(secret, attestation_id, passportData);\n  const index = findIndexInTree(merkletree, BigInt(commitment));\n  const { siblings, path, leaf_depth } = generateMerkleProof(\n    merkletree,\n    index,\n    COMMITMENT_TREE_DEPTH\n  );\n  const formattedMajority = majority.length === 1 ? `0${majority}` : majority;\n  const majority_ascii = formattedMajority.split('').map((char) => char.charCodeAt(0));\n\n  // Define default values for SMT proofs (BigInt(0) for roots/keys, array of 0s for siblings)\n  const defaultSiblings = Array(OFAC_TREE_LEVELS).fill(BigInt(0));\n  let passportNoProof = {\n    root: BigInt(0),\n    closestleaf: BigInt(0),\n    siblings: defaultSiblings,\n  };\n  let nameDobProof;\n  let nameYobProof;\n\n  // Calculate leaves based on document type (using OFAC logic for slicing)\n  const nameSlice = isPassportType ? formattedMrz.slice(10, 49) : formattedMrz.slice(65, 95);\n  const dobSlice = isPassportType ? formattedMrz.slice(62, 68) : formattedMrz.slice(35, 41);\n  const yobSlice = isPassportType ? formattedMrz.slice(62, 64) : formattedMrz.slice(35, 37);\n  const nationalitySlice = isPassportType ? formattedMrz.slice(59, 62) : formattedMrz.slice(50, 53);\n  const passNoSlice = isPassportType ? formattedMrz.slice(49, 58) : formattedMrz.slice(10, 19);\n\n  const namedob_leaf = getNameDobLeaf(nameSlice, dobSlice);\n  const nameyob_leaf = getNameYobLeaf(nameSlice, yobSlice);\n\n  // Generate Name/DOB and Name/YOB proofs (always needed)\n  nameDobProof = generateSMTProof(nameAndDob_smt, namedob_leaf);\n  nameYobProof = generateSMTProof(nameAndYob_smt, nameyob_leaf);\n\n  // Generate Passport Number proof only if it's a passport type and SMT is provided\n  if (isPassportType) {\n    if (!passportNo_smt) {\n      console.warn('Document type is passport, but passportNo_smt tree was not provided.');\n    } else {\n      const passportNo_leaf = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n      const proofResult = generateSMTProof(passportNo_smt, passportNo_leaf);\n      // Explicitly cast root and closestleaf to bigint\n      passportNoProof = {\n        root: BigInt(proofResult.root),\n        closestleaf: BigInt(proofResult.closestleaf),\n        siblings: proofResult.siblings,\n      };\n    }\n  }\n  // Build Final Input Object\n  const baseInputs = {\n    secret: formatInput(secret),\n    attestation_id: formatInput(attestation_id),\n    dg1: formatInput(formattedMrz),\n    eContent_shaBytes_packed_hash: formatInput(eContent_packed_hash),\n    dsc_tree_leaf: formatInput(dsc_tree_leaf),\n    merkle_root: formatInput(merkletree.root),\n    leaf_depth: formatInput(leaf_depth),\n    path: formatInput(path),\n    siblings: formatInput(siblings),\n    selector_dg1: formatInput(selector_dg1),\n    selector_older_than: formatInput(selector_older_than),\n    scope: formatInput(scope),\n    current_date: formatInput(getCurrentDateYYMMDD()),\n    majority: formatInput(majority_ascii),\n    user_identifier: formatInput(user_identifier),\n    selector_ofac: formatInput(selector_ofac),\n    forbidden_countries_list: formatInput(formatCountriesList(forbidden_countries_list)),\n  };\n\n  const ofacNameInputs = {\n    ofac_namedob_smt_root: formatInput(nameDobProof.root),\n    ofac_namedob_smt_leaf_key: formatInput(nameDobProof.closestleaf),\n    ofac_namedob_smt_siblings: formatInput(nameDobProof.siblings),\n    ofac_nameyob_smt_root: formatInput(nameYobProof.root),\n    ofac_nameyob_smt_leaf_key: formatInput(nameYobProof.closestleaf),\n    ofac_nameyob_smt_siblings: formatInput(nameYobProof.siblings),\n  };\n\n  // Conditionally include passport OFAC inputs\n  const finalInputs = {\n    ...baseInputs,\n    ...ofacNameInputs,\n    ...(isPassportType && {\n      ofac_passportno_smt_root: formatInput(passportNoProof.root),\n      ofac_passportno_smt_leaf_key: formatInput(passportNoProof.closestleaf),\n      ofac_passportno_smt_siblings: formatInput(passportNoProof.siblings),\n    }),\n  };\n\n  return finalInputs;\n}\n"],"mappings":"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","names":["forge","poseidon5","asn1","poseidon2","poseidon3","poseidon6","poseidon10","poseidon12","poseidon13","poseidon2","index","poseidon2","asn1"]}