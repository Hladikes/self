{"version":3,"sources":["../../../../../src/constants/constants.ts","../../../../../src/utils/date.ts","../../../../../src/utils/hash.ts","../../../../../src/utils/bytes.ts","../../../../../src/utils/passports/format.ts","../../../../../src/utils/passports/passport.ts","../../../../../src/utils/shaPad.ts","../../../../../src/utils/trees.ts","../../../../../src/utils/circuits/formatInputs.ts","../../../../../src/utils/circuits/generateInputs.ts"],"sourcesContent":["export type Country3LetterCode = keyof typeof countryCodes;\nexport type document_type = 'passport' | 'id_card';\nexport type hashAlgosTypes = 'sha512' | 'sha384' | 'sha256' | 'sha224' | 'sha1';\nexport const API_URL = 'https://api.self.xyz';\nexport const API_URL_STAGING = 'https://api.staging.self.xyz';\n\nexport const CHAIN_NAME = 'celo';\n\n// possible values because of sha1 constaints: 192,320,384, 448, 576, 640\nexport const CIRCUIT_CONSTANTS = {\n  REGISTER_NULLIFIER_INDEX: 0,\n  REGISTER_COMMITMENT_INDEX: 1,\n  REGISTER_MERKLE_ROOT_INDEX: 2,\n\n  DSC_TREE_LEAF_INDEX: 0,\n  DSC_CSCA_ROOT_INDEX: 1,\n\n  VC_AND_DISCLOSE_REVEALED_DATA_PACKED_INDEX: 0,\n  VC_AND_DISCLOSE_FORBIDDEN_COUNTRIES_LIST_PACKED_INDEX: 3,\n  VC_AND_DISCLOSE_NULLIFIER_INDEX: 7,\n  VC_AND_DISCLOSE_ATTESTATION_ID_INDEX: 8,\n  VC_AND_DISCLOSE_MERKLE_ROOT_INDEX: 9,\n  VC_AND_DISCLOSE_CURRENT_DATE_INDEX: 10,\n  VC_AND_DISCLOSE_PASSPORT_NO_SMT_ROOT_INDEX: 16,\n  VC_AND_DISCLOSE_NAME_DOB_SMT_ROOT_INDEX: 17,\n  VC_AND_DISCLOSE_NAME_YOB_SMT_ROOT_INDEX: 18,\n  VC_AND_DISCLOSE_SCOPE_INDEX: 19,\n  VC_AND_DISCLOSE_USER_IDENTIFIER_INDEX: 20,\n};\n\nexport const CIRCUIT_TYPES = ['dsc', 'register', 'vc_and_disclose'];\n\nexport const COMMITMENT_TREE_DEPTH = 33;\n\nexport const CSCA_TREE_DEPTH = 12;\n\nexport const CSCA_TREE_URL = 'https://tree.self.xyz/csca';\n\nexport const CSCA_TREE_URL_ID_CARD = 'https://tree.self.xyz/csca-id';\n\nexport const CSCA_TREE_URL_STAGING = 'https://tree.staging.self.xyz/csca';\n\nexport const CSCA_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/csca-id';\n\nexport const DEFAULT_MAJORITY = '18';\n\nexport const DEFAULT_RPC_URL = 'https://mainnet.optimism.io';\n\nexport const DEFAULT_USER_ID_TYPE = 'uuid';\n\nexport const DEVELOPMENT_MODE = true;\n\nexport const DSC_TREE_DEPTH = 21;\n\nexport const DSC_TREE_URL = 'https://tree.self.xyz/dsc';\n\nexport const DSC_TREE_URL_ID_CARD = 'https://tree.self.xyz/dsc-id';\n\nexport const DSC_TREE_URL_STAGING = 'https://tree.staging.self.xyz/dsc';\n\nexport const DSC_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/dsc-id';\n\nexport enum DscVerifierId {\n  dsc_sha1_ecdsa_brainpoolP256r1 = 0,\n  dsc_sha1_rsa_65537_4096 = 1,\n  dsc_sha256_ecdsa_brainpoolP256r1 = 2,\n  dsc_sha256_ecdsa_brainpoolP384r1 = 3,\n  dsc_sha256_ecdsa_secp256r1 = 4,\n  dsc_sha256_ecdsa_secp384r1 = 5,\n  dsc_sha256_ecdsa_secp521r1 = 6,\n  dsc_sha256_rsa_65537_4096 = 7,\n  dsc_sha256_rsapss_3_32_3072 = 8,\n  dsc_sha256_rsapss_65537_32_3072 = 9,\n  dsc_sha256_rsapss_65537_32_4096 = 10,\n  dsc_sha384_ecdsa_brainpoolP384r1 = 11,\n  dsc_sha384_ecdsa_brainpoolP512r1 = 12,\n  dsc_sha384_ecdsa_secp384r1 = 13,\n  dsc_sha512_ecdsa_brainpoolP512r1 = 14,\n  dsc_sha512_ecdsa_secp521r1 = 15,\n  dsc_sha512_rsa_65537_4096 = 16,\n  dsc_sha512_rsapss_65537_64_4096 = 17,\n  dsc_sha256_rsapss_3_32_4096 = 18,\n  dsc_sha1_ecdsa_secp256r1 = 19,\n}\n\nexport const ECDSA_K_LENGTH_FACTOR = 2;\n\nexport const IDENTITY_TREE_URL = 'https://tree.self.xyz/identity';\n\n//\"8518753152044246090169372947057357973469996808638122125210848696986717482788\"\nexport const IDENTITY_TREE_URL_ID_CARD = 'https://tree.self.xyz/identity-id';\n\nexport const IDENTITY_TREE_URL_STAGING = 'https://tree.staging.self.xyz/identity';\n\nexport const IDENTITY_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/identity-id';\n\nexport const ID_CARD_ATTESTATION_ID = '2';\n\nexport const MAX_BYTES_IN_FIELD = 31;\n\nexport const MAX_CERT_BYTES: Partial<Record<keyof typeof SignatureAlgorithmIndex, number>> = {\n  rsa_sha256_65537_4096: 512,\n  rsa_sha1_65537_4096: 640,\n  rsapss_sha256_65537_2048: 640,\n  rsapss_sha256_65537_3072: 640,\n  rsapss_sha256_65537_4096: 768,\n  rsapss_sha256_3_3072: 768,\n  rsapss_sha256_3_4096: 768,\n  rsapss_sha384_65537_3072: 768,\n};\n\n/**\n * Maximum number of countries in the forbidden countries list.\n *\n * IMPORTANT: This value must match in both backend and frontend SDK.\n * Any mismatch will result in an INVALID_FORBIDDEN_COUNTRIES error.\n */\nexport const MAX_DATAHASHES_LEN = 320;\n\nexport const MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n\nexport const MAX_PADDED_ECONTENT_LEN: Partial<Record<(typeof hashAlgos)[number], number>> = {\n  sha1: 384,\n  sha224: 512,\n  sha256: 512,\n  sha384: 768,\n  sha512: 896,\n};\n\nexport const MAX_PADDED_SIGNED_ATTR_LEN: Record<(typeof hashAlgos)[number], number> = {\n  sha1: 128,\n  sha224: 128,\n  sha256: 128,\n  sha384: 256,\n  sha512: 256,\n};\n\n// Note: Circuit lists are now managed through RegisterVerifierId and DscVerifierId enums below\n// instead of separate arrays for better type safety and maintainability\nexport const MAX_PUBKEY_DSC_BYTES = 525;\n\nexport const OFAC_TREE_LEVELS = 64;\n\n// we make it global here because passing it to generateCircuitInputsRegister caused trouble\nexport const PASSPORT_ATTESTATION_ID = '1';\n\nexport const PCR0_MANAGER_ADDRESS = '0xE36d4EE5Fd3916e703A46C21Bb3837dB7680C8B8';\n\nexport const REDIRECT_URL = 'https://redirect.self.xyz';\n\nexport const REGISTER_CONTRACT_ADDRESS = '0x3F346FFdC5d583e4126AF01A02Ac5b9CdB3f1909';\n\nexport const RPC_URL = 'https://forno.celo.org';\n\nexport enum RegisterVerifierId {\n  register_sha256_sha256_sha256_rsa_65537_4096 = 0,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 1,\n  register_sha256_sha256_sha256_ecdsa_secp256r1 = 2,\n  register_sha256_sha256_sha256_ecdsa_secp384r1 = 3,\n  register_sha256_sha256_sha256_rsa_3_4096 = 4,\n  register_sha256_sha256_sha256_rsapss_3_32_2048 = 5,\n  register_sha256_sha256_sha256_rsapss_65537_32_2048 = 6,\n  register_sha256_sha256_sha256_rsapss_65537_32_3072 = 7,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 8,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 9,\n  register_sha384_sha384_sha384_ecdsa_secp384r1 = 10,\n  register_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 11,\n  register_sha512_sha512_sha512_rsa_65537_4096 = 12,\n  register_sha512_sha512_sha512_rsapss_65537_64_2048 = 13,\n  register_sha1_sha1_sha1_rsa_65537_4096 = 14,\n  register_sha1_sha256_sha256_rsa_65537_4096 = 15,\n  register_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 16,\n  register_sha256_sha224_sha224_ecdsa_secp224r1 = 17,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 18,\n  register_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 19,\n  register_sha384_sha384_sha384_rsapss_65537_48_2048 = 20,\n  register_sha1_sha1_sha1_ecdsa_secp256r1 = 21,\n  register_sha256_sha256_sha256_rsapss_65537_64_2048 = 22,\n  register_sha512_sha512_sha256_rsa_65537_4096 = 23,\n  register_sha512_sha512_sha512_ecdsa_secp521r1 = 24,\n  register_id_sha256_sha256_sha256_rsa_65537_4096 = 25,\n  register_sha256_sha256_sha224_ecdsa_secp224r1 = 26,\n  register_id_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 27,\n  register_id_sha1_sha1_sha1_ecdsa_secp256r1 = 28,\n  register_id_sha1_sha1_sha1_rsa_65537_4096 = 29,\n  register_id_sha1_sha256_sha256_rsa_65537_4096 = 30,\n  register_id_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 31,\n  register_id_sha256_sha224_sha224_ecdsa_secp224r1 = 32,\n  register_id_sha256_sha256_sha224_ecdsa_secp224r1 = 33,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 34,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 35,\n  register_id_sha256_sha256_sha256_ecdsa_secp256r1 = 36,\n  register_id_sha256_sha256_sha256_ecdsa_secp384r1 = 37,\n  register_id_sha256_sha256_sha256_rsa_3_4096 = 38,\n  register_id_sha256_sha256_sha256_rsapss_3_32_2048 = 39,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_2048 = 40,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_3072 = 41,\n  register_id_sha256_sha256_sha256_rsapss_65537_64_2048 = 42,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 43,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 44,\n  register_id_sha384_sha384_sha384_ecdsa_secp384r1 = 45,\n  register_id_sha384_sha384_sha384_rsapss_65537_48_2048 = 46,\n  register_id_sha512_sha512_sha256_rsa_65537_4096 = 47,\n  register_id_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 48,\n  register_id_sha512_sha512_sha512_ecdsa_secp521r1 = 49,\n  register_id_sha512_sha512_sha512_rsa_65537_4096 = 50,\n  register_id_sha512_sha512_sha512_rsapss_65537_64_2048 = 51,\n}\n\nexport const SBT_CONTRACT_ADDRESS = '0x601Fd54FD11C5E77DE84d877e55B829aff20f0A6';\n\nexport enum SignatureAlgorithmIndex {\n  rsa_sha256_65537_2048 = 1,\n  rsa_sha1_65537_2048 = 3,\n  rsapss_sha256_65537_2048 = 4,\n  ecdsa_sha1_secp256r1_256 = 7,\n  ecdsa_sha256_secp256r1_256 = 8,\n  ecdsa_sha384_secp384r1_384 = 9,\n  rsa_sha256_65537_4096 = 10,\n  rsa_sha1_65537_4096 = 11,\n  rsapss_sha256_65537_4096 = 12,\n  rsa_sha256_3_2048 = 13,\n  rsa_sha256_65537_3072 = 14,\n  rsa_sha512_65537_4096 = 15,\n  rsapss_sha256_3_3072 = 16,\n  rsapss_sha256_3_4096 = 17,\n  rsapss_sha384_65537_3072 = 18,\n  rsapss_sha256_65537_3072 = 19,\n  ecdsa_sha256_brainpoolP256r1_256 = 21,\n  ecdsa_sha384_brainpoolP384r1_384 = 22,\n  ecdsa_sha256_secp384r1_384 = 23,\n  ecdsa_sha384_brainpoolP256r1_256 = 24,\n  ecdsa_sha512_brainpoolP256r1_256 = 25,\n  ecdsa_sha512_brainpoolP384r1_384 = 26,\n  ecdsa_sha1_brainpoolP224r1_224 = 27,\n  ecdsa_sha256_brainpoolP224r1_224 = 28,\n  ecdsa_sha512_brainpoolP512r1_512 = 29,\n  ecdsa_sha224_brainpoolP224r1_224 = 30,\n  rsa_sha256_3_4096 = 32,\n  rsa_sha1_3_4096 = 33,\n  rsa_sha384_65537_4096 = 34,\n  rsapss_sha384_65537_4096 = 35,\n  ecdsa_sha1_brainpoolP256r1_256 = 36,\n  ecdsa_sha512_secp521r1_521 = 41,\n}\n\nexport const TREE_TRACKER_URL = 'https://tree.self.xyz';\n\nexport const TREE_URL = 'https://tree.self.xyz';\nexport const TREE_URL_STAGING = 'https://tree.staging.self.xyz';\n\nexport const WS_DB_RELAYER = 'wss://websocket.self.xyz';\n\nexport const WS_DB_RELAYER_STAGING = 'wss://websocket.staging.self.xyz';\n\nexport const WS_RPC_URL_VC_AND_DISCLOSE = 'ws://disclose.proving.self.xyz:8888/';\n\nexport const attributeToPosition = {\n  issuing_state: [2, 4],\n  name: [5, 43],\n  passport_number: [44, 52],\n  nationality: [54, 56],\n  date_of_birth: [57, 62],\n  gender: [64, 64],\n  expiry_date: [65, 70],\n  older_than: [88, 89],\n  ofac: [90, 90],\n};\nexport const attributeToPosition_ID = {\n  issuing_state: [2, 4],\n  name: [60, 89],\n  passport_number: [5, 13],\n  nationality: [45, 47],\n  date_of_birth: [30, 35],\n  gender: [37, 37],\n  expiry_date: [38, 43],\n  older_than: [90, 91],\n  ofac: [92, 92],\n};\n\nexport const circuitNameFromMode = {\n  prove: 'prove',\n  prove_onchain: 'prove',\n  prove_offchain: 'prove',\n  register: 'prove',\n  vc_and_disclose: 'vc_and_disclose',\n  dsc: 'dsc',\n};\nexport const circuitToSelectorMode = {\n  register: [0, 0],\n  prove_onchain: [1, 0],\n  prove_offchain: [1, 1],\n};\n\nexport const contribute_publicKey = `-----BEGIN RSA PUBLIC KEY-----\nMIICCgKCAgEAv/hm7FZZ2KBmaeDHmLoRwuWmCcNKT561RqbsW8ZuYSyPWJUldE9U\nCf0lW3K1H5lsSDkl0Cq84cooL9f6X59Mffb/N24ZKTdL0xdcPwjk4LbcrVm8qubL\n0a/4uCNoZZ1my4nxbpLxYtbr8CNmUGvBOVKf8IcjsY6VghIZrO63G6BN/G44su1Z\nWcHpboGt9SDQK4enCyKxnCD+PbDYlewSA0n3GRajFfZex1bj1EvrS2hTLv8oNH5e\n9H+3TUke0uO6Ttl0bZepoMmPlpAXhJByISqC6SLth4WFIH+G1I/xt9AEM7hOfLMl\nKQv/3wlLEgEueRryKAHB2tqkaDKVJyw+tOyWj2iWA+nVgQKAxO4hOw01ljyVbcx6\nKboXwnamlZPFIx4tjEaZ+ClXCFqvXhE9LDFK11QsYzJZl0aRVfTNqcurhEt7SK0f\nqzOBhID0Nxk4k9sW1uT6ocW1xp1SB2WotORssOKIAOLJM8IbPl6n/DkYNcfvyXI7\n4BlUrf6M2DgZMYATabIy94AvopHJOyiRfh4NpQPDntWnShiI1em2MmtXiWFCdVFV\n6/QfJTKVixJpVfDh386ALXc97EPWDMWIalUwYoV/eRSMnuV8nZ0+Ctp3Qrtk/JYd\n+FWhKbtlPeRjmGVr6mVlvDJ7KqtY5/RqqwfWeXhXezGhQqQ/OoQQCRkCAwEAAQ==\n-----END RSA PUBLIC KEY-----`;\n\n// not using a library for this as the entry countries use can be differnt than the ISO 3166-1 alpha-3 standard\nexport const countryCodes = {\n  AFG: 'Afghanistan',\n  ALA: 'Aland Islands',\n  ALB: 'Albania',\n  DZA: 'Algeria',\n  ASM: 'American Samoa',\n  AND: 'Andorra',\n  AGO: 'Angola',\n  AIA: 'Anguilla',\n  ATA: 'Antarctica',\n  ATG: 'Antigua and Barbuda',\n  ARG: 'Argentina',\n  ARM: 'Armenia',\n  ABW: 'Aruba',\n  AUS: 'Australia',\n  AUT: 'Austria',\n  AZE: 'Azerbaijan',\n  BHS: 'Bahamas',\n  BHR: 'Bahrain',\n  BGD: 'Bangladesh',\n  BRB: 'Barbados',\n  BLR: 'Belarus',\n  BEL: 'Belgium',\n  BLZ: 'Belize',\n  BEN: 'Benin',\n  BMU: 'Bermuda',\n  BTN: 'Bhutan',\n  BOL: 'Bolivia (Plurinational State of)',\n  BES: 'Bonaire, Sint Eustatius and Saba',\n  BIH: 'Bosnia and Herzegovina',\n  BWA: 'Botswana',\n  BVT: 'Bouvet Island',\n  BRA: 'Brazil',\n  IOT: 'British Indian Ocean Territory',\n  BRN: 'Brunei Darussalam',\n  BGR: 'Bulgaria',\n  BFA: 'Burkina Faso',\n  BDI: 'Burundi',\n  CPV: 'Cabo Verde',\n  KHM: 'Cambodia',\n  CMR: 'Cameroon',\n  CAN: 'Canada',\n  CYM: 'Cayman Islands',\n  CAF: 'Central African Republic',\n  TCD: 'Chad',\n  CHL: 'Chile',\n  CHN: 'China',\n  CXR: 'Christmas Island',\n  CCK: 'Cocos (Keeling) Islands',\n  COL: 'Colombia',\n  COM: 'Comoros',\n  COG: 'Congo',\n  COD: 'Congo, Democratic Republic of the',\n  COK: 'Cook Islands',\n  CRI: 'Costa Rica',\n  CIV: \"Cote d'Ivoire\",\n  HRV: 'Croatia',\n  CUB: 'Cuba',\n  CUW: 'Curacao',\n  CYP: 'Cyprus',\n  CZE: 'Czechia',\n  DNK: 'Denmark',\n  DJI: 'Djibouti',\n  DMA: 'Dominica',\n  DOM: 'Dominican Republic',\n  ECU: 'Ecuador',\n  EGY: 'Egypt',\n  SLV: 'El Salvador',\n  GNQ: 'Equatorial Guinea',\n  ERI: 'Eritrea',\n  EST: 'Estonia',\n  SWZ: 'Eswatini',\n  ETH: 'Ethiopia',\n  FLK: 'Falkland Islands (Malvinas)',\n  FRO: 'Faroe Islands',\n  FJI: 'Fiji',\n  FIN: 'Finland',\n  FRA: 'France',\n  GUF: 'French Guiana',\n  PYF: 'French Polynesia',\n  ATF: 'French Southern Territories',\n  GAB: 'Gabon',\n  GMB: 'Gambia',\n  GEO: 'Georgia',\n  DEU: 'Germany',\n  'D<<': 'Germany', // Bundesrepublik Deutschland uses this in passports instead of DEU\n  GHA: 'Ghana',\n  GIB: 'Gibraltar',\n  GRC: 'Greece',\n  GRL: 'Greenland',\n  GRD: 'Grenada',\n  GLP: 'Guadeloupe',\n  GUM: 'Guam',\n  GTM: 'Guatemala',\n  GGY: 'Guernsey',\n  GIN: 'Guinea',\n  GNB: 'Guinea-Bissau',\n  GUY: 'Guyana',\n  HTI: 'Haiti',\n  HMD: 'Heard Island and McDonald Islands',\n  VAT: 'Holy See',\n  HND: 'Honduras',\n  HKG: 'Hong Kong',\n  HUN: 'Hungary',\n  ISL: 'Iceland',\n  IND: 'India',\n  IDN: 'Indonesia',\n  IRN: 'Iran (Islamic Republic of)',\n  IRQ: 'Iraq',\n  IRL: 'Ireland',\n  IMN: 'Isle of Man',\n  ISR: 'Israel',\n  ITA: 'Italy',\n  JAM: 'Jamaica',\n  JPN: 'Japan',\n  JEY: 'Jersey',\n  JOR: 'Jordan',\n  KAZ: 'Kazakhstan',\n  KEN: 'Kenya',\n  KIR: 'Kiribati',\n  PRK: \"Korea (Democratic People's Republic of)\",\n  KOR: 'Korea, Republic of',\n  KWT: 'Kuwait',\n  KGZ: 'Kyrgyzstan',\n  LAO: \"Lao People's Democratic Republic\",\n  LVA: 'Latvia',\n  LBN: 'Lebanon',\n  LSO: 'Lesotho',\n  LBR: 'Liberia',\n  LBY: 'Libya',\n  LIE: 'Liechtenstein',\n  LTU: 'Lithuania',\n  LUX: 'Luxembourg',\n  MAC: 'Macao',\n  MDG: 'Madagascar',\n  MWI: 'Malawi',\n  MYS: 'Malaysia',\n  MDV: 'Maldives',\n  MLI: 'Mali',\n  MLT: 'Malta',\n  MHL: 'Marshall Islands',\n  MTQ: 'Martinique',\n  MRT: 'Mauritania',\n  MUS: 'Mauritius',\n  MYT: 'Mayotte',\n  MEX: 'Mexico',\n  FSM: 'Micronesia (Federated States of)',\n  MDA: 'Moldova, Republic of',\n  MCO: 'Monaco',\n  MNG: 'Mongolia',\n  MNE: 'Montenegro',\n  MSR: 'Montserrat',\n  MAR: 'Morocco',\n  MOZ: 'Mozambique',\n  MMR: 'Myanmar',\n  NAM: 'Namibia',\n  NRU: 'Nauru',\n  NPL: 'Nepal',\n  NLD: 'Netherlands',\n  NCL: 'New Caledonia',\n  NZL: 'New Zealand',\n  NIC: 'Nicaragua',\n  NER: 'Niger',\n  NGA: 'Nigeria',\n  NIU: 'Niue',\n  NFK: 'Norfolk Island',\n  MKD: 'North Macedonia',\n  MNP: 'Northern Mariana Islands',\n  NOR: 'Norway',\n  OMN: 'Oman',\n  PAK: 'Pakistan',\n  PLW: 'Palau',\n  PSE: 'Palestine, State of',\n  PAN: 'Panama',\n  PNG: 'Papua New Guinea',\n  PRY: 'Paraguay',\n  PER: 'Peru',\n  PHL: 'Philippines',\n  PCN: 'Pitcairn',\n  POL: 'Poland',\n  PRT: 'Portugal',\n  PRI: 'Puerto Rico',\n  QAT: 'Qatar',\n  REU: 'Reunion',\n  ROU: 'Romania',\n  RUS: 'Russian Federation',\n  RWA: 'Rwanda',\n  BLM: 'Saint Barthelemy',\n  SHN: 'Saint Helena, Ascension and Tristan da Cunha',\n  KNA: 'Saint Kitts and Nevis',\n  LCA: 'Saint Lucia',\n  MAF: 'Saint Martin (French part)',\n  SPM: 'Saint Pierre and Miquelon',\n  VCT: 'Saint Vincent and the Grenadines',\n  WSM: 'Samoa',\n  SMR: 'San Marino',\n  STP: 'Sao Tome and Principe',\n  SAU: 'Saudi Arabia',\n  SEN: 'Senegal',\n  SRB: 'Serbia',\n  SYC: 'Seychelles',\n  SLE: 'Sierra Leone',\n  SGP: 'Singapore',\n  SXM: 'Sint Maarten (Dutch part)',\n  SVK: 'Slovakia',\n  SVN: 'Slovenia',\n  SLB: 'Solomon Islands',\n  SOM: 'Somalia',\n  ZAF: 'South Africa',\n  SGS: 'South Georgia and the South Sandwich Islands',\n  SSD: 'South Sudan',\n  ESP: 'Spain',\n  LKA: 'Sri Lanka',\n  SDN: 'Sudan',\n  SUR: 'Suriname',\n  SJM: 'Svalbard and Jan Mayen',\n  SWE: 'Sweden',\n  CHE: 'Switzerland',\n  SYR: 'Syrian Arab Republic',\n  TWN: 'Taiwan, Province of China',\n  TJK: 'Tajikistan',\n  TZA: 'Tanzania, United Republic of',\n  THA: 'Thailand',\n  TLS: 'Timor-Leste',\n  TGO: 'Togo',\n  TKL: 'Tokelau',\n  TON: 'Tonga',\n  TTO: 'Trinidad and Tobago',\n  TUN: 'Tunisia',\n  TUR: 'Turkey',\n  TKM: 'Turkmenistan',\n  TCA: 'Turks and Caicos Islands',\n  TUV: 'Tuvalu',\n  UGA: 'Uganda',\n  UKR: 'Ukraine',\n  ARE: 'United Arab Emirates',\n  GBR: 'United Kingdom of Great Britain and Northern Ireland',\n  USA: 'United States of America',\n  UMI: 'United States Minor Outlying Islands',\n  URY: 'Uruguay',\n  UZB: 'Uzbekistan',\n  VUT: 'Vanuatu',\n  VEN: 'Venezuela (Bolivarian Republic of)',\n  VNM: 'Viet Nam',\n  VGB: 'Virgin Islands (British)',\n  VIR: 'Virgin Islands (U.S.)',\n  WLF: 'Wallis and Futuna',\n  ESH: 'Western Sahara',\n  YEM: 'Yemen',\n  ZMB: 'Zambia',\n  ZWE: 'Zimbabwe',\n};\n\nexport function getCountryCode(countryName: string): string {\n  const entries = Object.entries(countryCodes);\n  const found = entries.find(([_, name]) => name.toLowerCase() === countryName.toLowerCase());\n  return found ? found[0] : 'undefined';\n}\n\nexport const hashAlgos = ['sha512', 'sha384', 'sha256', 'sha224', 'sha1'];\n\nexport const k_csca = 35;\n\nexport const k_dsc = 35;\n\n//48;\nexport const k_dsc_3072 = 35;\n\nexport const k_dsc_4096 = 35;\n\nexport const k_dsc_ecdsa = 4;\n\nexport const max_csca_bytes = 1792;\n\nexport const max_dsc_bytes = 1792;\n\nexport const n_csca = 120;\n\nexport const n_dsc = 120;\n\nexport const n_dsc_3072 = 120;\n\nexport const n_dsc_4096 = 120;\n\nexport const n_dsc_ecdsa = 64;\n\n// max formatted and concatenated datagroup hashes length in bytes\nexport const revealedDataTypes = {\n  issuing_state: 0,\n  name: 1,\n  passport_number: 2,\n  nationality: 3,\n  date_of_birth: 4,\n  gender: 5,\n  expiry_date: 6,\n  older_than: 7,\n  passport_no_ofac: 8,\n  name_and_dob_ofac: 9,\n  name_and_yob_ofac: 10,\n};\n\nexport const saltLengths = [64, 48, 32];\n","export function getAdjustedTimestampBytes(y: number = 0, m: number = 0, d: number = 0): number[] {\n  // Get the current date/time\n  const currentDate: Date = new Date();\n\n  // Optionally adjust the date\n  if (y !== 0) currentDate.setFullYear(currentDate.getFullYear() + y);\n  if (m !== 0) currentDate.setMonth(currentDate.getMonth() + m);\n  if (d !== 0) currentDate.setDate(currentDate.getDate() + d);\n\n  // Get the Unix timestamp (in seconds)\n  const timestamp: number = Math.floor(currentDate.getTime() / 1000);\n\n  // Convert the timestamp to 4 bytes\n  const bytes: number[] = [\n    (timestamp >> 24) & 0xff,\n    (timestamp >> 16) & 0xff,\n    (timestamp >> 8) & 0xff,\n    timestamp & 0xff,\n  ];\n\n  return bytes;\n}\nexport function getCurrentDateYYMMDD(dayDiff: number = 0): number[] {\n  const date = new Date();\n  date.setDate(date.getDate() + dayDiff); // Adjust the date by the dayDiff\n  const year = date.getUTCFullYear();\n  const month = date.getUTCMonth() + 1;\n  const day = date.getUTCDate();\n  const YY = `0${year % 100}`.slice(-2);\n  const MM = `0${month}`.slice(-2);\n  const DD = `0${day}`.slice(-2);\n\n  const yymmdd = `${YY}${MM}${DD}`;\n  return Array.from(yymmdd).map((char) => parseInt(char));\n}\n\nexport function getTimestampBytesFromYearFraction(yearFraction: number): number[] {\n  // Separate the year and the fractional part\n  const year = Math.floor(yearFraction);\n  const fraction = yearFraction - year;\n\n  // Convert the fractional part into months (0-11)\n  const monthsFromFraction = Math.floor(fraction * 12);\n\n  // Create a date object from the year and the calculated month\n  // Assuming the first day of the month for simplicity\n  const date = new Date(year, monthsFromFraction, 1);\n\n  // Get the Unix timestamp (in seconds)\n  const timestamp: number = Math.floor(date.getTime() / 1000);\n\n  // Convert the timestamp to 4 bytes\n  const bytes: number[] = [\n    (timestamp >> 24) & 0xff,\n    (timestamp >> 16) & 0xff,\n    (timestamp >> 8) & 0xff,\n    timestamp & 0xff,\n  ];\n\n  return bytes;\n}\n\nexport function unixTimestampToYYMMDD(timestamp: number): string {\n  console.log('timestamp: ' + timestamp);\n  const date = new Date(timestamp * 1000);\n  console.log('date: ' + date);\n  const year = date.getUTCFullYear();\n  console.log('year: ' + year);\n  const month = date.getUTCMonth() + 1;\n  const day = date.getUTCDate();\n\n  // Ensure the year is correctly formatted as two digits\n  const YY = `0${year % 100}`.slice(-2);\n  const MM = `0${month}`.slice(-2);\n  const DD = `0${day}`.slice(-2);\n\n  return `${YY}${MM}${DD}`;\n}\n\nexport function yearFractionToYYMMDD(yearFraction: number): string {\n  // Separate the year and the fractional part\n  const year = yearFraction;\n  const fraction = yearFraction - Math.floor(yearFraction);\n\n  // Convert the fractional part into months (0-11)\n  const monthsFromFraction = Math.floor(fraction * 12);\n\n  // Assuming the first day of the month for simplicity\n  const day = 1;\n\n  // Format year, month, and day into YYMMDD string\n  const YY = `0${Math.floor(year) % 100}`.slice(-2);\n  const MM = `0${monthsFromFraction + 1}`.slice(-2); // +1 because months are 1-indexed in this format\n  const DD = `0${day}`.slice(-2);\n\n  return `${YY}${MM}${DD}`;\n}\n\nexport function yymmddToByteArray(yymmdd: string): number[] {\n  // Convert each character in the string to its ASCII value\n  const byteArray = Array.from(yymmdd).map((char) => char.charCodeAt(0));\n  return byteArray;\n}\n","import { ethers } from 'ethers';\n// @ts-ignore - ESLint incorrectly flags this as needing default import, but TypeScript definitions use named export\nimport { sha1 } from 'js-sha1';\nimport { sha224, sha256 } from 'js-sha256';\nimport { sha384, sha512 } from 'js-sha512';\nimport * as forge from 'node-forge';\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from 'poseidon-lite';\n\nimport { hexToSignedBytes, packBytesArray } from './bytes.js';\n\nexport function calculateUserIdentifierHash(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): BigInt {\n  const solidityPackedUserContextData = getSolidityPackedUserContextData(\n    destChainID,\n    userID,\n    userDefinedData\n  );\n  const inputBytes = Buffer.from(solidityPackedUserContextData.slice(2), 'hex');\n  const sha256Hash = ethers.sha256(inputBytes);\n  const ripemdHash = ethers.ripemd160(sha256Hash);\n  return BigInt(ripemdHash);\n}\n\nexport function customHasher(pubKeyFormatted: string[]) {\n  if (pubKeyFormatted.length < 16) {\n    // if k is less than 16, we can use a single poseidon hash\n    return flexiblePoseidon(pubKeyFormatted.map(BigInt)).toString();\n  } else {\n    const rounds = Math.ceil(pubKeyFormatted.length / 16); // do up to 16 rounds of poseidon\n    if (rounds > 16) {\n      throw new Error('Number of rounds is greater than 16');\n    }\n    const hash = new Array(rounds);\n    for (let i = 0; i < rounds; i++) {\n      hash[i] = { inputs: new Array(16).fill(BigInt(0)) };\n    }\n    for (let i = 0; i < rounds; i++) {\n      for (let j = 0; j < 16; j++) {\n        if (i * 16 + j < pubKeyFormatted.length) {\n          hash[i].inputs[j] = BigInt(pubKeyFormatted[i * 16 + j]);\n        }\n      }\n    }\n    const finalHash = flexiblePoseidon(hash.map((h) => poseidon16(h.inputs)));\n    return finalHash.toString();\n  }\n}\n\nexport function flexiblePoseidon(inputs: bigint[]): bigint {\n  switch (inputs.length) {\n    case 1:\n      return poseidon1(inputs);\n    case 2:\n      return poseidon2(inputs);\n    case 3:\n      return poseidon3(inputs);\n    case 4:\n      return poseidon4(inputs);\n    case 5:\n      return poseidon5(inputs);\n    case 6:\n      return poseidon6(inputs);\n    case 7:\n      return poseidon7(inputs);\n    case 8:\n      return poseidon8(inputs);\n    case 9:\n      return poseidon9(inputs);\n    case 10:\n      return poseidon10(inputs);\n    case 11:\n      return poseidon11(inputs);\n    case 12:\n      return poseidon12(inputs);\n    case 13:\n      return poseidon13(inputs);\n    case 14:\n      return poseidon14(inputs);\n    case 15:\n      return poseidon15(inputs);\n    case 16:\n      return poseidon16(inputs);\n    default:\n      throw new Error(`Unsupported number of inputs: ${inputs.length}`);\n  }\n}\n\nexport function getHashLen(hashFunction: string) {\n  switch (hashFunction) {\n    case 'sha1':\n      return 20;\n    case 'sha224':\n      return 28;\n    case 'sha256':\n      return 32;\n    case 'sha384':\n      return 48;\n    case 'sha512':\n      return 64;\n    default:\n      console.log(`${hashFunction} not found in getHashLen`);\n      return 32;\n  }\n}\n\nexport function getSolidityPackedUserContextData(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): string {\n  const userIdHex = userID.replace(/-/g, '');\n  return ethers.solidityPacked(\n    ['bytes32', 'bytes32', 'bytes'],\n    [\n      ethers.zeroPadValue(ethers.toBeHex(destChainID), 32),\n      ethers.zeroPadValue('0x' + userIdHex, 32),\n      ethers.toUtf8Bytes(userDefinedData),\n    ]\n  );\n}\n\n// hash function - crypto is not supported in react native\nexport function hash(\n  hashFunction: string,\n  bytesArray: number[],\n  format: string = 'bytes'\n): string | number[] {\n  const unsignedBytesArray = bytesArray.map((byte) => byte & 0xff);\n  let hashResult: string;\n\n  switch (hashFunction) {\n    case 'sha1':\n      hashResult = sha1(unsignedBytesArray);\n      break;\n    case 'sha224':\n      hashResult = sha224(unsignedBytesArray);\n      break;\n    case 'sha256':\n      hashResult = sha256(unsignedBytesArray);\n      break;\n    case 'sha384':\n      hashResult = sha384(unsignedBytesArray);\n      break;\n    case 'sha512':\n      hashResult = sha512(unsignedBytesArray);\n      break;\n    default:\n      console.log('\\x1b[31m%s\\x1b[0m', `${hashFunction} not found in hash`); // Log in red\n      hashResult = sha256(unsignedBytesArray); // Default to sha256\n  }\n  if (format === 'hex') {\n    return hashResult;\n  }\n  if (format === 'bytes') {\n    return hexToSignedBytes(hashResult);\n  }\n  const actualForgeUtil = forge.util ? forge.util : (forge as any).default.util;\n  if (format === 'binary') {\n    return actualForgeUtil.binary.raw.encode(new Uint8Array(hexToSignedBytes(hashResult)));\n  }\n  throw new Error(`Invalid format: ${format}`);\n}\n\nexport function packBytesAndPoseidon(unpacked: number[]) {\n  const packed = packBytesArray(unpacked);\n  return customHasher(packed.map(String)).toString();\n}\n","import { MAX_BYTES_IN_FIELD } from '../constants/constants.js';\n\nexport function bigIntToChunkedBytes(\n  num: BigInt | bigint,\n  bytesPerChunk: number,\n  numChunks: number\n) {\n  const res: string[] = [];\n  const bigintNum: bigint = typeof num == 'bigint' ? num : num.valueOf();\n  const msk = (1n << BigInt(bytesPerChunk)) - 1n;\n  for (let i = 0; i < numChunks; ++i) {\n    res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());\n  }\n  return res;\n}\nexport function bytesToBigDecimal(arr: number[]): string {\n  let result = BigInt(0);\n  for (let i = 0; i < arr.length; i++) {\n    result = result * BigInt(256) + BigInt(arr[i] & 0xff);\n  }\n  return result.toString();\n}\n\nexport function computeIntChunkLength(byteLength: number) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const remain = byteLength % packSize;\n  let numChunks = (byteLength - remain) / packSize;\n  if (remain > 0) {\n    numChunks += 1;\n  }\n  return numChunks;\n}\n\nexport function derToBytes(derValue: string) {\n  const bytes = [];\n  for (let i = 0; i < derValue.length; i++) {\n    bytes.push(derValue.charCodeAt(i));\n  }\n  return bytes;\n}\n\nexport function hexStringToSignedIntArray(hexString: string) {\n  const result = [];\n  for (let i = 0; i < hexString.length; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    result.push(byte > 127 ? byte - 256 : byte);\n  }\n  return result;\n}\n\nexport function hexToBin(n: string): string {\n  let bin = Number(`0x${n[0]}`).toString(2);\n  for (let i = 1; i < n.length; i += 1) {\n    bin += Number(`0x${n[i]}`).toString(2).padStart(4, '0');\n  }\n  return bin;\n}\n\nexport function hexToDecimal(hex: string): string {\n  return BigInt(`0x${hex}`).toString();\n}\n\nexport function hexToSignedBytes(hexString: string): number[] {\n  const bytes = [];\n  for (let i = 0; i < hexString.length - 1; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    bytes.push(byte >= 128 ? byte - 256 : byte);\n  }\n  return bytes;\n}\n\nexport function num2Bits(n: number, inValue: bigint): bigint[] {\n  const out: bigint[] = new Array(n).fill(BigInt(0));\n  let lc1: bigint = BigInt(0);\n  let e2: bigint = BigInt(1);\n\n  for (let i = 0; i < n; i++) {\n    out[i] = (inValue >> BigInt(i)) & BigInt(1);\n\n    if (out[i] !== BigInt(0) && out[i] !== BigInt(1)) {\n      throw new Error('Bit value is not binary.');\n    }\n\n    lc1 += out[i] * e2;\n    e2 = e2 << BigInt(1);\n  }\n\n  if (lc1 !== inValue) {\n    throw new Error('Reconstructed value does not match the input.');\n  }\n  return out;\n}\n\nexport function packBytes(unpacked) {\n  const bytesCount = [31, 31, 31];\n  const packed = [0n, 0n, 0n];\n\n  let byteIndex = 0;\n  for (let i = 0; i < bytesCount.length; i++) {\n    for (let j = 0; j < bytesCount[i]; j++) {\n      if (byteIndex < unpacked.length) {\n        packed[i] |= BigInt(unpacked[byteIndex]) << (BigInt(j) * 8n);\n      }\n      byteIndex++;\n    }\n  }\n  return packed;\n}\n\nexport function packBytesArray(unpacked: number[]) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const maxBytes = unpacked.length;\n  const maxInts = computeIntChunkLength(maxBytes);\n  const out: bigint[] = new Array(maxInts).fill(0n);\n\n  for (let i = 0; i < maxInts; i++) {\n    let sum = 0n;\n    for (let j = 0; j < packSize; j++) {\n      const idx = packSize * i + j;\n\n      // Copy previous value if out of bounds\n      if (idx >= maxBytes) {\n        continue;\n      }\n      // First item of chunk is byte itself\n      else if (j === 0) {\n        sum = BigInt(unpacked[idx]);\n      }\n      // Every other item is 256^j * byte\n      else {\n        sum += (1n << BigInt(8 * j)) * BigInt(unpacked[idx]);\n      }\n    }\n    out[i] = sum;\n  }\n\n  return out;\n}\n\nexport function splitToWords(number: bigint, wordsize: number, numberElement: number) {\n  let t = number;\n  const words: string[] = [];\n  for (let i = 0; i < numberElement; ++i) {\n    const baseTwo = BigInt(2);\n\n    words.push(`${t % BigInt(Math.pow(Number(baseTwo), wordsize))}`);\n    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), wordsize)));\n  }\n  if (!(t == BigInt(0))) {\n    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;\n  }\n  return words;\n}\n\nexport const toBinaryString = (byte: any) => {\n  const binary = (parseInt(byte, 10) & 0xff).toString(2).padStart(8, '0');\n  return binary;\n};\n\nexport function toSigned(byte: number) {\n  return byte > 127 ? byte - 256 : byte;\n}\nexport function toUnsigned(byte: number) {\n  return byte & 0xff;\n}\nexport function toUnsignedByte(signedByte: number) {\n  return signedByte < 0 ? signedByte + 256 : signedByte;\n}\n","import { toUnsignedByte } from '../bytes.js';\n\nexport function formatAndConcatenateDataHashes(\n  dataHashes: [number, number[]][],\n  dg1HashOffset: number\n) {\n  // concatenating dataHashes :\n  const concat: number[] = [];\n\n  const startingSequence = Array.from(\n    { length: dg1HashOffset },\n    () => Math.floor(Math.random() * 256) - 128\n  );\n\n  // // sha256 with rsa (index of mrzhash is 31)\n  // const startingSequence = [\n  //   // SEQUENCE + long form indicator + length (293 bytes)\n  //   48, -126, 1, 37,\n  //   // length: 1 byte\n  //   2, 1,\n  //   // LDSSecurityObjectVersion v0\n  //   0,\n  //   // padding: size 11 - size 9...\n  //   48, 11, 6, 9,\n  //   // 2.16.840.1.101.3.4.2.1 is sha256\n  //   96, -122, 72, 1, 101, 3, 4, 2, 1,\n  //   // SEQUENCE + long form indicator + length (273 bytes)\n  //   48, -126, 1, 17,\n  // ]\n\n  // rsassaPss (index of mrzhash is 30)\n  // // SEQUENCE + short form indicator + length (137 bytes)\n  // 48, -127, -119,\n  // 2, 1,\n  // 0,\n  // 48, 13, 6, 9,\n  // // 2.16.840.1.101.3.4.2.1 is sha256\n  // 96, -122, 72, 1, 101, 3, 4, 2, 1,\n  // // NULL tag + SEQUENCE + length (117 bytes)\n  // 5, 0, 48, 117,\n\n  // SHA384withECDSA (index of mrzhash is 33)\n  // // SEQUENCE + long form indicator + length (313 bytes)\n  // 48, -126, 1, 57,\n  // 2, 1,\n  // 1,\n  // 48, 13, 6, 9,\n  // // 2.16.840.1.101.3.4.2.1 is sha384\n  // 96, -122, 72, 1, 101, 3, 4, 2, 2,\n  // // NULL tag + SEQUENCE + long form indicator + length (275 bytes)\n  // 5, 0, 48, -126, 1, 19,\n\n  // spain\n  // 48, -127,  -79,\n  // 2,    1,\n  // 0,\n  // 48,    7,   6,   5,\n  // 1.3.14.3.2.26 is sha1\n  // 43,  14, 3,    2,   26,\n  // SEQUENCE + ...\n  // 48, -127, -94,\n\n  // => current conclusion is we should be able to just hardcode indexes\n  // => as they shouldn't change must for same sig alg.\n  // => wrong: our rsassaPss has less datagroups so the length is different (30 rather then 31)\n\n  // console.log(`startingSequence`, startingSequence.map(byte => (byte < 0 ? byte + 256 : byte).toString(16).padStart(2, '0')).join(''));\n\n  concat.push(...startingSequence);\n\n  for (const dataHash of dataHashes) {\n    // console.log(`dataHash ${dataHash[0]}`, dataHash[1].map(byte => (byte < 0 ? byte + 256 : byte).toString(16).padStart(2, '0')).join(''));\n\n    //push 7 padding bytes\n    concat.push(...[0, 0, 0, 0, 0, 0, 0]);\n\n    concat.push(...dataHash[1]);\n    // concat.push(...[48, hashLen + 5, 2, 1, dataHash[0], 4, hashLen, ...dataHash[1]])\n    // 48, 37, 2, 1, 1, 4, 32,\n    // 48, 53, 2, 1, 1, 4, 48,\n  }\n\n  return concat;\n}\n\nexport function formatDG1Attribute(index: number[], value: string) {\n  const max_length = index[1] - index[0] + 1;\n  if (value.length > max_length) {\n    throw new Error(\n      `Value is too long for index ${index[0]}-${index[1]} value: ${value} value.length: ${value.length} maxLength: ${max_length}`\n    );\n  }\n  return value.padEnd(max_length, '<');\n}\n\nexport function formatDg2Hash(dg2Hash: number[]) {\n  const unsignedBytesDg2Hash = dg2Hash.map((x) => toUnsignedByte(x));\n  while (unsignedBytesDg2Hash.length < 64) {\n    // pad it to 64 bytes to correspond to the hash length of sha512 and avoid multiplying circuits\n    unsignedBytesDg2Hash.push(0);\n  }\n  return unsignedBytesDg2Hash;\n}\n\nexport function formatMrz(mrz: string) {\n  const mrzCharcodes = [...mrz].map((char) => char.charCodeAt(0));\n\n  if (mrz.length === 88) {\n    mrzCharcodes.unshift(88); // the length of the mrz data\n    mrzCharcodes.unshift(95, 31); // the MRZ_INFO_TAG\n    mrzCharcodes.unshift(91); // the new length of the whole array\n    mrzCharcodes.unshift(97); // the tag for DG1\n  } else if (mrz.length === 90) {\n    mrzCharcodes.unshift(90); // the length of the mrz data\n    mrzCharcodes.unshift(95, 31); // the MRZ_INFO_TAG\n    mrzCharcodes.unshift(93); // the new length of the whole array\n    mrzCharcodes.unshift(97); // the tag for DG1\n  } else {\n    throw new Error(`Unsupported MRZ length: ${mrz.length}. Expected 88 or 90 characters.`);\n  }\n\n  return mrzCharcodes;\n}\n\nexport function formatName(firstName: string, lastName: string, targetLength: number) {\n  // Split names by spaces and join parts with '<'\n  const formattedLastName = lastName.toUpperCase().split(' ').join('<');\n  const formattedFirstName = firstName.toUpperCase().split(' ').join('<');\n\n  // Combine with '<<' separator\n  let result = `${formattedLastName}<<${formattedFirstName}`;\n\n  // Pad with '<' or truncate to target length\n  if (result.length < targetLength) {\n    result = result.padEnd(targetLength, '<');\n  } else if (result.length > targetLength) {\n    result = result.substring(0, targetLength);\n  }\n\n  return result;\n}\n\nexport function generateSignedAttr(messageDigest: number[]) {\n  const constructedEContent = [];\n\n  // Detailed description is in private file r&d.ts for now\n  // First, the tag and length, assumed to be always the same\n  constructedEContent.push(...[49, 102]);\n\n  // 1.2.840.113549.1.9.3 is RFC_3369_CONTENT_TYPE_OID\n  constructedEContent.push(...[48, 21, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 3]);\n  // 2.23.136.1.1.1 is ldsSecurityObject\n  constructedEContent.push(...[49, 8, 6, 6, 103, -127, 8, 1, 1, 1]);\n\n  // 1.2.840.113549.1.9.5 is signing-time\n  constructedEContent.push(...[48, 28, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 5]);\n  // mock time of signature\n  constructedEContent.push(...[49, 15, 23, 13, 49, 57, 49, 50, 49, 54, 49, 55, 50, 50, 51, 56, 90]);\n  // 1.2.840.113549.1.9.4 is RFC_3369_MESSAGE_DIGEST_OID\n  constructedEContent.push(...[48, 47, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 4]);\n  // TAG and length of the message digest\n  constructedEContent.push(...[49, 34, 4, 32]);\n\n  constructedEContent.push(...messageDigest);\n  return constructedEContent;\n}\n","import * as forge from 'node-forge';\nimport { poseidon5 } from 'poseidon-lite';\n\nimport type { hashAlgos } from '../../constants/constants.js';\nimport {\n  k_csca,\n  k_dsc,\n  k_dsc_3072,\n  k_dsc_4096,\n  k_dsc_ecdsa,\n  n_csca,\n  n_dsc,\n  n_dsc_3072,\n  n_dsc_4096,\n  n_dsc_ecdsa,\n} from '../../constants/constants.js';\nimport { bytesToBigDecimal, hexToDecimal, splitToWords } from '../bytes.js';\nimport type {\n  CertificateData,\n  PublicKeyDetailsECDSA,\n  PublicKeyDetailsRSA,\n} from '../certificate_parsing/dataStructure.js';\nimport {\n  getCertificateFromPem,\n  parseCertificateSimple,\n} from '../certificate_parsing/parseCertificateSimple.js';\nimport { formatInput } from '../circuits/generateInputs.js';\nimport { findStartIndex, findStartIndexEC } from '../csca.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { sha384_512Pad, shaPad } from '../shaPad.js';\nimport { getLeafDscTree } from '../trees.js';\nimport type { PassportData, SignatureAlgorithm } from '../types.js';\nimport { formatMrz } from './format.js';\nimport { parsePassportData } from './passport_parsing/parsePassportData.js';\n\nexport function extractRSFromSignature(signatureBytes: number[]): { r: string; s: string } {\n  const derSignature = Buffer.from(signatureBytes).toString('binary');\n  const asn1 = forge.asn1.fromDer(derSignature);\n  const signatureAsn1 = asn1.value;\n\n  if (signatureAsn1.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n\n  if (!Array.isArray(asn1.value) || asn1.value.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n  const r = forge.util.createBuffer(asn1.value[0].value as string).toHex();\n  const s = forge.util.createBuffer(asn1.value[1].value as string).toHex();\n\n  return { r, s };\n}\n\nexport function extractSignatureFromDSC(dscCertificate: string) {\n  const cert = getCertificateFromPem(dscCertificate);\n  const dscSignature = cert.signatureValue.valueBlock.valueHexView;\n  return Array.from(dscSignature);\n}\n\nexport function findStartPubKeyIndex(\n  certificateData: CertificateData,\n  rawCert: any,\n  signatureAlgorithm: string\n): [number, number] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const [x_index, x_totalLength] = findStartIndexEC(x, rawCert);\n    const [y_index, y_totalLength] = findStartIndexEC(y, rawCert);\n\n    return [x_index, x_totalLength + y_totalLength];\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return findStartIndex(modulus, rawCert);\n  }\n}\n\n/// @notice Get the public key from the certificate padded as per the DSC circuit's requirements.\nexport function formatCertificatePubKeyDSC(\n  certificateData: CertificateData,\n  signatureAlgorithm: string\n): string[] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    // const normalizedX = x.length % 2 === 0 ? x : '0' + x;\n    // const normalizedY = y.length % 2 === 0 ? y : '0' + y;\n    const fullPubKey = x + y;\n\n    // Splits to 525 words of 8 bits each\n    return splitToWords(BigInt(hexToDecimal(fullPubKey)), 8, 525);\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), 8, 525);\n  }\n}\n\nexport function formatSignatureDSCCircuit(\n  cscaSignatureAlgorithm: string,\n  cscaHashFunction: string,\n  cscaCertificateData: CertificateData,\n  signature: number[]\n): string[] {\n  const cscaSignatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    cscaCertificateData,\n    cscaSignatureAlgorithm,\n    cscaHashFunction\n  );\n  const { n, k } = getNAndK(cscaSignatureAlgorithmFullName as SignatureAlgorithm);\n  if (cscaSignatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(signature);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return formatInput(splitToWords(BigInt(bytesToBigDecimal(signature)), n, k));\n  }\n}\n\nexport function generateCommitment(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData\n) {\n  const passportMetadata = passportData.passportMetadata;\n\n  const dg1_packed_hash = packBytesAndPoseidon(formatMrz(passportData.mrz));\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(passportData.eContent),\n    'bytes'\n  );\n\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_hash = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n  // Log the values used to generate the commitment\n\n  return poseidon5([\n    secret,\n    attestation_id,\n    dg1_packed_hash,\n    eContent_packed_hash,\n    dsc_hash,\n  ]).toString();\n}\n\nfunction getPassportSignature(passportData: PassportData, n: number, k: number): any {\n  const { signatureAlgorithm } = passportData.dsc_parsed;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(passportData.encryptedDigest);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return splitToWords(BigInt(bytesToBigDecimal(passportData.encryptedDigest)), n, k);\n  }\n}\n\nexport function generateNullifier(passportData: PassportData) {\n  const signedAttr_shaBytes = hash(\n    passportData.passportMetadata.signedAttrHashFunction,\n    Array.from(passportData.signedAttr),\n    'bytes'\n  );\n  const signedAttr_packed_hash = packBytesAndPoseidon(\n    (signedAttr_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n  return signedAttr_packed_hash;\n}\n\n/// @notice Get the public key from the certificate\n/// @dev valid for both DSC and CSCA\nexport function getCertificatePubKey(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashFunction: string\n): any {\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    certificateData,\n    signatureAlgorithm,\n    hashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const x_dsc = splitToWords(BigInt(hexToDecimal(x)), n, k);\n    const y_dsc = splitToWords(BigInt(hexToDecimal(y)), n, k);\n    return [...x_dsc, ...y_dsc];\n  } else {\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), n, k);\n  }\n}\n\nexport function getNAndK(sigAlg: SignatureAlgorithm) {\n  if (sigAlg === 'rsa_sha256_65537_3072') {\n    return { n: n_dsc_3072, k: k_dsc }; // 3072/32 = 96\n  }\n\n  if (sigAlg.startsWith('ecdsa_')) {\n    if (sigAlg.endsWith('224')) {\n      return { n: 32, k: 7 };\n    } else if (sigAlg.endsWith('256')) {\n      return { n: n_dsc_ecdsa, k: 4 };\n    } else if (sigAlg.endsWith('384')) {\n      return { n: n_dsc_ecdsa, k: 6 };\n    } else if (sigAlg.endsWith('512')) {\n      return { n: n_dsc_ecdsa, k: 8 };\n    } else if (sigAlg.endsWith('521')) {\n      return { n: 66, k: 8 };\n    } else {\n      throw new Error('invalid key size');\n    }\n  }\n\n  if (sigAlg.startsWith('rsapss_')) {\n    const keyLength = parseInt(sigAlg.split('_')[3]);\n\n    if (keyLength === 3072) {\n      return { n: n_dsc_3072, k: k_dsc_3072 }; // 3072/32 = 96\n    }\n\n    if (keyLength === 4096) {\n      return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n    }\n    return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n  }\n\n  if (sigAlg === 'rsa_sha256_65537_4096' || sigAlg === 'rsa_sha512_65537_4096') {\n    return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n  }\n\n  return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n}\n\nexport function getNAndKCSCA(sigAlg: 'rsa' | 'ecdsa' | 'rsapss') {\n  const n = sigAlg === 'ecdsa' ? n_dsc_ecdsa : n_csca;\n  const k = sigAlg === 'ecdsa' ? k_dsc_ecdsa : k_csca;\n  return { n, k };\n}\n\n/// @notice Get the signature of the passport and the public key of the DSC\n/// @dev valid for only for the passport/dsc chain\nexport function getPassportSignatureInfos(passportData: PassportData) {\n  const passportMetadata = passportData.passportMetadata;\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    passportData.dsc_parsed,\n    passportMetadata.signatureAlgorithm,\n    passportMetadata.signedAttrHashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n\n  return {\n    pubKey: getCertificatePubKey(\n      passportData.dsc_parsed,\n      passportMetadata.signatureAlgorithm,\n      passportMetadata.signedAttrHashFunction\n    ),\n    signature: getPassportSignature(passportData, n, k),\n    signatureAlgorithmFullName: signatureAlgorithmFullName,\n  };\n}\n\n/// @notice Get the signature algorithm full name\n/// @dev valid for both DSC and CSCA\nexport function getSignatureAlgorithmFullName(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashAlgorithm: string\n): string {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    return `${signatureAlgorithm}_${hashAlgorithm}_${(publicKeyDetails as PublicKeyDetailsECDSA).curve}_${publicKeyDetails.bits}`;\n  } else {\n    const { exponent } = publicKeyDetails as PublicKeyDetailsRSA;\n    return `${signatureAlgorithm}_${hashAlgorithm}_${exponent}_${publicKeyDetails.bits}`;\n  }\n}\n\n/// @dev will bruteforce passport and dsc signature\nexport function initPassportDataParsing(passportData: PassportData, skiPem: any = null) {\n  const passportMetadata = parsePassportData(passportData, skiPem);\n  passportData.passportMetadata = passportMetadata;\n  const dscParsed = parseCertificateSimple(passportData.dsc);\n  passportData.dsc_parsed = dscParsed;\n  if (passportData.passportMetadata.csca) {\n    const cscaParsed = parseCertificateSimple(passportData.passportMetadata.csca);\n    passportData.csca_parsed = cscaParsed;\n  }\n  return passportData;\n}\n\nexport function pad(hashFunction: (typeof hashAlgos)[number]) {\n  return hashFunction === 'sha1' || hashFunction === 'sha224' || hashFunction === 'sha256'\n    ? shaPad\n    : sha384_512Pad;\n}\n\nexport function padWithZeroes(bytes: number[], length: number) {\n  return bytes.concat(new Array(length - bytes.length).fill(0));\n}\n","export function assert(cond: boolean, errorMessage: string) {\n  if (!cond) {\n    throw new Error(errorMessage);\n  }\n}\n\n// Works only on 32 bit sha text lengths\nexport function int64toBytes(num: number): Uint8Array {\n  const arr = new ArrayBuffer(8); // an Int32 takes 4 bytes\n  const view = new DataView(arr);\n  view.setInt32(4, num, false); // byteOffset = 0; litteEndian = false\n  return new Uint8Array(arr);\n}\n\n// Helper function to convert 128-bit length to bytes\nfunction int128toBytes(x: number): Uint8Array {\n  const buffer = new ArrayBuffer(16);\n  const view = new DataView(buffer);\n\n  // Write high 64 bits\n  view.setBigUint64(0, BigInt(0), false);\n  // Write low 64 bits\n  view.setBigUint64(8, BigInt(x), false);\n\n  return new Uint8Array(buffer);\n}\n\n// Works only on 32 bit sha text lengths\nexport function int8toBytes(num: number): Uint8Array {\n  const arr = new ArrayBuffer(1); // an Int8 takes 4 bytes\n  const view = new DataView(arr);\n  view.setUint8(0, num); // byteOffset = 0; litteEndian = false\n  return new Uint8Array(arr);\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n  // sum of individual array lengths\n  const mergedArray = new Uint8Array(a1.length + a2.length);\n  mergedArray.set(a1);\n  mergedArray.set(a2, a1.length);\n  return mergedArray;\n}\n\nexport function sha384_512Pad(\n  prehash_prepad_m_array: number[],\n  maxShaBytes: number\n): [number[], number] {\n  let prehash_prepad_m: Uint8Array = new Uint8Array(prehash_prepad_m_array);\n  // Length in bits before padding\n  const length_bits = prehash_prepad_m.length * 8;\n\n  // For SHA-384, length is stored in 128 bits (16 bytes)\n  const length_in_bytes = int128toBytes(length_bits);\n\n  // Add the 1 bit (as a byte with value 128)\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(2 ** 7));\n\n  // Add padding zeros until total length is congruent to 896 mod 1024\n  while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 1024 !== 0) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(0));\n  }\n\n  // Append the length\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, length_in_bytes);\n\n  // Verify padding is correct (multiple of 1024 bits)\n  assert((prehash_prepad_m.length * 8) % 1024 === 0, 'Padding did not complete properly!');\n\n  const messageLen = prehash_prepad_m.length;\n\n  // Pad to max length if needed\n  while (prehash_prepad_m.length < maxShaBytes) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int128toBytes(0));\n  }\n\n  assert(\n    prehash_prepad_m.length === maxShaBytes,\n    `Padding to max length did not complete properly! Your padded message is ${prehash_prepad_m.length} long but max is ${maxShaBytes}!`\n  );\n\n  return [Array.from(prehash_prepad_m), messageLen];\n}\n\n// Copied from zk-email cuz it uses crypto so can't import it here.\n// Puts an end selector, a bunch of 0s, then the length, then fill the rest with 0s.\nexport function shaPad(prehash_prepad_m_array: number[], maxShaBytes: number): [number[], number] {\n  let prehash_prepad_m: Uint8Array = new Uint8Array(prehash_prepad_m_array);\n  const length_bits = prehash_prepad_m.length * 8; // bytes to bits\n  const length_in_bytes = int64toBytes(length_bits);\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(2 ** 7)); // Add the 1 on the end, length 505\n  while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 512 !== 0) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(0));\n  }\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, length_in_bytes);\n  assert((prehash_prepad_m.length * 8) % 512 === 0, 'Padding did not complete properly!');\n  const messageLen = prehash_prepad_m.length;\n  while (prehash_prepad_m.length < maxShaBytes) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int64toBytes(0));\n  }\n  assert(\n    prehash_prepad_m.length === maxShaBytes,\n    `Padding to max length did not complete properly! Your padded message is ${prehash_prepad_m.length} long but max is ${maxShaBytes}!`\n  );\n  return [Array.from(prehash_prepad_m), messageLen];\n}\n","import countries from 'i18n-iso-countries';\n// @ts-ignore\nimport en from 'i18n-iso-countries/langs/en.json' with { type: 'json' };\nimport { poseidon2, poseidon3, poseidon6, poseidon10, poseidon12, poseidon13 } from 'poseidon-lite';\n\nimport {\n  CSCA_TREE_DEPTH,\n  DSC_TREE_DEPTH,\n  max_csca_bytes,\n  max_dsc_bytes,\n  OFAC_TREE_LEVELS,\n} from '../constants/constants.js';\nimport type { CertificateData } from './certificate_parsing/dataStructure.js';\nimport { parseCertificateSimple } from './certificate_parsing/parseCertificateSimple.js';\nimport { stringToAsciiBigIntArray } from './circuits/uuid.js';\nimport { packBytesAndPoseidon } from './hash.js';\nimport { pad } from './passports/passport.js';\nimport type { DscCertificateMetaData } from './passports/passport_parsing/parseDscCertificateData.js';\nimport { parseDscCertificateData } from './passports/passport_parsing/parseDscCertificateData.js';\n\nimport { IMT } from '@openpassport/zk-kit-imt';\nimport { LeanIMT } from '@openpassport/zk-kit-lean-imt';\nimport type { ChildNodes } from '@openpassport/zk-kit-smt';\nimport { SMT } from '@openpassport/zk-kit-smt';\n\n// SideEffect here\ncountries.registerLocale(en);\n\n// SMT trees for 3 levels of matching :\n// 1. Passport Number and Nationality tree : level 3 (Absolute Match)\n// 2. Name and date of birth combo tree : level 2 (High Probability Match)\n// 3. Name and year of birth combo tree : level 1 (Partial Match)\n// NEW: ID card specific trees\nexport function buildSMT(field: any[], treetype: string): [number, number, SMT] {\n  let count = 0;\n  const startTime = performance.now();\n\n  const hash2 = (childNodes: ChildNodes) =>\n    childNodes.length === 2 ? poseidon2(childNodes) : poseidon3(childNodes);\n  const tree = new SMT(hash2, true);\n\n  for (let i = 0; i < field.length; i++) {\n    const entry = field[i];\n\n    // Optimization: Log progress less frequently\n    if (i !== 0 && i % 100 === 0) {\n      console.log('Processing', treetype, 'number', i, 'out of', field.length);\n    }\n\n    let leaf = BigInt(0);\n    // Determine document type based on treetype for name processing\n    let docType: 'passport' | 'id_card' = 'passport'; // Default to passport\n    if (treetype.endsWith('_id_card')) {\n      docType = 'id_card';\n    }\n\n    if (treetype == 'passport_no_and_nationality') {\n      leaf = processPassportNoAndNationality(entry.Pass_No, entry.Pass_Country, i);\n    } else if (treetype == 'name_and_dob') {\n      leaf = processNameAndDob(entry, i, 'passport'); // Explicitly passport\n    } else if (treetype == 'name_and_yob') {\n      leaf = processNameAndYob(entry, i, 'passport'); // Explicitly passport\n    } else if (treetype == 'name_and_dob_id_card') {\n      // New ID card type\n      leaf = processNameAndDob(entry, i, 'id_card');\n    } else if (treetype == 'name_and_yob_id_card') {\n      // New ID card type\n      leaf = processNameAndYob(entry, i, 'id_card');\n    } else if (treetype == 'country') {\n      const keys = Object.keys(entry);\n      leaf = processCountry(keys[0], entry[keys[0]], i);\n    }\n\n    if (leaf == BigInt(0)) {\n      // Skip entries that couldn't be processed (e.g., missing data)\n      continue;\n    }\n\n    // Check for duplicates *after* processing, as different inputs might yield the same hash\n    if (tree.createProof(leaf).membership) {\n      // console.log('Duplicate leaf generated, skipping entry:', i, entry); // Optional: log duplicates\n      continue;\n    }\n\n    count += 1;\n    tree.add(leaf, BigInt(1));\n  }\n\n  console.log('Total', treetype, 'entries added:', count, 'out of', field.length);\n  console.log(treetype, 'tree built in', (performance.now() - startTime).toFixed(2), 'ms');\n  return [count, performance.now() - startTime, tree];\n}\n\nexport function formatRoot(root: string): string {\n  const rootHex = BigInt(root).toString(16);\n  return rootHex.length % 2 === 0 ? '0x' + rootHex : '0x0' + rootHex;\n}\n\nexport function generateMerkleProof(imt: LeanIMT, _index: number, maxleaf_depth: number) {\n  const { siblings: siblings, index } = imt.generateProof(_index);\n  const leaf_depth = siblings.length;\n  // The index must be converted to a list of indices, 1 for each tree level.\n  // The circuit tree leaf_depth is 20, so the number of siblings must be 20, even if\n  // the tree leaf_depth is actually 3. The missing siblings can be set to 0, as they\n  // won't be used to calculate the root in the circuit.\n  const path: number[] = [];\n\n  for (let i = 0; i < maxleaf_depth; i += 1) {\n    path.push((index >> i) & 1);\n    if (siblings[i] === undefined) {\n      siblings[i] = BigInt(0);\n    }\n  }\n  return { siblings, path, leaf_depth };\n}\n\nexport function generateSMTProof(smt: SMT, leaf: bigint) {\n  const { entry, matchingEntry, siblings, root, membership } = smt.createProof(leaf);\n  const leaf_depth = siblings.length;\n\n  let closestleaf;\n  if (!matchingEntry) {\n    // we got the 0 leaf or membership\n    // then check if entry[1] exists\n    if (!entry[1]) {\n      // non membership proof\n      closestleaf = BigInt(0); // 0 leaf\n    } else {\n      closestleaf = BigInt(entry[0]); // leaf itself (memb proof)\n    }\n  } else {\n    // non membership proof\n    closestleaf = BigInt(matchingEntry[0]); // actual closest\n  }\n\n  // PATH, SIBLINGS manipulation as per binary tree in the circuit\n  siblings.reverse();\n  while (siblings.length < OFAC_TREE_LEVELS) siblings.push(BigInt(0));\n\n  // ----- Useful for debugging hence leaving as comments -----\n  // const binary = entry[0].toString(2)\n  // const bits = binary.slice(-leaf_depth);\n  // let indices = bits.padEnd(256, \"0\").split(\"\").map(Number)\n  // const pathToMatch = num2Bits(256,BigInt(entry[0]))\n  // while(indices.length < 256) indices.push(0);\n  // // CALCULATED ROOT FOR TESTING\n  // // closestleaf, leaf_depth, siblings, indices, root : needed\n  // let calculatedNode = poseidon3([closestleaf,1,1]);\n  // console.log(\"Initial node while calculating\",calculatedNode)\n  // console.log(smt.verifyProof(smt.createProof(leaf)))\n  // for (let i= 0; i < leaf_depth ; i++) {\n  //   const childNodes: any = indices[i] ? [siblings[i], calculatedNode] : [calculatedNode, siblings[i]]\n  //   console.log(indices[i],childNodes)\n  //   calculatedNode = poseidon2(childNodes)\n  // }\n  // console.log(\"Actual node\", root)\n  // console.log(\"calculated node\", calculatedNode)\n  // -----------------------------------------------------------\n\n  return {\n    root,\n    leaf_depth,\n    closestleaf,\n    siblings,\n  };\n}\n\nexport function getCountryLeaf(\n  country_by: (bigint | number)[],\n  country_to: (bigint | number)[],\n  i?: number\n): bigint {\n  if (country_by.length !== 3 || country_to.length !== 3) {\n    console.log('parsed passport length is not 3:', i, country_to, country_by);\n    return;\n  }\n  try {\n    const country = country_by.concat(country_to);\n    return poseidon6(country);\n  } catch (err) {\n    console.log('err : sanc_country hash', err, i, country_by, country_to);\n  }\n}\n\nexport function getCscaTreeInclusionProof(leaf: string, _serialized_csca_tree: any[][]) {\n  const tree = new IMT(poseidon2, CSCA_TREE_DEPTH, 0, 2);\n  tree.setNodes(_serialized_csca_tree);\n  const index = tree.indexOf(leaf);\n  if (index === -1) {\n    throw new Error('Your public key was not found in the registry');\n  }\n  const proof = tree.createProof(index);\n  return [\n    tree.root,\n    proof.pathIndices.map((index) => index.toString()),\n    proof.siblings.flat().map((sibling) => sibling.toString()),\n  ];\n}\n\nexport function getCscaTreeRoot(serialized_csca_tree: any[][]) {\n  const tree = new IMT(poseidon2, CSCA_TREE_DEPTH, 0, 2);\n  tree.setNodes(serialized_csca_tree);\n  return tree.root;\n}\n\nexport function getDobLeaf(dobMrz: (bigint | number)[], i?: number): bigint {\n  if (dobMrz.length !== 6) {\n    // console.log('parsed dob length is not 6:', i, dobMrz); // Corrected length check message\n    return BigInt(0); // Return 0 for invalid length\n  }\n  try {\n    return poseidon6(dobMrz);\n  } catch (err) {\n    console.error('Error in getDobLeaf:', err, 'Index:', i, 'DOB MRZ:', dobMrz); // Use console.error\n    return BigInt(0); // Return 0 on error\n  }\n}\n\nexport function getDscTreeInclusionProof(\n  leaf: string,\n  serialized_dsc_tree: string\n): [string, number[], bigint[], number] {\n  const hashFunction = (a: any, b: any) => poseidon2([a, b]);\n  const tree = LeanIMT.import(hashFunction, serialized_dsc_tree);\n  const index = tree.indexOf(BigInt(leaf));\n  if (index === -1) {\n    throw new Error('Your public key was not found in the registry');\n  }\n  const { siblings, path, leaf_depth } = generateMerkleProof(tree, index, DSC_TREE_DEPTH);\n  return [tree.root, path, siblings, leaf_depth];\n}\n\n/** get leaf for DSC and CSCA Trees */\nexport function getLeaf(parsed: CertificateData, type: 'dsc' | 'csca'): string {\n  if (type === 'dsc') {\n    // for now, we pad it for sha\n    const tbsArray = Object.keys(parsed.tbsBytes).map((key) => parsed.tbsBytes[key]);\n    const [paddedTbsBytes, tbsBytesPaddedLength] = pad(parsed.hashAlgorithm)(\n      tbsArray,\n      max_dsc_bytes\n    );\n    const dsc_hash = packBytesAndPoseidon(Array.from(paddedTbsBytes));\n\n    return poseidon2([dsc_hash, tbsArray.length]).toString();\n  } else {\n    const tbsBytesArray = Array.from(parsed.tbsBytes);\n    const paddedTbsBytesArray = tbsBytesArray.concat(\n      new Array(max_csca_bytes - tbsBytesArray.length).fill(0)\n    );\n    const csca_hash = packBytesAndPoseidon(paddedTbsBytesArray);\n    return poseidon2([csca_hash, tbsBytesArray.length]).toString();\n  }\n}\n\nexport function getLeafCscaTree(csca_parsed: CertificateData): string {\n  return getLeaf(csca_parsed, 'csca');\n}\n\nexport function getLeafDscTree(dsc_parsed: CertificateData, csca_parsed: CertificateData): string {\n  const dscLeaf = getLeaf(dsc_parsed, 'dsc');\n  const cscaLeaf = getLeaf(csca_parsed, 'csca');\n  return poseidon2([dscLeaf, cscaLeaf]).toString();\n}\n\nfunction processPassportNoAndNationality(\n  passno: string,\n  nationality: string,\n  index: number\n): bigint {\n  if (passno.length > 9) {\n    console.log('passport number length is greater than 9:', index, passno);\n  } else if (passno.length < 9) {\n    while (passno.length != 9) {\n      passno += '<';\n    }\n  }\n\n  const countryCode = getCountryCode(nationality);\n  if (!countryCode) {\n    console.log('Error getting country code', index, nationality);\n    return BigInt(0);\n  }\n  console.log('nationality and countryCode', nationality, countryCode);\n\n  const leaf = getPassportNumberAndNationalityLeaf(\n    stringToAsciiBigIntArray(passno),\n    stringToAsciiBigIntArray(countryCode),\n    index\n  );\n  if (!leaf) {\n    console.log('Error creating leaf value', index, passno, nationality);\n    return BigInt(0);\n  }\n  return leaf;\n}\n\n// this is a temporary workaround for some of the country name,\n// will be removed once we parse the OFAC list better, starting from the XML file.\nconst normalizeCountryName = (country: string): string => {\n  const mapping: Record<string, string> = {\n    palestinian: 'Palestine',\n    'korea, north': 'North Korea',\n    'korea, south': 'Korea, Republic of',\n    'united kingdom': 'United Kingdom',\n    syria: 'Syrian Arab Republic',\n    burma: 'Myanmar',\n    'cabo verde': 'Cape Verde',\n    'congo, democratic republic of the': 'Democratic Republic of the Congo',\n    macau: 'Macao',\n  };\n  return mapping[country.toLowerCase()] || country;\n};\n\nconst getCountryCode = (countryName: string): string | undefined => {\n  return countries.getAlpha3Code(normalizeCountryName(countryName), 'en');\n};\n\nfunction generateSmallKey(input: bigint): bigint {\n  return input % (BigInt(1) << BigInt(OFAC_TREE_LEVELS));\n}\n\nfunction processNameAndDob(entry: any, i: number, docType: 'passport' | 'id_card'): bigint {\n  const firstName = entry.First_Name;\n  const lastName = entry.Last_Name;\n  const day = entry.day;\n  const month = entry.month;\n  const year = entry.year;\n  if (day == null || month == null || year == null || !firstName || !lastName) {\n    // Added checks for name presence\n    // console.log('Name or DOB data missing for name_and_dob', i, entry); // Optional: log missing data\n    return BigInt(0);\n  }\n  const targetLength = docType === 'passport' ? 39 : 30;\n  const nameHash = processName(firstName, lastName, targetLength, i);\n  if (nameHash === BigInt(0)) return BigInt(0); // Propagate error\n  const dobHash = processDob(day, month, year, i);\n  if (dobHash === BigInt(0)) return BigInt(0); // Propagate error\n\n  return generateSmallKey(poseidon2([dobHash, nameHash]));\n}\n\nfunction processNameAndYob(entry: any, i: number, docType: 'passport' | 'id_card'): bigint {\n  const firstName = entry.First_Name;\n  const lastName = entry.Last_Name;\n  const year = entry.year;\n  if (year == null || !firstName || !lastName) {\n    // Added checks for name presence\n    // console.log('Name or YOB data missing for name_and_yob', i, entry); // Optional: log missing data\n    return BigInt(0);\n  }\n  const targetLength = docType === 'passport' ? 39 : 30;\n  const nameHash = processName(firstName, lastName, targetLength, i);\n  if (nameHash === BigInt(0)) return BigInt(0); // Propagate error\n  const yearHash = processYear(year, i);\n  if (yearHash === BigInt(0)) return BigInt(0); // Propagate error\n\n  return generateSmallKey(poseidon2([yearHash, nameHash]));\n}\n\nfunction processYear(year: string, i: number): bigint {\n  if (!year || typeof year !== 'string' || year.length < 2) {\n    // console.log('Invalid year format for processYear', i, year); // Optional: log error\n    return BigInt(0);\n  }\n  const yearSuffix = year.slice(-2);\n  const yearArr = stringToAsciiBigIntArray(yearSuffix);\n  return getYearLeaf(yearArr);\n}\n\nfunction getYearLeaf(yearArr: (bigint | number)[]): bigint {\n  if (yearArr.length !== 2) {\n    // console.log('Invalid year array length for getYearLeaf', yearArr); // Optional: log error\n    return BigInt(0);\n  }\n  try {\n    return poseidon2(yearArr);\n  } catch (err) {\n    // console.log('err : Year hash', err, yearArr); // Optional: log error\n    return BigInt(0);\n  }\n}\n\nfunction processName(\n  firstName: string,\n  lastName: string,\n  targetLength: 30 | 39,\n  i: number\n): bigint {\n  // LASTNAME<<FIRSTNAME<MIDDLENAME<<<...\n  // Ensure names are strings before processing\n  const cleanFirstName =\n    typeof firstName === 'string'\n      ? firstName.replace(/'/g, '').replace(/\\./g, '').replace(/[- ]/g, '<')\n      : '';\n  const cleanLastName =\n    typeof lastName === 'string'\n      ? lastName.replace(/'/g, '').replace(/[- ]/g, '<').replace(/\\./g, '')\n      : '';\n\n  // Handle cases where one name might be missing\n  let arr = (cleanLastName ? cleanLastName + '<<' : '') + cleanFirstName;\n\n  if (arr.length === 0) {\n    // console.log('Cannot process empty name string', i); // Optional: log error\n    return BigInt(0);\n  }\n\n  // Pad or truncate to target length\n  if (arr.length > targetLength) {\n    arr = arr.substring(0, targetLength);\n  } else {\n    while (arr.length < targetLength) {\n      arr += '<';\n    }\n  }\n  console.log('arr', arr, 'arr.length', arr.length);\n  const nameArr = stringToAsciiBigIntArray(arr);\n  // getNameLeaf will select the correct Poseidon hash based on nameArr.length\n  return getNameLeaf(nameArr, i);\n}\n\nfunction processDob(day: string, month: string, year: string, i: number): bigint {\n  // YYMMDD\n  const monthMap: { [key: string]: string } = {\n    jan: '01',\n    feb: '02',\n    mar: '03',\n    apr: '04',\n    may: '05',\n    jun: '06',\n    jul: '07',\n    aug: '08',\n    sep: '09',\n    oct: '10',\n    nov: '11',\n    dec: '12',\n  };\n\n  const lowerMonth = typeof month === 'string' ? month.toLowerCase() : '';\n  const mappedMonth = monthMap[lowerMonth];\n\n  if (\n    !mappedMonth ||\n    !day ||\n    typeof day !== 'string' ||\n    day.length !== 2 ||\n    !year ||\n    typeof year !== 'string' ||\n    year.length < 2\n  ) {\n    // console.log('Invalid DOB component format for processDob', i, {day, month, year}); // Optional: log error\n    return BigInt(0);\n  }\n\n  const yearSuffix = year.slice(-2);\n  const dob = yearSuffix + mappedMonth + day;\n  const arr = stringToAsciiBigIntArray(dob);\n  return getDobLeaf(arr, i);\n}\n\nfunction processCountry(country1: string, country2: string, i: number) {\n  const arr = stringToAsciiBigIntArray(country1);\n  const arr2 = stringToAsciiBigIntArray(country2);\n\n  const leaf = getCountryLeaf(arr, arr2, i);\n  if (!leaf) {\n    console.log('Error creating leaf value', i, country1, country2);\n    return BigInt(0);\n  }\n  return leaf;\n}\n\nexport function getLeafDscTreeFromDscCertificateMetadata(\n  dscParsed: CertificateData,\n  dscMetaData: DscCertificateMetaData\n): string {\n  // TODO: WRONG  change this function using raw dsc and hashfunctions from passportMetadata\n  const cscaParsed = parseCertificateSimple(dscMetaData.csca);\n  return getLeafDscTree(dscParsed, cscaParsed);\n}\n\nexport function getLeafDscTreeFromParsedDsc(dscParsed: CertificateData): string {\n  return getLeafDscTreeFromDscCertificateMetadata(dscParsed, parseDscCertificateData(dscParsed));\n}\n\nexport function getNameDobLeaf(\n  nameMrz: (bigint | number)[],\n  dobMrz: (bigint | number)[],\n  i?: number\n): bigint {\n  return generateSmallKey(poseidon2([getDobLeaf(dobMrz), getNameLeaf(nameMrz)]));\n}\n\nexport function getNameLeaf(nameMrz: (bigint | number)[], i?: number): bigint {\n  const middleChunks: bigint[] = [];\n  const chunks: (number | bigint)[][] = [];\n  try {\n    // Add try-catch block\n    if (nameMrz.length == 39) {\n      // passport\n      chunks.push(nameMrz.slice(0, 13), nameMrz.slice(13, 26), nameMrz.slice(26, 39));\n      for (const chunk of chunks) {\n        if (chunk.length !== 13)\n          throw new Error(`Invalid chunk length for Poseidon13: ${chunk.length}`);\n        middleChunks.push(poseidon13(chunk));\n      }\n    } else if (nameMrz.length == 30) {\n      // id_card\n      chunks.push(nameMrz.slice(0, 10), nameMrz.slice(10, 20), nameMrz.slice(20, 30)); // Corrected comment: 30/3 for poseidon10\n      for (const chunk of chunks) {\n        if (chunk.length !== 10)\n          throw new Error(`Invalid chunk length for Poseidon10: ${chunk.length}`);\n        middleChunks.push(poseidon10(chunk));\n      }\n    } else {\n      throw new Error(`Unsupported name MRZ length: ${nameMrz.length}`); // Handle unexpected lengths\n    }\n\n    if (middleChunks.length !== 3)\n      throw new Error(`Invalid number of middle chunks: ${middleChunks.length}`);\n    return poseidon3(middleChunks);\n  } catch (err) {\n    console.error('Error in getNameLeaf:', err, 'Index:', i, 'MRZ Length:', nameMrz.length); // Use console.error for errors\n    // console.log('MRZ data:', nameMrz); // Optional: log failing data\n    return BigInt(0); // Return 0 on error\n  }\n}\n\nexport function getNameYobLeaf(\n  nameMrz: (bigint | number)[],\n  yobMrz: (bigint | number)[],\n  i?: number\n): bigint {\n  return generateSmallKey(poseidon2([getYearLeaf(yobMrz), getNameLeaf(nameMrz)]));\n}\n\nexport function getPassportNumberAndNationalityLeaf(\n  passport: (bigint | number)[],\n  nationality: (bigint | number)[],\n  i?: number\n): bigint {\n  if (passport.length !== 9) {\n    console.log('parsed passport length is not 9:', i, passport);\n    return;\n  }\n  if (nationality.length !== 3) {\n    console.log('parsed nationality length is not 3:', i, nationality);\n    return;\n  }\n  try {\n    const fullHash = poseidon12(passport.concat(nationality));\n    return generateSmallKey(fullHash);\n  } catch (err) {\n    console.log('err : passport', err, i, passport);\n  }\n}\n","import { MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH } from '../../constants/constants.js';\n// import { commonNames } from '../../constants/countries.js';\n\n/**\n * Formats the list of country codes for use in verification circuits.\n * Important: this list must exactly match the list in the backend.\n *\n * @param countries Array of three-letter country codes\n * @returns Formatted byte array representing country codes\n * @throws Error if the maximum list length is exceeded or if country codes are invalid\n */\nexport function formatCountriesList(countries: string[]) {\n  // Check maximum list length\n  if (countries.length > MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH) {\n    throw new Error(\n      `Countries list must be inferior or equals to ${MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH}`\n    );\n  }\n\n  // Validate country codes\n  for (const country of countries) {\n    if (!country || country.length !== 3) {\n      throw new Error(\n        `Invalid country code: \"${country}\". Country codes must be exactly 3 characters long.`\n      );\n    }\n\n    // Optional check for the country code existence in the list of valid codes\n    // This code can be uncommented if strict validation of country codes is needed\n    /*\n        const isValidCountry = Object.values(commonNames).some(\n            name => name === country || country in commonNames\n        );\n\n        if (!isValidCountry) {\n            throw new Error(`Unknown country code: \"${country}\". Please use valid 3-letter ISO country codes.`);\n        }\n        */\n  }\n\n  const paddedCountries = countries.concat(\n    Array(MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH - countries.length).fill('')\n  );\n  const result = paddedCountries.flatMap((country) => {\n    const chars = country\n      .padEnd(3, '\\0')\n      .split('')\n      .map((char) => char.charCodeAt(0));\n    return chars;\n  });\n  return result;\n}\n\nexport function reverseBytes(input: string): string {\n  const hex = input.slice(2);\n\n  const bytes = hex.match(/.{2}/g) || [];\n\n  const reversedBytes = bytes.reverse();\n\n  return '0x' + reversedBytes.join('');\n}\n\nexport function reverseCountryBytes(input: string): string {\n  const hex = input.slice(2);\n  const groups = hex.match(/.{6}/g) || [];\n  const reversedGroups = groups.reverse();\n\n  const remainderLength = hex.length % 6;\n  let remainder = '';\n  if (remainderLength > 0) {\n    remainder = hex.slice(hex.length - remainderLength);\n  }\n\n  return '0x' + reversedGroups.join('') + remainder;\n}\n","import {\n  COMMITMENT_TREE_DEPTH,\n  max_csca_bytes,\n  max_dsc_bytes,\n  MAX_PADDED_ECONTENT_LEN,\n  MAX_PADDED_SIGNED_ATTR_LEN,\n  OFAC_TREE_LEVELS,\n} from '../../constants/constants.js';\nimport { getCurrentDateYYMMDD } from '../date.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { formatMrz } from '../passports/format.js';\nimport {\n  extractSignatureFromDSC,\n  findStartPubKeyIndex,\n  formatSignatureDSCCircuit,\n  generateCommitment,\n  getCertificatePubKey,\n  getPassportSignatureInfos,\n  pad,\n  padWithZeroes,\n} from '../passports/passport.js';\nimport {\n  generateMerkleProof,\n  generateSMTProof,\n  getCountryLeaf,\n  getCscaTreeInclusionProof,\n  getDscTreeInclusionProof,\n  getLeafCscaTree,\n  getLeafDscTree,\n  getNameDobLeaf,\n  getNameYobLeaf,\n  getPassportNumberAndNationalityLeaf,\n} from '../trees.js';\nimport type { PassportData } from '../types.js';\nimport { formatCountriesList } from './formatInputs.js';\nimport { stringToAsciiBigIntArray } from './uuid.js';\n\nimport type { LeanIMT } from '@openpassport/zk-kit-lean-imt';\nimport type { SMT } from '@openpassport/zk-kit-smt';\n\n// this get the commitment index whether it is a string or a bigint\n// this is necessary rn because when the tree is send from the server in a serialized form,\n// the bigints are converted to strings and I can't figure out how to use tree.import to load bigints there\nexport function findIndexInTree(tree: LeanIMT, commitment: bigint): number {\n  let index = tree.indexOf(commitment);\n  if (index === -1) {\n    index = tree.indexOf(commitment.toString() as unknown as bigint);\n  }\n  if (index === -1) {\n    throw new Error('This commitment was not found in the tree');\n  } else {\n    //  console.log(`Index of commitment in the registry: ${index}`);\n  }\n  return index;\n}\n\nexport function formatInput(input: any) {\n  if (Array.isArray(input)) {\n    return input.map((item) => BigInt(item).toString());\n  } else if (input instanceof Uint8Array) {\n    return Array.from(input).map((num) => BigInt(num).toString());\n  } else if (typeof input === 'string' && input.includes(',')) {\n    const numbers = input\n      .split(',')\n      .map((s) => s.trim())\n      .filter((s) => s !== '' && !isNaN(Number(s)))\n      .map(Number);\n\n    try {\n      return numbers.map((num) => BigInt(num).toString());\n    } catch (e) {\n      throw e;\n    }\n  } else {\n    return [BigInt(input).toString()];\n  }\n}\n\nexport function generateCircuitInputsCountryVerifier(\n  passportData: PassportData,\n  sparsemerkletree: SMT\n) {\n  const mrz_bytes = formatMrz(passportData.mrz);\n  const usa_ascii = stringToAsciiBigIntArray('USA');\n  const country_leaf = getCountryLeaf(usa_ascii, mrz_bytes.slice(7, 10));\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, country_leaf);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    hostCountry: formatInput(usa_ascii),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsDSC(\n  passportData: PassportData,\n  serializedCscaTree: string[][]\n) {\n  const passportMetadata = passportData.passportMetadata;\n  const cscaParsed = passportData.csca_parsed;\n  const dscParsed = passportData.dsc_parsed;\n  const raw_dsc = passportData.dsc;\n  // CSCA is padded with 0s to max_csca_bytes\n  const cscaTbsBytesPadded = padWithZeroes(cscaParsed.tbsBytes, max_csca_bytes);\n  const dscTbsBytes = dscParsed.tbsBytes;\n\n  // DSC is padded using sha padding because it will be hashed in the circuit\n  const [dscTbsBytesPadded, dscTbsBytesLen] = pad(passportMetadata.cscaHashFunction)(\n    dscTbsBytes,\n    max_dsc_bytes\n  );\n  const leaf = getLeafCscaTree(cscaParsed);\n  const [root, path, siblings] = getCscaTreeInclusionProof(leaf, serializedCscaTree);\n  // Parse CSCA certificate and get its public key\n  const csca_pubKey_formatted = getCertificatePubKey(\n    cscaParsed,\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction\n  );\n\n  const signatureRaw = extractSignatureFromDSC(raw_dsc);\n  const signature = formatSignatureDSCCircuit(\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction,\n    cscaParsed,\n    signatureRaw\n  );\n  // Get start index of CSCA pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    cscaParsed,\n    cscaTbsBytesPadded,\n    passportMetadata.cscaSignatureAlgorithm\n  );\n  return {\n    raw_csca: cscaTbsBytesPadded.map((x) => x.toString()),\n    raw_csca_actual_length: BigInt(cscaParsed.tbsBytes.length).toString(),\n    csca_pubKey_offset: startIndex.toString(),\n    csca_pubKey_actual_size: BigInt(keyLength).toString(),\n    raw_dsc: Array.from(dscTbsBytesPadded).map((x) => x.toString()),\n    raw_dsc_padded_length: BigInt(dscTbsBytesLen).toString(), // with the sha padding actually\n    csca_pubKey: csca_pubKey_formatted,\n    signature,\n    merkle_root: root,\n    path: path,\n    siblings: siblings,\n  };\n}\n\nexport function generateCircuitInputsOfac(\n  passportData: PassportData,\n  sparsemerkletree: SMT,\n  proofLevel: number\n) {\n  const { mrz, documentType } = passportData;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const mrz_bytes = formatMrz(mrz); // Assume formatMrz handles basic formatting\n  const nameSlice = isPassportType\n    ? mrz_bytes.slice(5 + 5, 44 + 5)\n    : mrz_bytes.slice(60 + 5, 90 + 5);\n  const dobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 63 + 5)\n    : mrz_bytes.slice(30 + 5, 36 + 5);\n  const yobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 59 + 5)\n    : mrz_bytes.slice(30 + 5, 32 + 5);\n  const nationalitySlice = isPassportType\n    ? mrz_bytes.slice(54 + 5, 57 + 5)\n    : mrz_bytes.slice(45 + 5, 48 + 5);\n  const passNoSlice = isPassportType\n    ? mrz_bytes.slice(44 + 5, 53 + 5)\n    : mrz_bytes.slice(5 + 5, 14 + 5);\n\n  let leafToProve: bigint;\n\n  if (proofLevel == 3) {\n    if (!isPassportType) {\n      throw new Error(\n        'Proof level 3 (Passport Number) is only applicable to passport document types.'\n      );\n    }\n    leafToProve = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n  } else if (proofLevel == 2) {\n    leafToProve = getNameDobLeaf(nameSlice, dobSlice);\n  } else if (proofLevel == 1) {\n    leafToProve = getNameYobLeaf(nameSlice, yobSlice);\n  } else {\n    throw new Error('Invalid proof level specified for OFAC check.');\n  }\n\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, leafToProve);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsRegister(\n  secret: string,\n  passportData: PassportData,\n  serializedDscTree: string\n) {\n  const { mrz, eContent, signedAttr } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const dscParsed = passportData.dsc_parsed;\n\n  const [dscTbsBytesPadded] = pad(dscParsed.hashAlgorithm)(dscParsed.tbsBytes, max_dsc_bytes);\n\n  const { pubKey, signature, signatureAlgorithmFullName } = getPassportSignatureInfos(passportData);\n  const mrz_formatted = formatMrz(mrz);\n\n  if (eContent.length > MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]) {\n    console.error(\n      `eContent too long (${eContent.length} bytes). Max length is ${MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]} bytes.`\n    );\n    throw new Error(\n      `This length of datagroups (${eContent.length} bytes) is currently unsupported. Please contact us so we add support!`\n    );\n  }\n\n  const [eContentPadded, eContentLen] = pad(passportMetadata.eContentHashFunction)(\n    eContent,\n    MAX_PADDED_ECONTENT_LEN[passportMetadata.dg1HashFunction]\n  );\n  const [signedAttrPadded, signedAttrPaddedLen] = pad(passportMetadata.signedAttrHashFunction)(\n    signedAttr,\n    MAX_PADDED_SIGNED_ATTR_LEN[passportMetadata.eContentHashFunction]\n  );\n\n  const dsc_leaf = getLeafDscTree(dscParsed, passportData.csca_parsed); // TODO: WRONG\n  const [root, path, siblings, leaf_depth] = getDscTreeInclusionProof(dsc_leaf, serializedDscTree);\n  const csca_tree_leaf = getLeafCscaTree(passportData.csca_parsed);\n\n  // Get start index of DSC pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    dscParsed,\n    dscTbsBytesPadded,\n    dscParsed.signatureAlgorithm\n  );\n\n  const inputs = {\n    raw_dsc: dscTbsBytesPadded.map((x) => x.toString()),\n    raw_dsc_actual_length: [BigInt(dscParsed.tbsBytes.length).toString()],\n    dsc_pubKey_offset: startIndex,\n    dsc_pubKey_actual_size: [BigInt(keyLength).toString()],\n    dg1: mrz_formatted,\n    dg1_hash_offset: passportMetadata.dg1HashOffset,\n    eContent: eContentPadded,\n    eContent_padded_length: eContentLen,\n    signed_attr: signedAttrPadded,\n    signed_attr_padded_length: signedAttrPaddedLen,\n    signed_attr_econtent_hash_offset: passportMetadata.eContentHashOffset,\n    pubKey_dsc: pubKey,\n    signature_passport: signature,\n    merkle_root: [BigInt(root).toString()],\n    leaf_depth: leaf_depth,\n    path: path,\n    siblings: siblings,\n    csca_tree_leaf: csca_tree_leaf,\n    secret: secret,\n  };\n\n  return Object.entries(inputs)\n    .map(([key, value]) => ({\n      [key]: formatInput(value),\n    }))\n    .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n}\n\nexport function generateCircuitInputsVCandDisclose(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData,\n  scope: string,\n  selector_dg1: string[],\n  selector_older_than: string | number,\n  merkletree: LeanIMT,\n  majority: string,\n  passportNo_smt: SMT | null,\n  nameAndDob_smt: SMT,\n  nameAndYob_smt: SMT,\n  selector_ofac: string | number,\n  forbidden_countries_list: string[],\n  user_identifier: string\n) {\n  const { mrz, eContent, signedAttr, documentType } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const formattedMrz = formatMrz(mrz);\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(eContent),\n    'bytes'\n  );\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_tree_leaf = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n\n  const commitment = generateCommitment(secret, attestation_id, passportData);\n  const index = findIndexInTree(merkletree, BigInt(commitment));\n  const { siblings, path, leaf_depth } = generateMerkleProof(\n    merkletree,\n    index,\n    COMMITMENT_TREE_DEPTH\n  );\n  const formattedMajority = majority.length === 1 ? `0${majority}` : majority;\n  const majority_ascii = formattedMajority.split('').map((char) => char.charCodeAt(0));\n\n  // Define default values for SMT proofs (BigInt(0) for roots/keys, array of 0s for siblings)\n  const defaultSiblings = Array(OFAC_TREE_LEVELS).fill(BigInt(0));\n  let passportNoProof = {\n    root: BigInt(0),\n    closestleaf: BigInt(0),\n    siblings: defaultSiblings,\n  };\n  let nameDobProof;\n  let nameYobProof;\n\n  // Calculate leaves based on document type (using OFAC logic for slicing)\n  const nameSlice = isPassportType ? formattedMrz.slice(10, 49) : formattedMrz.slice(65, 95);\n  const dobSlice = isPassportType ? formattedMrz.slice(62, 68) : formattedMrz.slice(35, 41);\n  const yobSlice = isPassportType ? formattedMrz.slice(62, 64) : formattedMrz.slice(35, 37);\n  const nationalitySlice = isPassportType ? formattedMrz.slice(59, 62) : formattedMrz.slice(50, 53);\n  const passNoSlice = isPassportType ? formattedMrz.slice(49, 58) : formattedMrz.slice(10, 19);\n\n  const namedob_leaf = getNameDobLeaf(nameSlice, dobSlice);\n  const nameyob_leaf = getNameYobLeaf(nameSlice, yobSlice);\n\n  // Generate Name/DOB and Name/YOB proofs (always needed)\n  nameDobProof = generateSMTProof(nameAndDob_smt, namedob_leaf);\n  nameYobProof = generateSMTProof(nameAndYob_smt, nameyob_leaf);\n\n  // Generate Passport Number proof only if it's a passport type and SMT is provided\n  if (isPassportType) {\n    if (!passportNo_smt) {\n      console.warn('Document type is passport, but passportNo_smt tree was not provided.');\n    } else {\n      const passportNo_leaf = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n      const proofResult = generateSMTProof(passportNo_smt, passportNo_leaf);\n      // Explicitly cast root and closestleaf to bigint\n      passportNoProof = {\n        root: BigInt(proofResult.root),\n        closestleaf: BigInt(proofResult.closestleaf),\n        siblings: proofResult.siblings,\n      };\n    }\n  }\n  // Build Final Input Object\n  const baseInputs = {\n    secret: formatInput(secret),\n    attestation_id: formatInput(attestation_id),\n    dg1: formatInput(formattedMrz),\n    eContent_shaBytes_packed_hash: formatInput(eContent_packed_hash),\n    dsc_tree_leaf: formatInput(dsc_tree_leaf),\n    merkle_root: formatInput(merkletree.root),\n    leaf_depth: formatInput(leaf_depth),\n    path: formatInput(path),\n    siblings: formatInput(siblings),\n    selector_dg1: formatInput(selector_dg1),\n    selector_older_than: formatInput(selector_older_than),\n    scope: formatInput(scope),\n    current_date: formatInput(getCurrentDateYYMMDD()),\n    majority: formatInput(majority_ascii),\n    user_identifier: formatInput(user_identifier),\n    selector_ofac: formatInput(selector_ofac),\n    forbidden_countries_list: formatInput(formatCountriesList(forbidden_countries_list)),\n  };\n\n  const ofacNameInputs = {\n    ofac_namedob_smt_root: formatInput(nameDobProof.root),\n    ofac_namedob_smt_leaf_key: formatInput(nameDobProof.closestleaf),\n    ofac_namedob_smt_siblings: formatInput(nameDobProof.siblings),\n    ofac_nameyob_smt_root: formatInput(nameYobProof.root),\n    ofac_nameyob_smt_leaf_key: formatInput(nameYobProof.closestleaf),\n    ofac_nameyob_smt_siblings: formatInput(nameYobProof.siblings),\n  };\n\n  // Conditionally include passport OFAC inputs\n  const finalInputs = {\n    ...baseInputs,\n    ...ofacNameInputs,\n    ...(isPassportType && {\n      ofac_passportno_smt_root: formatInput(passportNoProof.root),\n      ofac_passportno_smt_leaf_key: formatInput(passportNoProof.closestleaf),\n      ofac_passportno_smt_siblings: formatInput(passportNoProof.siblings),\n    }),\n  };\n\n  return finalInputs;\n}\n"],"mappings":"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","names":["hash","forge","poseidon5","poseidon2","poseidon3","poseidon6","poseidon10","poseidon12","poseidon13","poseidon6","poseidon2","poseidon2","poseidon2","poseidon2","poseidon13","poseidon10","poseidon3","poseidon12","poseidon5","countries"]}