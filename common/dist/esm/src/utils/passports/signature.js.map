{"version":3,"sources":["../../../../../src/utils/passports/passport.ts","../../../../../src/constants/constants.ts","../../../../../src/utils/bytes.ts","../../../../../src/utils/certificate_parsing/parseCertificateSimple.ts","../../../../../src/utils/circuits/generateInputs.ts"],"sourcesContent":["import * as forge from 'node-forge';\nimport { poseidon5 } from 'poseidon-lite';\n\nimport type { hashAlgos } from '../../constants/constants.js';\nimport {\n  k_csca,\n  k_dsc,\n  k_dsc_3072,\n  k_dsc_4096,\n  k_dsc_ecdsa,\n  n_csca,\n  n_dsc,\n  n_dsc_3072,\n  n_dsc_4096,\n  n_dsc_ecdsa,\n} from '../../constants/constants.js';\nimport { bytesToBigDecimal, hexToDecimal, splitToWords } from '../bytes.js';\nimport type {\n  CertificateData,\n  PublicKeyDetailsECDSA,\n  PublicKeyDetailsRSA,\n} from '../certificate_parsing/dataStructure.js';\nimport {\n  getCertificateFromPem,\n  parseCertificateSimple,\n} from '../certificate_parsing/parseCertificateSimple.js';\nimport { formatInput } from '../circuits/generateInputs.js';\nimport { findStartIndex, findStartIndexEC } from '../csca.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { sha384_512Pad, shaPad } from '../shaPad.js';\nimport { getLeafDscTree } from '../trees.js';\nimport type { PassportData, SignatureAlgorithm } from '../types.js';\nimport { formatMrz } from './format.js';\nimport { parsePassportData } from './passport_parsing/parsePassportData.js';\n\nexport function extractRSFromSignature(signatureBytes: number[]): { r: string; s: string } {\n  const derSignature = Buffer.from(signatureBytes).toString('binary');\n  const asn1 = forge.asn1.fromDer(derSignature);\n  const signatureAsn1 = asn1.value;\n\n  if (signatureAsn1.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n\n  if (!Array.isArray(asn1.value) || asn1.value.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n  const r = forge.util.createBuffer(asn1.value[0].value as string).toHex();\n  const s = forge.util.createBuffer(asn1.value[1].value as string).toHex();\n\n  return { r, s };\n}\n\nexport function extractSignatureFromDSC(dscCertificate: string) {\n  const cert = getCertificateFromPem(dscCertificate);\n  const dscSignature = cert.signatureValue.valueBlock.valueHexView;\n  return Array.from(dscSignature);\n}\n\nexport function findStartPubKeyIndex(\n  certificateData: CertificateData,\n  rawCert: any,\n  signatureAlgorithm: string\n): [number, number] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const [x_index, x_totalLength] = findStartIndexEC(x, rawCert);\n    const [y_index, y_totalLength] = findStartIndexEC(y, rawCert);\n\n    return [x_index, x_totalLength + y_totalLength];\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return findStartIndex(modulus, rawCert);\n  }\n}\n\n/// @notice Get the public key from the certificate padded as per the DSC circuit's requirements.\nexport function formatCertificatePubKeyDSC(\n  certificateData: CertificateData,\n  signatureAlgorithm: string\n): string[] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    // const normalizedX = x.length % 2 === 0 ? x : '0' + x;\n    // const normalizedY = y.length % 2 === 0 ? y : '0' + y;\n    const fullPubKey = x + y;\n\n    // Splits to 525 words of 8 bits each\n    return splitToWords(BigInt(hexToDecimal(fullPubKey)), 8, 525);\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), 8, 525);\n  }\n}\n\nexport function formatSignatureDSCCircuit(\n  cscaSignatureAlgorithm: string,\n  cscaHashFunction: string,\n  cscaCertificateData: CertificateData,\n  signature: number[]\n): string[] {\n  const cscaSignatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    cscaCertificateData,\n    cscaSignatureAlgorithm,\n    cscaHashFunction\n  );\n  const { n, k } = getNAndK(cscaSignatureAlgorithmFullName as SignatureAlgorithm);\n  if (cscaSignatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(signature);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return formatInput(splitToWords(BigInt(bytesToBigDecimal(signature)), n, k));\n  }\n}\n\nexport function generateCommitment(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData\n) {\n  const passportMetadata = passportData.passportMetadata;\n\n  const dg1_packed_hash = packBytesAndPoseidon(formatMrz(passportData.mrz));\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(passportData.eContent),\n    'bytes'\n  );\n\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_hash = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n  // Log the values used to generate the commitment\n\n  return poseidon5([\n    secret,\n    attestation_id,\n    dg1_packed_hash,\n    eContent_packed_hash,\n    dsc_hash,\n  ]).toString();\n}\n\nfunction getPassportSignature(passportData: PassportData, n: number, k: number): any {\n  const { signatureAlgorithm } = passportData.dsc_parsed;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(passportData.encryptedDigest);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return splitToWords(BigInt(bytesToBigDecimal(passportData.encryptedDigest)), n, k);\n  }\n}\n\nexport function generateNullifier(passportData: PassportData) {\n  const signedAttr_shaBytes = hash(\n    passportData.passportMetadata.signedAttrHashFunction,\n    Array.from(passportData.signedAttr),\n    'bytes'\n  );\n  const signedAttr_packed_hash = packBytesAndPoseidon(\n    (signedAttr_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n  return signedAttr_packed_hash;\n}\n\n/// @notice Get the public key from the certificate\n/// @dev valid for both DSC and CSCA\nexport function getCertificatePubKey(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashFunction: string\n): any {\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    certificateData,\n    signatureAlgorithm,\n    hashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const x_dsc = splitToWords(BigInt(hexToDecimal(x)), n, k);\n    const y_dsc = splitToWords(BigInt(hexToDecimal(y)), n, k);\n    return [...x_dsc, ...y_dsc];\n  } else {\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), n, k);\n  }\n}\n\nexport function getNAndK(sigAlg: SignatureAlgorithm) {\n  if (sigAlg === 'rsa_sha256_65537_3072') {\n    return { n: n_dsc_3072, k: k_dsc }; // 3072/32 = 96\n  }\n\n  if (sigAlg.startsWith('ecdsa_')) {\n    if (sigAlg.endsWith('224')) {\n      return { n: 32, k: 7 };\n    } else if (sigAlg.endsWith('256')) {\n      return { n: n_dsc_ecdsa, k: 4 };\n    } else if (sigAlg.endsWith('384')) {\n      return { n: n_dsc_ecdsa, k: 6 };\n    } else if (sigAlg.endsWith('512')) {\n      return { n: n_dsc_ecdsa, k: 8 };\n    } else if (sigAlg.endsWith('521')) {\n      return { n: 66, k: 8 };\n    } else {\n      throw new Error('invalid key size');\n    }\n  }\n\n  if (sigAlg.startsWith('rsapss_')) {\n    const keyLength = parseInt(sigAlg.split('_')[3]);\n\n    if (keyLength === 3072) {\n      return { n: n_dsc_3072, k: k_dsc_3072 }; // 3072/32 = 96\n    }\n\n    if (keyLength === 4096) {\n      return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n    }\n    return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n  }\n\n  if (sigAlg === 'rsa_sha256_65537_4096' || sigAlg === 'rsa_sha512_65537_4096') {\n    return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n  }\n\n  return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n}\n\nexport function getNAndKCSCA(sigAlg: 'rsa' | 'ecdsa' | 'rsapss') {\n  const n = sigAlg === 'ecdsa' ? n_dsc_ecdsa : n_csca;\n  const k = sigAlg === 'ecdsa' ? k_dsc_ecdsa : k_csca;\n  return { n, k };\n}\n\n/// @notice Get the signature of the passport and the public key of the DSC\n/// @dev valid for only for the passport/dsc chain\nexport function getPassportSignatureInfos(passportData: PassportData) {\n  const passportMetadata = passportData.passportMetadata;\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    passportData.dsc_parsed,\n    passportMetadata.signatureAlgorithm,\n    passportMetadata.signedAttrHashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n\n  return {\n    pubKey: getCertificatePubKey(\n      passportData.dsc_parsed,\n      passportMetadata.signatureAlgorithm,\n      passportMetadata.signedAttrHashFunction\n    ),\n    signature: getPassportSignature(passportData, n, k),\n    signatureAlgorithmFullName: signatureAlgorithmFullName,\n  };\n}\n\n/// @notice Get the signature algorithm full name\n/// @dev valid for both DSC and CSCA\nexport function getSignatureAlgorithmFullName(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashAlgorithm: string\n): string {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    return `${signatureAlgorithm}_${hashAlgorithm}_${(publicKeyDetails as PublicKeyDetailsECDSA).curve}_${publicKeyDetails.bits}`;\n  } else {\n    const { exponent } = publicKeyDetails as PublicKeyDetailsRSA;\n    return `${signatureAlgorithm}_${hashAlgorithm}_${exponent}_${publicKeyDetails.bits}`;\n  }\n}\n\n/// @dev will bruteforce passport and dsc signature\nexport function initPassportDataParsing(passportData: PassportData, skiPem: any = null) {\n  const passportMetadata = parsePassportData(passportData, skiPem);\n  passportData.passportMetadata = passportMetadata;\n  const dscParsed = parseCertificateSimple(passportData.dsc);\n  passportData.dsc_parsed = dscParsed;\n  if (passportData.passportMetadata.csca) {\n    const cscaParsed = parseCertificateSimple(passportData.passportMetadata.csca);\n    passportData.csca_parsed = cscaParsed;\n  }\n  return passportData;\n}\n\nexport function pad(hashFunction: (typeof hashAlgos)[number]) {\n  return hashFunction === 'sha1' || hashFunction === 'sha224' || hashFunction === 'sha256'\n    ? shaPad\n    : sha384_512Pad;\n}\n\nexport function padWithZeroes(bytes: number[], length: number) {\n  return bytes.concat(new Array(length - bytes.length).fill(0));\n}\n","export type Country3LetterCode = keyof typeof countryCodes;\nexport type document_type = 'passport' | 'id_card';\nexport type hashAlgosTypes = 'sha512' | 'sha384' | 'sha256' | 'sha224' | 'sha1';\nexport const API_URL = 'https://api.self.xyz';\nexport const API_URL_STAGING = 'https://api.staging.self.xyz';\n\nexport const CHAIN_NAME = 'celo';\n\n// possible values because of sha1 constaints: 192,320,384, 448, 576, 640\nexport const CIRCUIT_CONSTANTS = {\n  REGISTER_NULLIFIER_INDEX: 0,\n  REGISTER_COMMITMENT_INDEX: 1,\n  REGISTER_MERKLE_ROOT_INDEX: 2,\n\n  DSC_TREE_LEAF_INDEX: 0,\n  DSC_CSCA_ROOT_INDEX: 1,\n\n  VC_AND_DISCLOSE_REVEALED_DATA_PACKED_INDEX: 0,\n  VC_AND_DISCLOSE_FORBIDDEN_COUNTRIES_LIST_PACKED_INDEX: 3,\n  VC_AND_DISCLOSE_NULLIFIER_INDEX: 7,\n  VC_AND_DISCLOSE_ATTESTATION_ID_INDEX: 8,\n  VC_AND_DISCLOSE_MERKLE_ROOT_INDEX: 9,\n  VC_AND_DISCLOSE_CURRENT_DATE_INDEX: 10,\n  VC_AND_DISCLOSE_PASSPORT_NO_SMT_ROOT_INDEX: 16,\n  VC_AND_DISCLOSE_NAME_DOB_SMT_ROOT_INDEX: 17,\n  VC_AND_DISCLOSE_NAME_YOB_SMT_ROOT_INDEX: 18,\n  VC_AND_DISCLOSE_SCOPE_INDEX: 19,\n  VC_AND_DISCLOSE_USER_IDENTIFIER_INDEX: 20,\n};\n\nexport const CIRCUIT_TYPES = ['dsc', 'register', 'vc_and_disclose'];\n\nexport const COMMITMENT_TREE_DEPTH = 33;\n\nexport const CSCA_TREE_DEPTH = 12;\n\nexport const CSCA_TREE_URL = 'https://tree.self.xyz/csca';\n\nexport const CSCA_TREE_URL_ID_CARD = 'https://tree.self.xyz/csca-id';\n\nexport const CSCA_TREE_URL_STAGING = 'https://tree.staging.self.xyz/csca';\n\nexport const CSCA_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/csca-id';\n\nexport const DEFAULT_MAJORITY = '18';\n\nexport const DEFAULT_RPC_URL = 'https://mainnet.optimism.io';\n\nexport const DEFAULT_USER_ID_TYPE = 'uuid';\n\nexport const DEVELOPMENT_MODE = true;\n\nexport const DSC_TREE_DEPTH = 21;\n\nexport const DSC_TREE_URL = 'https://tree.self.xyz/dsc';\n\nexport const DSC_TREE_URL_ID_CARD = 'https://tree.self.xyz/dsc-id';\n\nexport const DSC_TREE_URL_STAGING = 'https://tree.staging.self.xyz/dsc';\n\nexport const DSC_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/dsc-id';\n\nexport enum DscVerifierId {\n  dsc_sha1_ecdsa_brainpoolP256r1 = 0,\n  dsc_sha1_rsa_65537_4096 = 1,\n  dsc_sha256_ecdsa_brainpoolP256r1 = 2,\n  dsc_sha256_ecdsa_brainpoolP384r1 = 3,\n  dsc_sha256_ecdsa_secp256r1 = 4,\n  dsc_sha256_ecdsa_secp384r1 = 5,\n  dsc_sha256_ecdsa_secp521r1 = 6,\n  dsc_sha256_rsa_65537_4096 = 7,\n  dsc_sha256_rsapss_3_32_3072 = 8,\n  dsc_sha256_rsapss_65537_32_3072 = 9,\n  dsc_sha256_rsapss_65537_32_4096 = 10,\n  dsc_sha384_ecdsa_brainpoolP384r1 = 11,\n  dsc_sha384_ecdsa_brainpoolP512r1 = 12,\n  dsc_sha384_ecdsa_secp384r1 = 13,\n  dsc_sha512_ecdsa_brainpoolP512r1 = 14,\n  dsc_sha512_ecdsa_secp521r1 = 15,\n  dsc_sha512_rsa_65537_4096 = 16,\n  dsc_sha512_rsapss_65537_64_4096 = 17,\n  dsc_sha256_rsapss_3_32_4096 = 18,\n  dsc_sha1_ecdsa_secp256r1 = 19,\n}\n\nexport const ECDSA_K_LENGTH_FACTOR = 2;\n\nexport const IDENTITY_TREE_URL = 'https://tree.self.xyz/identity';\n\n//\"8518753152044246090169372947057357973469996808638122125210848696986717482788\"\nexport const IDENTITY_TREE_URL_ID_CARD = 'https://tree.self.xyz/identity-id';\n\nexport const IDENTITY_TREE_URL_STAGING = 'https://tree.staging.self.xyz/identity';\n\nexport const IDENTITY_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/identity-id';\n\nexport const ID_CARD_ATTESTATION_ID = '2';\n\nexport const MAX_BYTES_IN_FIELD = 31;\n\nexport const MAX_CERT_BYTES: Partial<Record<keyof typeof SignatureAlgorithmIndex, number>> = {\n  rsa_sha256_65537_4096: 512,\n  rsa_sha1_65537_4096: 640,\n  rsapss_sha256_65537_2048: 640,\n  rsapss_sha256_65537_3072: 640,\n  rsapss_sha256_65537_4096: 768,\n  rsapss_sha256_3_3072: 768,\n  rsapss_sha256_3_4096: 768,\n  rsapss_sha384_65537_3072: 768,\n};\n\n/**\n * Maximum number of countries in the forbidden countries list.\n *\n * IMPORTANT: This value must match in both backend and frontend SDK.\n * Any mismatch will result in an INVALID_FORBIDDEN_COUNTRIES error.\n */\nexport const MAX_DATAHASHES_LEN = 320;\n\nexport const MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n\nexport const MAX_PADDED_ECONTENT_LEN: Partial<Record<(typeof hashAlgos)[number], number>> = {\n  sha1: 384,\n  sha224: 512,\n  sha256: 512,\n  sha384: 768,\n  sha512: 896,\n};\n\nexport const MAX_PADDED_SIGNED_ATTR_LEN: Record<(typeof hashAlgos)[number], number> = {\n  sha1: 128,\n  sha224: 128,\n  sha256: 128,\n  sha384: 256,\n  sha512: 256,\n};\n\n// Note: Circuit lists are now managed through RegisterVerifierId and DscVerifierId enums below\n// instead of separate arrays for better type safety and maintainability\nexport const MAX_PUBKEY_DSC_BYTES = 525;\n\nexport const OFAC_TREE_LEVELS = 64;\n\n// we make it global here because passing it to generateCircuitInputsRegister caused trouble\nexport const PASSPORT_ATTESTATION_ID = '1';\n\nexport const PCR0_MANAGER_ADDRESS = '0xE36d4EE5Fd3916e703A46C21Bb3837dB7680C8B8';\n\nexport const REDIRECT_URL = 'https://redirect.self.xyz';\n\nexport const REGISTER_CONTRACT_ADDRESS = '0x3F346FFdC5d583e4126AF01A02Ac5b9CdB3f1909';\n\nexport const RPC_URL = 'https://forno.celo.org';\n\nexport enum RegisterVerifierId {\n  register_sha256_sha256_sha256_rsa_65537_4096 = 0,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 1,\n  register_sha256_sha256_sha256_ecdsa_secp256r1 = 2,\n  register_sha256_sha256_sha256_ecdsa_secp384r1 = 3,\n  register_sha256_sha256_sha256_rsa_3_4096 = 4,\n  register_sha256_sha256_sha256_rsapss_3_32_2048 = 5,\n  register_sha256_sha256_sha256_rsapss_65537_32_2048 = 6,\n  register_sha256_sha256_sha256_rsapss_65537_32_3072 = 7,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 8,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 9,\n  register_sha384_sha384_sha384_ecdsa_secp384r1 = 10,\n  register_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 11,\n  register_sha512_sha512_sha512_rsa_65537_4096 = 12,\n  register_sha512_sha512_sha512_rsapss_65537_64_2048 = 13,\n  register_sha1_sha1_sha1_rsa_65537_4096 = 14,\n  register_sha1_sha256_sha256_rsa_65537_4096 = 15,\n  register_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 16,\n  register_sha256_sha224_sha224_ecdsa_secp224r1 = 17,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 18,\n  register_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 19,\n  register_sha384_sha384_sha384_rsapss_65537_48_2048 = 20,\n  register_sha1_sha1_sha1_ecdsa_secp256r1 = 21,\n  register_sha256_sha256_sha256_rsapss_65537_64_2048 = 22,\n  register_sha512_sha512_sha256_rsa_65537_4096 = 23,\n  register_sha512_sha512_sha512_ecdsa_secp521r1 = 24,\n  register_id_sha256_sha256_sha256_rsa_65537_4096 = 25,\n  register_sha256_sha256_sha224_ecdsa_secp224r1 = 26,\n  register_id_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 27,\n  register_id_sha1_sha1_sha1_ecdsa_secp256r1 = 28,\n  register_id_sha1_sha1_sha1_rsa_65537_4096 = 29,\n  register_id_sha1_sha256_sha256_rsa_65537_4096 = 30,\n  register_id_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 31,\n  register_id_sha256_sha224_sha224_ecdsa_secp224r1 = 32,\n  register_id_sha256_sha256_sha224_ecdsa_secp224r1 = 33,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 34,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 35,\n  register_id_sha256_sha256_sha256_ecdsa_secp256r1 = 36,\n  register_id_sha256_sha256_sha256_ecdsa_secp384r1 = 37,\n  register_id_sha256_sha256_sha256_rsa_3_4096 = 38,\n  register_id_sha256_sha256_sha256_rsapss_3_32_2048 = 39,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_2048 = 40,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_3072 = 41,\n  register_id_sha256_sha256_sha256_rsapss_65537_64_2048 = 42,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 43,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 44,\n  register_id_sha384_sha384_sha384_ecdsa_secp384r1 = 45,\n  register_id_sha384_sha384_sha384_rsapss_65537_48_2048 = 46,\n  register_id_sha512_sha512_sha256_rsa_65537_4096 = 47,\n  register_id_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 48,\n  register_id_sha512_sha512_sha512_ecdsa_secp521r1 = 49,\n  register_id_sha512_sha512_sha512_rsa_65537_4096 = 50,\n  register_id_sha512_sha512_sha512_rsapss_65537_64_2048 = 51,\n}\n\nexport const SBT_CONTRACT_ADDRESS = '0x601Fd54FD11C5E77DE84d877e55B829aff20f0A6';\n\nexport enum SignatureAlgorithmIndex {\n  rsa_sha256_65537_2048 = 1,\n  rsa_sha1_65537_2048 = 3,\n  rsapss_sha256_65537_2048 = 4,\n  ecdsa_sha1_secp256r1_256 = 7,\n  ecdsa_sha256_secp256r1_256 = 8,\n  ecdsa_sha384_secp384r1_384 = 9,\n  rsa_sha256_65537_4096 = 10,\n  rsa_sha1_65537_4096 = 11,\n  rsapss_sha256_65537_4096 = 12,\n  rsa_sha256_3_2048 = 13,\n  rsa_sha256_65537_3072 = 14,\n  rsa_sha512_65537_4096 = 15,\n  rsapss_sha256_3_3072 = 16,\n  rsapss_sha256_3_4096 = 17,\n  rsapss_sha384_65537_3072 = 18,\n  rsapss_sha256_65537_3072 = 19,\n  ecdsa_sha256_brainpoolP256r1_256 = 21,\n  ecdsa_sha384_brainpoolP384r1_384 = 22,\n  ecdsa_sha256_secp384r1_384 = 23,\n  ecdsa_sha384_brainpoolP256r1_256 = 24,\n  ecdsa_sha512_brainpoolP256r1_256 = 25,\n  ecdsa_sha512_brainpoolP384r1_384 = 26,\n  ecdsa_sha1_brainpoolP224r1_224 = 27,\n  ecdsa_sha256_brainpoolP224r1_224 = 28,\n  ecdsa_sha512_brainpoolP512r1_512 = 29,\n  ecdsa_sha224_brainpoolP224r1_224 = 30,\n  rsa_sha256_3_4096 = 32,\n  rsa_sha1_3_4096 = 33,\n  rsa_sha384_65537_4096 = 34,\n  rsapss_sha384_65537_4096 = 35,\n  ecdsa_sha1_brainpoolP256r1_256 = 36,\n  ecdsa_sha512_secp521r1_521 = 41,\n}\n\nexport const TREE_TRACKER_URL = 'https://tree.self.xyz';\n\nexport const TREE_URL = 'https://tree.self.xyz';\nexport const TREE_URL_STAGING = 'https://tree.staging.self.xyz';\n\nexport const WS_DB_RELAYER = 'wss://websocket.self.xyz';\n\nexport const WS_DB_RELAYER_STAGING = 'wss://websocket.staging.self.xyz';\n\nexport const WS_RPC_URL_VC_AND_DISCLOSE = 'ws://disclose.proving.self.xyz:8888/';\n\nexport const attributeToPosition = {\n  issuing_state: [2, 4],\n  name: [5, 43],\n  passport_number: [44, 52],\n  nationality: [54, 56],\n  date_of_birth: [57, 62],\n  gender: [64, 64],\n  expiry_date: [65, 70],\n  older_than: [88, 89],\n  ofac: [90, 90],\n};\nexport const attributeToPosition_ID = {\n  issuing_state: [2, 4],\n  name: [60, 89],\n  passport_number: [5, 13],\n  nationality: [45, 47],\n  date_of_birth: [30, 35],\n  gender: [37, 37],\n  expiry_date: [38, 43],\n  older_than: [90, 91],\n  ofac: [92, 92],\n};\n\nexport const circuitNameFromMode = {\n  prove: 'prove',\n  prove_onchain: 'prove',\n  prove_offchain: 'prove',\n  register: 'prove',\n  vc_and_disclose: 'vc_and_disclose',\n  dsc: 'dsc',\n};\nexport const circuitToSelectorMode = {\n  register: [0, 0],\n  prove_onchain: [1, 0],\n  prove_offchain: [1, 1],\n};\n\nexport const contribute_publicKey = `-----BEGIN RSA PUBLIC KEY-----\nMIICCgKCAgEAv/hm7FZZ2KBmaeDHmLoRwuWmCcNKT561RqbsW8ZuYSyPWJUldE9U\nCf0lW3K1H5lsSDkl0Cq84cooL9f6X59Mffb/N24ZKTdL0xdcPwjk4LbcrVm8qubL\n0a/4uCNoZZ1my4nxbpLxYtbr8CNmUGvBOVKf8IcjsY6VghIZrO63G6BN/G44su1Z\nWcHpboGt9SDQK4enCyKxnCD+PbDYlewSA0n3GRajFfZex1bj1EvrS2hTLv8oNH5e\n9H+3TUke0uO6Ttl0bZepoMmPlpAXhJByISqC6SLth4WFIH+G1I/xt9AEM7hOfLMl\nKQv/3wlLEgEueRryKAHB2tqkaDKVJyw+tOyWj2iWA+nVgQKAxO4hOw01ljyVbcx6\nKboXwnamlZPFIx4tjEaZ+ClXCFqvXhE9LDFK11QsYzJZl0aRVfTNqcurhEt7SK0f\nqzOBhID0Nxk4k9sW1uT6ocW1xp1SB2WotORssOKIAOLJM8IbPl6n/DkYNcfvyXI7\n4BlUrf6M2DgZMYATabIy94AvopHJOyiRfh4NpQPDntWnShiI1em2MmtXiWFCdVFV\n6/QfJTKVixJpVfDh386ALXc97EPWDMWIalUwYoV/eRSMnuV8nZ0+Ctp3Qrtk/JYd\n+FWhKbtlPeRjmGVr6mVlvDJ7KqtY5/RqqwfWeXhXezGhQqQ/OoQQCRkCAwEAAQ==\n-----END RSA PUBLIC KEY-----`;\n\n// not using a library for this as the entry countries use can be differnt than the ISO 3166-1 alpha-3 standard\nexport const countryCodes = {\n  AFG: 'Afghanistan',\n  ALA: 'Aland Islands',\n  ALB: 'Albania',\n  DZA: 'Algeria',\n  ASM: 'American Samoa',\n  AND: 'Andorra',\n  AGO: 'Angola',\n  AIA: 'Anguilla',\n  ATA: 'Antarctica',\n  ATG: 'Antigua and Barbuda',\n  ARG: 'Argentina',\n  ARM: 'Armenia',\n  ABW: 'Aruba',\n  AUS: 'Australia',\n  AUT: 'Austria',\n  AZE: 'Azerbaijan',\n  BHS: 'Bahamas',\n  BHR: 'Bahrain',\n  BGD: 'Bangladesh',\n  BRB: 'Barbados',\n  BLR: 'Belarus',\n  BEL: 'Belgium',\n  BLZ: 'Belize',\n  BEN: 'Benin',\n  BMU: 'Bermuda',\n  BTN: 'Bhutan',\n  BOL: 'Bolivia (Plurinational State of)',\n  BES: 'Bonaire, Sint Eustatius and Saba',\n  BIH: 'Bosnia and Herzegovina',\n  BWA: 'Botswana',\n  BVT: 'Bouvet Island',\n  BRA: 'Brazil',\n  IOT: 'British Indian Ocean Territory',\n  BRN: 'Brunei Darussalam',\n  BGR: 'Bulgaria',\n  BFA: 'Burkina Faso',\n  BDI: 'Burundi',\n  CPV: 'Cabo Verde',\n  KHM: 'Cambodia',\n  CMR: 'Cameroon',\n  CAN: 'Canada',\n  CYM: 'Cayman Islands',\n  CAF: 'Central African Republic',\n  TCD: 'Chad',\n  CHL: 'Chile',\n  CHN: 'China',\n  CXR: 'Christmas Island',\n  CCK: 'Cocos (Keeling) Islands',\n  COL: 'Colombia',\n  COM: 'Comoros',\n  COG: 'Congo',\n  COD: 'Congo, Democratic Republic of the',\n  COK: 'Cook Islands',\n  CRI: 'Costa Rica',\n  CIV: \"Cote d'Ivoire\",\n  HRV: 'Croatia',\n  CUB: 'Cuba',\n  CUW: 'Curacao',\n  CYP: 'Cyprus',\n  CZE: 'Czechia',\n  DNK: 'Denmark',\n  DJI: 'Djibouti',\n  DMA: 'Dominica',\n  DOM: 'Dominican Republic',\n  ECU: 'Ecuador',\n  EGY: 'Egypt',\n  SLV: 'El Salvador',\n  GNQ: 'Equatorial Guinea',\n  ERI: 'Eritrea',\n  EST: 'Estonia',\n  SWZ: 'Eswatini',\n  ETH: 'Ethiopia',\n  FLK: 'Falkland Islands (Malvinas)',\n  FRO: 'Faroe Islands',\n  FJI: 'Fiji',\n  FIN: 'Finland',\n  FRA: 'France',\n  GUF: 'French Guiana',\n  PYF: 'French Polynesia',\n  ATF: 'French Southern Territories',\n  GAB: 'Gabon',\n  GMB: 'Gambia',\n  GEO: 'Georgia',\n  DEU: 'Germany',\n  'D<<': 'Germany', // Bundesrepublik Deutschland uses this in passports instead of DEU\n  GHA: 'Ghana',\n  GIB: 'Gibraltar',\n  GRC: 'Greece',\n  GRL: 'Greenland',\n  GRD: 'Grenada',\n  GLP: 'Guadeloupe',\n  GUM: 'Guam',\n  GTM: 'Guatemala',\n  GGY: 'Guernsey',\n  GIN: 'Guinea',\n  GNB: 'Guinea-Bissau',\n  GUY: 'Guyana',\n  HTI: 'Haiti',\n  HMD: 'Heard Island and McDonald Islands',\n  VAT: 'Holy See',\n  HND: 'Honduras',\n  HKG: 'Hong Kong',\n  HUN: 'Hungary',\n  ISL: 'Iceland',\n  IND: 'India',\n  IDN: 'Indonesia',\n  IRN: 'Iran (Islamic Republic of)',\n  IRQ: 'Iraq',\n  IRL: 'Ireland',\n  IMN: 'Isle of Man',\n  ISR: 'Israel',\n  ITA: 'Italy',\n  JAM: 'Jamaica',\n  JPN: 'Japan',\n  JEY: 'Jersey',\n  JOR: 'Jordan',\n  KAZ: 'Kazakhstan',\n  KEN: 'Kenya',\n  KIR: 'Kiribati',\n  PRK: \"Korea (Democratic People's Republic of)\",\n  KOR: 'Korea, Republic of',\n  KWT: 'Kuwait',\n  KGZ: 'Kyrgyzstan',\n  LAO: \"Lao People's Democratic Republic\",\n  LVA: 'Latvia',\n  LBN: 'Lebanon',\n  LSO: 'Lesotho',\n  LBR: 'Liberia',\n  LBY: 'Libya',\n  LIE: 'Liechtenstein',\n  LTU: 'Lithuania',\n  LUX: 'Luxembourg',\n  MAC: 'Macao',\n  MDG: 'Madagascar',\n  MWI: 'Malawi',\n  MYS: 'Malaysia',\n  MDV: 'Maldives',\n  MLI: 'Mali',\n  MLT: 'Malta',\n  MHL: 'Marshall Islands',\n  MTQ: 'Martinique',\n  MRT: 'Mauritania',\n  MUS: 'Mauritius',\n  MYT: 'Mayotte',\n  MEX: 'Mexico',\n  FSM: 'Micronesia (Federated States of)',\n  MDA: 'Moldova, Republic of',\n  MCO: 'Monaco',\n  MNG: 'Mongolia',\n  MNE: 'Montenegro',\n  MSR: 'Montserrat',\n  MAR: 'Morocco',\n  MOZ: 'Mozambique',\n  MMR: 'Myanmar',\n  NAM: 'Namibia',\n  NRU: 'Nauru',\n  NPL: 'Nepal',\n  NLD: 'Netherlands',\n  NCL: 'New Caledonia',\n  NZL: 'New Zealand',\n  NIC: 'Nicaragua',\n  NER: 'Niger',\n  NGA: 'Nigeria',\n  NIU: 'Niue',\n  NFK: 'Norfolk Island',\n  MKD: 'North Macedonia',\n  MNP: 'Northern Mariana Islands',\n  NOR: 'Norway',\n  OMN: 'Oman',\n  PAK: 'Pakistan',\n  PLW: 'Palau',\n  PSE: 'Palestine, State of',\n  PAN: 'Panama',\n  PNG: 'Papua New Guinea',\n  PRY: 'Paraguay',\n  PER: 'Peru',\n  PHL: 'Philippines',\n  PCN: 'Pitcairn',\n  POL: 'Poland',\n  PRT: 'Portugal',\n  PRI: 'Puerto Rico',\n  QAT: 'Qatar',\n  REU: 'Reunion',\n  ROU: 'Romania',\n  RUS: 'Russian Federation',\n  RWA: 'Rwanda',\n  BLM: 'Saint Barthelemy',\n  SHN: 'Saint Helena, Ascension and Tristan da Cunha',\n  KNA: 'Saint Kitts and Nevis',\n  LCA: 'Saint Lucia',\n  MAF: 'Saint Martin (French part)',\n  SPM: 'Saint Pierre and Miquelon',\n  VCT: 'Saint Vincent and the Grenadines',\n  WSM: 'Samoa',\n  SMR: 'San Marino',\n  STP: 'Sao Tome and Principe',\n  SAU: 'Saudi Arabia',\n  SEN: 'Senegal',\n  SRB: 'Serbia',\n  SYC: 'Seychelles',\n  SLE: 'Sierra Leone',\n  SGP: 'Singapore',\n  SXM: 'Sint Maarten (Dutch part)',\n  SVK: 'Slovakia',\n  SVN: 'Slovenia',\n  SLB: 'Solomon Islands',\n  SOM: 'Somalia',\n  ZAF: 'South Africa',\n  SGS: 'South Georgia and the South Sandwich Islands',\n  SSD: 'South Sudan',\n  ESP: 'Spain',\n  LKA: 'Sri Lanka',\n  SDN: 'Sudan',\n  SUR: 'Suriname',\n  SJM: 'Svalbard and Jan Mayen',\n  SWE: 'Sweden',\n  CHE: 'Switzerland',\n  SYR: 'Syrian Arab Republic',\n  TWN: 'Taiwan, Province of China',\n  TJK: 'Tajikistan',\n  TZA: 'Tanzania, United Republic of',\n  THA: 'Thailand',\n  TLS: 'Timor-Leste',\n  TGO: 'Togo',\n  TKL: 'Tokelau',\n  TON: 'Tonga',\n  TTO: 'Trinidad and Tobago',\n  TUN: 'Tunisia',\n  TUR: 'Turkey',\n  TKM: 'Turkmenistan',\n  TCA: 'Turks and Caicos Islands',\n  TUV: 'Tuvalu',\n  UGA: 'Uganda',\n  UKR: 'Ukraine',\n  ARE: 'United Arab Emirates',\n  GBR: 'United Kingdom of Great Britain and Northern Ireland',\n  USA: 'United States of America',\n  UMI: 'United States Minor Outlying Islands',\n  URY: 'Uruguay',\n  UZB: 'Uzbekistan',\n  VUT: 'Vanuatu',\n  VEN: 'Venezuela (Bolivarian Republic of)',\n  VNM: 'Viet Nam',\n  VGB: 'Virgin Islands (British)',\n  VIR: 'Virgin Islands (U.S.)',\n  WLF: 'Wallis and Futuna',\n  ESH: 'Western Sahara',\n  YEM: 'Yemen',\n  ZMB: 'Zambia',\n  ZWE: 'Zimbabwe',\n};\n\nexport function getCountryCode(countryName: string): string {\n  const entries = Object.entries(countryCodes);\n  const found = entries.find(([_, name]) => name.toLowerCase() === countryName.toLowerCase());\n  return found ? found[0] : 'undefined';\n}\n\nexport const hashAlgos = ['sha512', 'sha384', 'sha256', 'sha224', 'sha1'];\n\nexport const k_csca = 35;\n\nexport const k_dsc = 35;\n\n//48;\nexport const k_dsc_3072 = 35;\n\nexport const k_dsc_4096 = 35;\n\nexport const k_dsc_ecdsa = 4;\n\nexport const max_csca_bytes = 1792;\n\nexport const max_dsc_bytes = 1792;\n\nexport const n_csca = 120;\n\nexport const n_dsc = 120;\n\nexport const n_dsc_3072 = 120;\n\nexport const n_dsc_4096 = 120;\n\nexport const n_dsc_ecdsa = 64;\n\n// max formatted and concatenated datagroup hashes length in bytes\nexport const revealedDataTypes = {\n  issuing_state: 0,\n  name: 1,\n  passport_number: 2,\n  nationality: 3,\n  date_of_birth: 4,\n  gender: 5,\n  expiry_date: 6,\n  older_than: 7,\n  passport_no_ofac: 8,\n  name_and_dob_ofac: 9,\n  name_and_yob_ofac: 10,\n};\n\nexport const saltLengths = [64, 48, 32];\n","import { MAX_BYTES_IN_FIELD } from '../constants/constants.js';\n\nexport function bigIntToChunkedBytes(\n  num: BigInt | bigint,\n  bytesPerChunk: number,\n  numChunks: number\n) {\n  const res: string[] = [];\n  const bigintNum: bigint = typeof num == 'bigint' ? num : num.valueOf();\n  const msk = (1n << BigInt(bytesPerChunk)) - 1n;\n  for (let i = 0; i < numChunks; ++i) {\n    res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());\n  }\n  return res;\n}\nexport function bytesToBigDecimal(arr: number[]): string {\n  let result = BigInt(0);\n  for (let i = 0; i < arr.length; i++) {\n    result = result * BigInt(256) + BigInt(arr[i] & 0xff);\n  }\n  return result.toString();\n}\n\nexport function computeIntChunkLength(byteLength: number) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const remain = byteLength % packSize;\n  let numChunks = (byteLength - remain) / packSize;\n  if (remain > 0) {\n    numChunks += 1;\n  }\n  return numChunks;\n}\n\nexport function derToBytes(derValue: string) {\n  const bytes = [];\n  for (let i = 0; i < derValue.length; i++) {\n    bytes.push(derValue.charCodeAt(i));\n  }\n  return bytes;\n}\n\nexport function hexStringToSignedIntArray(hexString: string) {\n  const result = [];\n  for (let i = 0; i < hexString.length; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    result.push(byte > 127 ? byte - 256 : byte);\n  }\n  return result;\n}\n\nexport function hexToBin(n: string): string {\n  let bin = Number(`0x${n[0]}`).toString(2);\n  for (let i = 1; i < n.length; i += 1) {\n    bin += Number(`0x${n[i]}`).toString(2).padStart(4, '0');\n  }\n  return bin;\n}\n\nexport function hexToDecimal(hex: string): string {\n  return BigInt(`0x${hex}`).toString();\n}\n\nexport function hexToSignedBytes(hexString: string): number[] {\n  const bytes = [];\n  for (let i = 0; i < hexString.length - 1; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    bytes.push(byte >= 128 ? byte - 256 : byte);\n  }\n  return bytes;\n}\n\nexport function num2Bits(n: number, inValue: bigint): bigint[] {\n  const out: bigint[] = new Array(n).fill(BigInt(0));\n  let lc1: bigint = BigInt(0);\n  let e2: bigint = BigInt(1);\n\n  for (let i = 0; i < n; i++) {\n    out[i] = (inValue >> BigInt(i)) & BigInt(1);\n\n    if (out[i] !== BigInt(0) && out[i] !== BigInt(1)) {\n      throw new Error('Bit value is not binary.');\n    }\n\n    lc1 += out[i] * e2;\n    e2 = e2 << BigInt(1);\n  }\n\n  if (lc1 !== inValue) {\n    throw new Error('Reconstructed value does not match the input.');\n  }\n  return out;\n}\n\nexport function packBytes(unpacked) {\n  const bytesCount = [31, 31, 31];\n  const packed = [0n, 0n, 0n];\n\n  let byteIndex = 0;\n  for (let i = 0; i < bytesCount.length; i++) {\n    for (let j = 0; j < bytesCount[i]; j++) {\n      if (byteIndex < unpacked.length) {\n        packed[i] |= BigInt(unpacked[byteIndex]) << (BigInt(j) * 8n);\n      }\n      byteIndex++;\n    }\n  }\n  return packed;\n}\n\nexport function packBytesArray(unpacked: number[]) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const maxBytes = unpacked.length;\n  const maxInts = computeIntChunkLength(maxBytes);\n  const out: bigint[] = new Array(maxInts).fill(0n);\n\n  for (let i = 0; i < maxInts; i++) {\n    let sum = 0n;\n    for (let j = 0; j < packSize; j++) {\n      const idx = packSize * i + j;\n\n      // Copy previous value if out of bounds\n      if (idx >= maxBytes) {\n        continue;\n      }\n      // First item of chunk is byte itself\n      else if (j === 0) {\n        sum = BigInt(unpacked[idx]);\n      }\n      // Every other item is 256^j * byte\n      else {\n        sum += (1n << BigInt(8 * j)) * BigInt(unpacked[idx]);\n      }\n    }\n    out[i] = sum;\n  }\n\n  return out;\n}\n\nexport function splitToWords(number: bigint, wordsize: number, numberElement: number) {\n  let t = number;\n  const words: string[] = [];\n  for (let i = 0; i < numberElement; ++i) {\n    const baseTwo = BigInt(2);\n\n    words.push(`${t % BigInt(Math.pow(Number(baseTwo), wordsize))}`);\n    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), wordsize)));\n  }\n  if (!(t == BigInt(0))) {\n    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;\n  }\n  return words;\n}\n\nexport const toBinaryString = (byte: any) => {\n  const binary = (parseInt(byte, 10) & 0xff).toString(2).padStart(8, '0');\n  return binary;\n};\n\nexport function toSigned(byte: number) {\n  return byte > 127 ? byte - 256 : byte;\n}\nexport function toUnsigned(byte: number) {\n  return byte & 0xff;\n}\nexport function toUnsignedByte(signedByte: number) {\n  return signedByte < 0 ? signedByte + 256 : signedByte;\n}\n","import * as asn1js from 'asn1js';\nimport { Certificate, RSAPublicKey, RSASSAPSSParams } from 'pkijs';\n\nimport { circuitNameFromMode } from '../../constants/constants.js';\nimport type { Mode } from '../appType.js';\nimport type { StandardCurve } from './curves.js';\nimport { getCurveForElliptic, getECDSACurveBits, identifyCurve } from './curves.js';\nimport type {\n  CertificateData,\n  PublicKeyDetailsECDSA,\n  PublicKeyDetailsRSA,\n  PublicKeyDetailsRSAPSS,\n} from './dataStructure.js';\nimport { initElliptic } from './elliptic.js';\nimport { getFriendlyName, getSecpFromNist } from './oids.js';\nimport { getIssuerCountryCode, getSubjectKeyIdentifier } from './utils.js';\n\nexport const getAuthorityKeyIdentifier = (cert: Certificate): string => {\n  const authorityKeyIdentifier = cert.extensions.find((ext) => ext.extnID === '2.5.29.35');\n  if (authorityKeyIdentifier) {\n    let akiValue = Buffer.from(authorityKeyIdentifier.extnValue.valueBlock.valueHexView).toString(\n      'hex'\n    );\n\n    // Match the ASN.1 sequence header pattern: 30 followed by length\n    const sequenceMatch = akiValue.match(/^30([0-9a-f]{2}|8[0-9a-f][0-9a-f])/i);\n    if (sequenceMatch) {\n      // console.log('Sequence length indicator:', sequenceMatch[1]);\n    }\n\n    // Match the keyIdentifier pattern: 80 followed by length (usually 14)\n    const keyIdMatch = akiValue.match(/80([0-9a-f]{2})/i);\n    if (keyIdMatch) {\n      const keyIdLength = parseInt(keyIdMatch[1], 16);\n      // Extract the actual key ID (length * 2 because hex)\n      const startIndex = akiValue.indexOf(keyIdMatch[0]) + 4;\n      akiValue = akiValue.slice(startIndex, startIndex + keyIdLength * 2);\n      return akiValue.toUpperCase();\n    }\n  }\n  return null;\n};\n\nfunction getParamsRSA(cert: Certificate): PublicKeyDetailsRSA {\n  const publicKeyValue = cert.subjectPublicKeyInfo.parsedKey as RSAPublicKey;\n  const modulusBytes = publicKeyValue.modulus.valueBlock.valueHexView;\n  const modulusHex = Buffer.from(modulusBytes).toString('hex');\n  const exponentBigInt = publicKeyValue.publicExponent.toBigInt();\n  const exponentDecimal = exponentBigInt.toString();\n  const actualBits = modulusBytes.length * 8;\n\n  return {\n    modulus: modulusHex,\n    exponent: exponentDecimal,\n    bits: actualBits.toString(),\n  };\n}\n\nfunction getParamsRSAPSS(cert: Certificate): PublicKeyDetailsRSAPSS {\n  // Get the subjectPublicKey BitString\n  const spki = cert.subjectPublicKeyInfo;\n  const spkiValueHex = spki.subjectPublicKey.valueBlock.valueHexView;\n\n  // Parse the public key ASN.1 structure\n  const asn1PublicKey = asn1js.fromBER(spkiValueHex);\n  if (asn1PublicKey.offset === -1) {\n    throw new Error('Error parsing public key ASN.1 structure');\n  }\n\n  // The public key is an RSAPublicKey structure\n  const rsaPublicKey = new RSAPublicKey({ schema: asn1PublicKey.result });\n  const modulusBytes = rsaPublicKey.modulus.valueBlock.valueHexView;\n  const modulusHex = Buffer.from(modulusBytes).toString('hex');\n  const exponentBigInt = rsaPublicKey.publicExponent.toBigInt();\n  const exponentDecimal = exponentBigInt.toString();\n  const actualBits = modulusBytes.length * 8;\n\n  const sigAlgParams = cert.signatureAlgorithm.algorithmParams;\n  const pssParams = new RSASSAPSSParams({ schema: sigAlgParams });\n  const hashAlgorithm = getFriendlyName(pssParams.hashAlgorithm.algorithmId);\n  const mgf = getFriendlyName(pssParams.maskGenAlgorithm.algorithmId);\n\n  return {\n    modulus: modulusHex,\n    exponent: exponentDecimal,\n    bits: actualBits.toString(),\n    hashAlgorithm: hashAlgorithm,\n    mgf: mgf,\n    saltLength: pssParams.saltLength.toString(),\n  };\n}\n\nexport function getCertificateFromPem(pemContent: string): Certificate {\n  const pemFormatted = pemContent.replace(/(-----(BEGIN|END) CERTIFICATE-----|\\n|\\r)/g, '');\n  const binary = Buffer.from(pemFormatted, 'base64');\n  const arrayBuffer = new ArrayBuffer(binary.length);\n  const view = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < binary.length; i++) {\n    view[i] = binary[i];\n  }\n\n  const asn1 = asn1js.fromBER(arrayBuffer);\n  if (asn1.offset === -1) {\n    throw new Error(`ASN.1 parsing error: ${asn1.result.error}`);\n  }\n\n  return new Certificate({ schema: asn1.result });\n}\n\nexport const getCircuitName = (\n  circuitMode: 'prove' | 'dsc' | 'vc_and_disclose',\n  signatureAlgorithm: string,\n  hashFunction: string,\n  domainParameter: string,\n  keyLength: string\n) => {\n  const circuit = circuitNameFromMode[circuitMode];\n  if (circuit == 'vc_and_disclose') {\n    return 'vc_and_disclose';\n  }\n  if (circuit == 'dsc') {\n    return (\n      circuit +\n      '_' +\n      signatureAlgorithm +\n      '_' +\n      hashFunction +\n      '_' +\n      domainParameter +\n      '_' +\n      keyLength\n    );\n  }\n  return (\n    circuit +\n    '_' +\n    signatureAlgorithm +\n    '_' +\n    hashFunction +\n    '_' +\n    domainParameter +\n    '_' +\n    keyLength\n  );\n};\n\nexport const getCircuitNameOld = (\n  circuitMode: Mode,\n  signatureAlgorithm: string,\n  hashFunction: string\n) => {\n  const circuit = circuitNameFromMode[circuitMode];\n  if (circuit == 'vc_and_disclose') {\n    return 'vc_and_disclose';\n  } else if (signatureAlgorithm === 'ecdsa') {\n    return circuit + '_' + signatureAlgorithm + '_secp256r1_' + hashFunction;\n  } else {\n    return circuit + '_' + signatureAlgorithm + '_65537_' + hashFunction;\n  }\n};\nexport function getHashAlgorithm(rawSignatureAlgorithm: string) {\n  const input = rawSignatureAlgorithm.toLowerCase();\n  const patterns = [/sha-?1/i, /sha-?224/i, /sha-?256/i, /sha-?384/i, /sha-?512/i];\n\n  for (const pattern of patterns) {\n    const match = input.match(pattern);\n    if (match) {\n      // Remove any hyphens and return standardized format\n      return match[0].replace('-', '');\n    }\n  }\n\n  return 'unknown';\n}\n\nexport function getParamsECDSA(cert: Certificate): PublicKeyDetailsECDSA {\n  try {\n    const algorithmParams = cert.subjectPublicKeyInfo.algorithm.algorithmParams;\n\n    if (!algorithmParams) {\n      console.error('No algorithm params found');\n      return {\n        curve: 'Unknown',\n        params: {} as StandardCurve,\n        bits: 'Unknown',\n        x: 'Unknown',\n        y: 'Unknown',\n      };\n    }\n\n    let curveName,\n      bits,\n      x,\n      y = 'Unknown';\n    const curveParams: StandardCurve = {} as StandardCurve;\n\n    // Try to get the curve name from the OID\n    if (algorithmParams instanceof asn1js.ObjectIdentifier) {\n      const curveOid = algorithmParams.valueBlock.toString();\n      curveName = getSecpFromNist(getFriendlyName(curveOid)) || 'Unknown';\n      bits = getECDSACurveBits(curveName);\n    }\n\n    // If the OID of the curve is not present, we try to get the curve parameters and identify the curve from them\n    else {\n      const params = asn1js.fromBER(algorithmParams.valueBeforeDecodeView).result;\n      const valueBlock: any = params.valueBlock;\n      if (valueBlock.value && valueBlock.value.length >= 5) {\n        const curveParams: StandardCurve = {} as StandardCurve;\n        // Field ID (index 1)\n        const fieldId = valueBlock.value[1];\n        if (fieldId && fieldId.valueBlock && fieldId.valueBlock.value) {\n          const fieldType = fieldId.valueBlock.value[0];\n          const prime = fieldId.valueBlock.value[1];\n          //curveParams.fieldType = fieldType.valueBlock.toString();\n          curveParams.p = Buffer.from(prime.valueBlock.valueHexView).toString('hex');\n        }\n\n        // Curve Coefficients (index 2)\n        const curveCoefficients = valueBlock.value[2];\n        if (\n          curveCoefficients &&\n          curveCoefficients.valueBlock &&\n          curveCoefficients.valueBlock.value\n        ) {\n          const a = curveCoefficients.valueBlock.value[0];\n          const b = curveCoefficients.valueBlock.value[1];\n          curveParams.a = Buffer.from(a.valueBlock.valueHexView).toString('hex');\n          curveParams.b = Buffer.from(b.valueBlock.valueHexView).toString('hex');\n        }\n\n        // Base Point G (index 3)\n        const basePoint = valueBlock.value[3];\n        if (basePoint && basePoint.valueBlock) {\n          curveParams.G = Buffer.from(basePoint.valueBlock.valueHexView).toString('hex');\n        }\n\n        // Order n (index 4)\n        const order = valueBlock.value[4];\n        if (order && order.valueBlock) {\n          curveParams.n = Buffer.from(order.valueBlock.valueHexView).toString('hex');\n        }\n\n        if (valueBlock.value.length >= 6) {\n          // Cofactor h (index 5)\n          const cofactor = valueBlock.value[5];\n          if (cofactor && cofactor.valueBlock) {\n            curveParams.h = Buffer.from(cofactor.valueBlock.valueHexView).toString('hex');\n          }\n        } else {\n          curveParams.h = '01';\n        }\n        const identifiedCurve = identifyCurve(curveParams);\n        curveName = identifiedCurve;\n        bits = getECDSACurveBits(curveName);\n      } else {\n        if (valueBlock.value) {\n          console.log(valueBlock.value);\n        } else {\n          console.log('No value block found');\n        }\n      }\n    }\n\n    // Get the public key x and y parameters\n    const publicKeyBuffer = cert.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView;\n    if (publicKeyBuffer && curveName !== 'Unknown') {\n      const elliptic = initElliptic();\n      const ec = new elliptic.ec(getCurveForElliptic(curveName));\n      const key = ec.keyFromPublic(publicKeyBuffer);\n      const x_point = key.getPublic().getX().toString('hex');\n      const y_point = key.getPublic().getY().toString('hex');\n\n      // For 521 bit curves, pad to expected length of 132 hex chars (66 bytes)\n      if (curveName === 'secp521r1' || curveName === 'brainpoolP521r1') {\n        x = x_point.padStart(132, '0');\n        y = y_point.padStart(132, '0');\n      } else {\n        // For other curves, ensure even length\n        x = x_point.length % 2 === 0 ? x_point : '0' + x_point;\n        y = y_point.length % 2 === 0 ? y_point : '0' + y_point;\n      }\n    }\n    return { curve: curveName, params: curveParams, bits: bits, x: x, y: y };\n  } catch (error) {\n    console.error('Error parsing EC parameters:', error);\n    return {\n      curve: 'Error',\n      params: {} as StandardCurve,\n      bits: 'Unknown',\n      x: 'Unknown',\n      y: 'Unknown',\n    };\n  }\n}\n\nexport function getTBSBytesForge(certificate: Certificate): number[] {\n  return Array.from(certificate.tbsView.map((byte) => parseInt(byte.toString(16), 16)));\n}\n\nexport function parseCertificateSimple(pem: string): CertificateData {\n  const certificateData: CertificateData = {\n    id: '',\n    issuer: '',\n    validity: {\n      notBefore: '',\n      notAfter: '',\n    },\n    subjectKeyIdentifier: '',\n    authorityKeyIdentifier: '',\n    signatureAlgorithm: '',\n    hashAlgorithm: '',\n    publicKeyDetails: undefined,\n    tbsBytes: undefined,\n    tbsBytesLength: '',\n    rawPem: '',\n    rawTxt: '',\n    publicKeyAlgoOID: '',\n  };\n  try {\n    const cert = getCertificateFromPem(pem);\n    certificateData.tbsBytes = getTBSBytesForge(cert);\n    certificateData.tbsBytesLength = certificateData.tbsBytes.length.toString();\n\n    const publicKeyAlgoOID = cert.subjectPublicKeyInfo.algorithm.algorithmId;\n    const publicKeyAlgoFN = getFriendlyName(publicKeyAlgoOID);\n    const signatureAlgoOID = cert.signatureAlgorithm.algorithmId;\n    const signatureAlgoFN = getFriendlyName(signatureAlgoOID);\n    certificateData.hashAlgorithm = getHashAlgorithm(signatureAlgoFN);\n    certificateData.publicKeyAlgoOID = publicKeyAlgoOID;\n    let params;\n    if (publicKeyAlgoFN === 'RSA' && signatureAlgoFN != 'RSASSA_PSS') {\n      certificateData.signatureAlgorithm = 'rsa';\n      params = getParamsRSA(cert);\n    } else if (publicKeyAlgoFN === 'ECC') {\n      certificateData.signatureAlgorithm = 'ecdsa';\n      params = getParamsECDSA(cert);\n    } else if (publicKeyAlgoFN === 'RSASSA_PSS' || signatureAlgoFN === 'RSASSA_PSS') {\n      certificateData.signatureAlgorithm = 'rsapss';\n      params = getParamsRSAPSS(cert);\n    } else {\n      console.log(publicKeyAlgoFN);\n    }\n    certificateData.publicKeyDetails = params;\n    certificateData.issuer = getIssuerCountryCode(cert);\n    certificateData.validity = {\n      notBefore: cert.notBefore.value.toString(),\n      notAfter: cert.notAfter.value.toString(),\n    };\n    const ski = getSubjectKeyIdentifier(cert);\n    certificateData.id = ski.slice(0, 12);\n    certificateData.subjectKeyIdentifier = ski;\n    certificateData.rawPem = pem;\n\n    const authorityKeyIdentifier = getAuthorityKeyIdentifier(cert);\n    certificateData.authorityKeyIdentifier = authorityKeyIdentifier;\n\n    // corner case for rsapss\n    if (\n      certificateData.signatureAlgorithm === 'rsapss' &&\n      (!certificateData.hashAlgorithm || certificateData.hashAlgorithm === 'unknown')\n    ) {\n      certificateData.hashAlgorithm = (\n        certificateData.publicKeyDetails as PublicKeyDetailsRSAPSS\n      ).hashAlgorithm;\n    }\n\n    return certificateData;\n  } catch (error) {\n    console.error(`Error processing certificate`, error);\n    throw error;\n  }\n}\n","import {\n  COMMITMENT_TREE_DEPTH,\n  max_csca_bytes,\n  max_dsc_bytes,\n  MAX_PADDED_ECONTENT_LEN,\n  MAX_PADDED_SIGNED_ATTR_LEN,\n  OFAC_TREE_LEVELS,\n} from '../../constants/constants.js';\nimport { getCurrentDateYYMMDD } from '../date.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { formatMrz } from '../passports/format.js';\nimport {\n  extractSignatureFromDSC,\n  findStartPubKeyIndex,\n  formatSignatureDSCCircuit,\n  generateCommitment,\n  getCertificatePubKey,\n  getPassportSignatureInfos,\n  pad,\n  padWithZeroes,\n} from '../passports/passport.js';\nimport {\n  generateMerkleProof,\n  generateSMTProof,\n  getCountryLeaf,\n  getCscaTreeInclusionProof,\n  getDscTreeInclusionProof,\n  getLeafCscaTree,\n  getLeafDscTree,\n  getNameDobLeaf,\n  getNameYobLeaf,\n  getPassportNumberAndNationalityLeaf,\n} from '../trees.js';\nimport type { PassportData } from '../types.js';\nimport { formatCountriesList } from './formatInputs.js';\nimport { stringToAsciiBigIntArray } from './uuid.js';\n\nimport type { LeanIMT } from '@openpassport/zk-kit-lean-imt';\nimport type { SMT } from '@openpassport/zk-kit-smt';\n\n// this get the commitment index whether it is a string or a bigint\n// this is necessary rn because when the tree is send from the server in a serialized form,\n// the bigints are converted to strings and I can't figure out how to use tree.import to load bigints there\nexport function findIndexInTree(tree: LeanIMT, commitment: bigint): number {\n  let index = tree.indexOf(commitment);\n  if (index === -1) {\n    index = tree.indexOf(commitment.toString() as unknown as bigint);\n  }\n  if (index === -1) {\n    throw new Error('This commitment was not found in the tree');\n  } else {\n    //  console.log(`Index of commitment in the registry: ${index}`);\n  }\n  return index;\n}\n\nexport function formatInput(input: any) {\n  if (Array.isArray(input)) {\n    return input.map((item) => BigInt(item).toString());\n  } else if (input instanceof Uint8Array) {\n    return Array.from(input).map((num) => BigInt(num).toString());\n  } else if (typeof input === 'string' && input.includes(',')) {\n    const numbers = input\n      .split(',')\n      .map((s) => s.trim())\n      .filter((s) => s !== '' && !isNaN(Number(s)))\n      .map(Number);\n\n    try {\n      return numbers.map((num) => BigInt(num).toString());\n    } catch (e) {\n      throw e;\n    }\n  } else {\n    return [BigInt(input).toString()];\n  }\n}\n\nexport function generateCircuitInputsCountryVerifier(\n  passportData: PassportData,\n  sparsemerkletree: SMT\n) {\n  const mrz_bytes = formatMrz(passportData.mrz);\n  const usa_ascii = stringToAsciiBigIntArray('USA');\n  const country_leaf = getCountryLeaf(usa_ascii, mrz_bytes.slice(7, 10));\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, country_leaf);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    hostCountry: formatInput(usa_ascii),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsDSC(\n  passportData: PassportData,\n  serializedCscaTree: string[][]\n) {\n  const passportMetadata = passportData.passportMetadata;\n  const cscaParsed = passportData.csca_parsed;\n  const dscParsed = passportData.dsc_parsed;\n  const raw_dsc = passportData.dsc;\n  // CSCA is padded with 0s to max_csca_bytes\n  const cscaTbsBytesPadded = padWithZeroes(cscaParsed.tbsBytes, max_csca_bytes);\n  const dscTbsBytes = dscParsed.tbsBytes;\n\n  // DSC is padded using sha padding because it will be hashed in the circuit\n  const [dscTbsBytesPadded, dscTbsBytesLen] = pad(passportMetadata.cscaHashFunction)(\n    dscTbsBytes,\n    max_dsc_bytes\n  );\n  const leaf = getLeafCscaTree(cscaParsed);\n  const [root, path, siblings] = getCscaTreeInclusionProof(leaf, serializedCscaTree);\n  // Parse CSCA certificate and get its public key\n  const csca_pubKey_formatted = getCertificatePubKey(\n    cscaParsed,\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction\n  );\n\n  const signatureRaw = extractSignatureFromDSC(raw_dsc);\n  const signature = formatSignatureDSCCircuit(\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction,\n    cscaParsed,\n    signatureRaw\n  );\n  // Get start index of CSCA pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    cscaParsed,\n    cscaTbsBytesPadded,\n    passportMetadata.cscaSignatureAlgorithm\n  );\n  return {\n    raw_csca: cscaTbsBytesPadded.map((x) => x.toString()),\n    raw_csca_actual_length: BigInt(cscaParsed.tbsBytes.length).toString(),\n    csca_pubKey_offset: startIndex.toString(),\n    csca_pubKey_actual_size: BigInt(keyLength).toString(),\n    raw_dsc: Array.from(dscTbsBytesPadded).map((x) => x.toString()),\n    raw_dsc_padded_length: BigInt(dscTbsBytesLen).toString(), // with the sha padding actually\n    csca_pubKey: csca_pubKey_formatted,\n    signature,\n    merkle_root: root,\n    path: path,\n    siblings: siblings,\n  };\n}\n\nexport function generateCircuitInputsOfac(\n  passportData: PassportData,\n  sparsemerkletree: SMT,\n  proofLevel: number\n) {\n  const { mrz, documentType } = passportData;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const mrz_bytes = formatMrz(mrz); // Assume formatMrz handles basic formatting\n  const nameSlice = isPassportType\n    ? mrz_bytes.slice(5 + 5, 44 + 5)\n    : mrz_bytes.slice(60 + 5, 90 + 5);\n  const dobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 63 + 5)\n    : mrz_bytes.slice(30 + 5, 36 + 5);\n  const yobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 59 + 5)\n    : mrz_bytes.slice(30 + 5, 32 + 5);\n  const nationalitySlice = isPassportType\n    ? mrz_bytes.slice(54 + 5, 57 + 5)\n    : mrz_bytes.slice(45 + 5, 48 + 5);\n  const passNoSlice = isPassportType\n    ? mrz_bytes.slice(44 + 5, 53 + 5)\n    : mrz_bytes.slice(5 + 5, 14 + 5);\n\n  let leafToProve: bigint;\n\n  if (proofLevel == 3) {\n    if (!isPassportType) {\n      throw new Error(\n        'Proof level 3 (Passport Number) is only applicable to passport document types.'\n      );\n    }\n    leafToProve = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n  } else if (proofLevel == 2) {\n    leafToProve = getNameDobLeaf(nameSlice, dobSlice);\n  } else if (proofLevel == 1) {\n    leafToProve = getNameYobLeaf(nameSlice, yobSlice);\n  } else {\n    throw new Error('Invalid proof level specified for OFAC check.');\n  }\n\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, leafToProve);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsRegister(\n  secret: string,\n  passportData: PassportData,\n  serializedDscTree: string\n) {\n  const { mrz, eContent, signedAttr } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const dscParsed = passportData.dsc_parsed;\n\n  const [dscTbsBytesPadded] = pad(dscParsed.hashAlgorithm)(dscParsed.tbsBytes, max_dsc_bytes);\n\n  const { pubKey, signature, signatureAlgorithmFullName } = getPassportSignatureInfos(passportData);\n  const mrz_formatted = formatMrz(mrz);\n\n  if (eContent.length > MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]) {\n    console.error(\n      `eContent too long (${eContent.length} bytes). Max length is ${MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]} bytes.`\n    );\n    throw new Error(\n      `This length of datagroups (${eContent.length} bytes) is currently unsupported. Please contact us so we add support!`\n    );\n  }\n\n  const [eContentPadded, eContentLen] = pad(passportMetadata.eContentHashFunction)(\n    eContent,\n    MAX_PADDED_ECONTENT_LEN[passportMetadata.dg1HashFunction]\n  );\n  const [signedAttrPadded, signedAttrPaddedLen] = pad(passportMetadata.signedAttrHashFunction)(\n    signedAttr,\n    MAX_PADDED_SIGNED_ATTR_LEN[passportMetadata.eContentHashFunction]\n  );\n\n  const dsc_leaf = getLeafDscTree(dscParsed, passportData.csca_parsed); // TODO: WRONG\n  const [root, path, siblings, leaf_depth] = getDscTreeInclusionProof(dsc_leaf, serializedDscTree);\n  const csca_tree_leaf = getLeafCscaTree(passportData.csca_parsed);\n\n  // Get start index of DSC pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    dscParsed,\n    dscTbsBytesPadded,\n    dscParsed.signatureAlgorithm\n  );\n\n  const inputs = {\n    raw_dsc: dscTbsBytesPadded.map((x) => x.toString()),\n    raw_dsc_actual_length: [BigInt(dscParsed.tbsBytes.length).toString()],\n    dsc_pubKey_offset: startIndex,\n    dsc_pubKey_actual_size: [BigInt(keyLength).toString()],\n    dg1: mrz_formatted,\n    dg1_hash_offset: passportMetadata.dg1HashOffset,\n    eContent: eContentPadded,\n    eContent_padded_length: eContentLen,\n    signed_attr: signedAttrPadded,\n    signed_attr_padded_length: signedAttrPaddedLen,\n    signed_attr_econtent_hash_offset: passportMetadata.eContentHashOffset,\n    pubKey_dsc: pubKey,\n    signature_passport: signature,\n    merkle_root: [BigInt(root).toString()],\n    leaf_depth: leaf_depth,\n    path: path,\n    siblings: siblings,\n    csca_tree_leaf: csca_tree_leaf,\n    secret: secret,\n  };\n\n  return Object.entries(inputs)\n    .map(([key, value]) => ({\n      [key]: formatInput(value),\n    }))\n    .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n}\n\nexport function generateCircuitInputsVCandDisclose(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData,\n  scope: string,\n  selector_dg1: string[],\n  selector_older_than: string | number,\n  merkletree: LeanIMT,\n  majority: string,\n  passportNo_smt: SMT | null,\n  nameAndDob_smt: SMT,\n  nameAndYob_smt: SMT,\n  selector_ofac: string | number,\n  forbidden_countries_list: string[],\n  user_identifier: string\n) {\n  const { mrz, eContent, signedAttr, documentType } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const formattedMrz = formatMrz(mrz);\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(eContent),\n    'bytes'\n  );\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_tree_leaf = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n\n  const commitment = generateCommitment(secret, attestation_id, passportData);\n  const index = findIndexInTree(merkletree, BigInt(commitment));\n  const { siblings, path, leaf_depth } = generateMerkleProof(\n    merkletree,\n    index,\n    COMMITMENT_TREE_DEPTH\n  );\n  const formattedMajority = majority.length === 1 ? `0${majority}` : majority;\n  const majority_ascii = formattedMajority.split('').map((char) => char.charCodeAt(0));\n\n  // Define default values for SMT proofs (BigInt(0) for roots/keys, array of 0s for siblings)\n  const defaultSiblings = Array(OFAC_TREE_LEVELS).fill(BigInt(0));\n  let passportNoProof = {\n    root: BigInt(0),\n    closestleaf: BigInt(0),\n    siblings: defaultSiblings,\n  };\n  let nameDobProof;\n  let nameYobProof;\n\n  // Calculate leaves based on document type (using OFAC logic for slicing)\n  const nameSlice = isPassportType ? formattedMrz.slice(10, 49) : formattedMrz.slice(65, 95);\n  const dobSlice = isPassportType ? formattedMrz.slice(62, 68) : formattedMrz.slice(35, 41);\n  const yobSlice = isPassportType ? formattedMrz.slice(62, 64) : formattedMrz.slice(35, 37);\n  const nationalitySlice = isPassportType ? formattedMrz.slice(59, 62) : formattedMrz.slice(50, 53);\n  const passNoSlice = isPassportType ? formattedMrz.slice(49, 58) : formattedMrz.slice(10, 19);\n\n  const namedob_leaf = getNameDobLeaf(nameSlice, dobSlice);\n  const nameyob_leaf = getNameYobLeaf(nameSlice, yobSlice);\n\n  // Generate Name/DOB and Name/YOB proofs (always needed)\n  nameDobProof = generateSMTProof(nameAndDob_smt, namedob_leaf);\n  nameYobProof = generateSMTProof(nameAndYob_smt, nameyob_leaf);\n\n  // Generate Passport Number proof only if it's a passport type and SMT is provided\n  if (isPassportType) {\n    if (!passportNo_smt) {\n      console.warn('Document type is passport, but passportNo_smt tree was not provided.');\n    } else {\n      const passportNo_leaf = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n      const proofResult = generateSMTProof(passportNo_smt, passportNo_leaf);\n      // Explicitly cast root and closestleaf to bigint\n      passportNoProof = {\n        root: BigInt(proofResult.root),\n        closestleaf: BigInt(proofResult.closestleaf),\n        siblings: proofResult.siblings,\n      };\n    }\n  }\n  // Build Final Input Object\n  const baseInputs = {\n    secret: formatInput(secret),\n    attestation_id: formatInput(attestation_id),\n    dg1: formatInput(formattedMrz),\n    eContent_shaBytes_packed_hash: formatInput(eContent_packed_hash),\n    dsc_tree_leaf: formatInput(dsc_tree_leaf),\n    merkle_root: formatInput(merkletree.root),\n    leaf_depth: formatInput(leaf_depth),\n    path: formatInput(path),\n    siblings: formatInput(siblings),\n    selector_dg1: formatInput(selector_dg1),\n    selector_older_than: formatInput(selector_older_than),\n    scope: formatInput(scope),\n    current_date: formatInput(getCurrentDateYYMMDD()),\n    majority: formatInput(majority_ascii),\n    user_identifier: formatInput(user_identifier),\n    selector_ofac: formatInput(selector_ofac),\n    forbidden_countries_list: formatInput(formatCountriesList(forbidden_countries_list)),\n  };\n\n  const ofacNameInputs = {\n    ofac_namedob_smt_root: formatInput(nameDobProof.root),\n    ofac_namedob_smt_leaf_key: formatInput(nameDobProof.closestleaf),\n    ofac_namedob_smt_siblings: formatInput(nameDobProof.siblings),\n    ofac_nameyob_smt_root: formatInput(nameYobProof.root),\n    ofac_nameyob_smt_leaf_key: formatInput(nameYobProof.closestleaf),\n    ofac_nameyob_smt_siblings: formatInput(nameYobProof.siblings),\n  };\n\n  // Conditionally include passport OFAC inputs\n  const finalInputs = {\n    ...baseInputs,\n    ...ofacNameInputs,\n    ...(isPassportType && {\n      ofac_passportno_smt_root: formatInput(passportNoProof.root),\n      ofac_passportno_smt_leaf_key: formatInput(passportNoProof.closestleaf),\n      ofac_passportno_smt_siblings: formatInput(passportNoProof.siblings),\n    }),\n  };\n\n  return finalInputs;\n}\n"],"mappings":";AAAA,YAAY,WAAW;AACvB,SAAS,iBAAiB;;;AC2jBnB,IAAM,QAAQ;AAGd,IAAM,aAAa;AAEnB,IAAM,aAAa;AAUnB,IAAM,QAAQ;AAEd,IAAM,aAAa;AAEnB,IAAM,aAAa;AAEnB,IAAM,cAAc;;;AClkBpB,SAAS,kBAAkB,KAAuB;AACvD,MAAI,SAAS,OAAO,CAAC;AACrB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,aAAS,SAAS,OAAO,GAAG,IAAI,OAAO,IAAI,CAAC,IAAI,GAAI;AAAA,EACtD;AACA,SAAO,OAAO,SAAS;AACzB;AAqCO,SAAS,aAAa,KAAqB;AAChD,SAAO,OAAO,KAAK,GAAG,EAAE,EAAE,SAAS;AACrC;AA+EO,SAAS,aAAa,QAAgB,UAAkB,eAAuB;AACpF,MAAI,IAAI;AACR,QAAM,QAAkB,CAAC;AACzB,WAAS,IAAI,GAAG,IAAI,eAAe,EAAE,GAAG;AACtC,UAAM,UAAU,OAAO,CAAC;AAExB,UAAM,KAAK,GAAG,IAAI,OAAO,KAAK,IAAI,OAAO,OAAO,GAAG,QAAQ,CAAC,CAAC,EAAE;AAC/D,QAAI,OAAO,IAAI,OAAO,KAAK,IAAI,OAAO,OAAO,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC;AAAA,EAC9D;AACA,MAAI,EAAE,KAAK,OAAO,CAAC,IAAI;AACrB,UAAM,UAAU,MAAM,qBAAqB,WAAW,eAAe,SAAS,CAAC;AAAA,EACjF;AACA,SAAO;AACT;;;ACxJA,YAAY,YAAY;AACxB,SAAS,aAAa,cAAc,uBAAuB;AA2FpD,SAAS,sBAAsB,YAAiC;AACrE,QAAM,eAAe,WAAW,QAAQ,8CAA8C,EAAE;AACxF,QAAM,SAAS,OAAO,KAAK,cAAc,QAAQ;AACjD,QAAM,cAAc,IAAI,YAAY,OAAO,MAAM;AACjD,QAAM,OAAO,IAAI,WAAW,WAAW;AACvC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,SAAK,CAAC,IAAI,OAAO,CAAC;AAAA,EACpB;AAEA,QAAMA,QAAc,eAAQ,WAAW;AACvC,MAAIA,MAAK,WAAW,IAAI;AACtB,UAAM,IAAI,MAAM,wBAAwBA,MAAK,OAAO,KAAK,EAAE;AAAA,EAC7D;AAEA,SAAO,IAAI,YAAY,EAAE,QAAQA,MAAK,OAAO,CAAC;AAChD;;;ACnDO,SAAS,YAAY,OAAY;AACtC,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO,MAAM,IAAI,CAAC,SAAS,OAAO,IAAI,EAAE,SAAS,CAAC;AAAA,EACpD,WAAW,iBAAiB,YAAY;AACtC,WAAO,MAAM,KAAK,KAAK,EAAE,IAAI,CAAC,QAAQ,OAAO,GAAG,EAAE,SAAS,CAAC;AAAA,EAC9D,WAAW,OAAO,UAAU,YAAY,MAAM,SAAS,GAAG,GAAG;AAC3D,UAAM,UAAU,MACb,MAAM,GAAG,EACT,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,EACnB,OAAO,CAAC,MAAM,MAAM,MAAM,CAAC,MAAM,OAAO,CAAC,CAAC,CAAC,EAC3C,IAAI,MAAM;AAEb,QAAI;AACF,aAAO,QAAQ,IAAI,CAAC,QAAQ,OAAO,GAAG,EAAE,SAAS,CAAC;AAAA,IACpD,SAAS,GAAG;AACV,YAAM;AAAA,IACR;AAAA,EACF,OAAO;AACL,WAAO,CAAC,OAAO,KAAK,EAAE,SAAS,CAAC;AAAA,EAClC;AACF;;;AJzCO,SAAS,uBAAuB,gBAAoD;AACzF,QAAM,eAAe,OAAO,KAAK,cAAc,EAAE,SAAS,QAAQ;AAClE,QAAMC,QAAa,WAAK,QAAQ,YAAY;AAC5C,QAAM,gBAAgBA,MAAK;AAE3B,MAAI,cAAc,WAAW,GAAG;AAC9B,UAAM,IAAI,MAAM,0BAA0B;AAAA,EAC5C;AAEA,MAAI,CAAC,MAAM,QAAQA,MAAK,KAAK,KAAKA,MAAK,MAAM,WAAW,GAAG;AACzD,UAAM,IAAI,MAAM,0BAA0B;AAAA,EAC5C;AACA,QAAM,IAAU,WAAK,aAAaA,MAAK,MAAM,CAAC,EAAE,KAAe,EAAE,MAAM;AACvE,QAAM,IAAU,WAAK,aAAaA,MAAK,MAAM,CAAC,EAAE,KAAe,EAAE,MAAM;AAEvE,SAAO,EAAE,GAAG,EAAE;AAChB;AAEO,SAAS,wBAAwB,gBAAwB;AAC9D,QAAM,OAAO,sBAAsB,cAAc;AACjD,QAAM,eAAe,KAAK,eAAe,WAAW;AACpD,SAAO,MAAM,KAAK,YAAY;AAChC;AA0CO,SAAS,0BACd,wBACA,kBACA,qBACA,WACU;AACV,QAAM,iCAAiC;AAAA,IACrC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,EAAE,GAAG,EAAE,IAAI,SAAS,8BAAoD;AAC9E,MAAI,2BAA2B,SAAS;AACtC,UAAM,EAAE,GAAG,EAAE,IAAI,uBAAuB,SAAS;AACjD,UAAM,cAAc,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AAC9D,UAAM,cAAc,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AAC9D,WAAO,CAAC,GAAG,aAAa,GAAG,WAAW;AAAA,EACxC,OAAO;AACL,WAAO,YAAY,aAAa,OAAO,kBAAkB,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,EAC7E;AACF;AAiCA,SAAS,qBAAqB,cAA4B,GAAW,GAAgB;AACnF,QAAM,EAAE,mBAAmB,IAAI,aAAa;AAC5C,MAAI,uBAAuB,SAAS;AAClC,UAAM,EAAE,GAAG,EAAE,IAAI,uBAAuB,aAAa,eAAe;AACpE,UAAM,cAAc,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AAC9D,UAAM,cAAc,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AAC9D,WAAO,CAAC,GAAG,aAAa,GAAG,WAAW;AAAA,EACxC,OAAO;AACL,WAAO,aAAa,OAAO,kBAAkB,aAAa,eAAe,CAAC,GAAG,GAAG,CAAC;AAAA,EACnF;AACF;AAgBO,SAAS,qBACd,iBACA,oBACA,cACK;AACL,QAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,EAAE,GAAG,EAAE,IAAI,SAAS,0BAAgD;AAC1E,QAAM,EAAE,iBAAiB,IAAI;AAC7B,MAAI,uBAAuB,SAAS;AAClC,UAAM,EAAE,GAAG,EAAE,IAAI;AACjB,UAAM,QAAQ,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AACxD,UAAM,QAAQ,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AACxD,WAAO,CAAC,GAAG,OAAO,GAAG,KAAK;AAAA,EAC5B,OAAO;AACL,UAAM,EAAE,QAAQ,IAAI;AACpB,WAAO,aAAa,OAAO,aAAa,OAAO,CAAC,GAAG,GAAG,CAAC;AAAA,EACzD;AACF;AAEO,SAAS,SAAS,QAA4B;AACnD,MAAI,WAAW,yBAAyB;AACtC,WAAO,EAAE,GAAG,YAAY,GAAG,MAAM;AAAA,EACnC;AAEA,MAAI,OAAO,WAAW,QAAQ,GAAG;AAC/B,QAAI,OAAO,SAAS,KAAK,GAAG;AAC1B,aAAO,EAAE,GAAG,IAAI,GAAG,EAAE;AAAA,IACvB,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,aAAa,GAAG,EAAE;AAAA,IAChC,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,aAAa,GAAG,EAAE;AAAA,IAChC,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,aAAa,GAAG,EAAE;AAAA,IAChC,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,IAAI,GAAG,EAAE;AAAA,IACvB,OAAO;AACL,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AAAA,EACF;AAEA,MAAI,OAAO,WAAW,SAAS,GAAG;AAChC,UAAM,YAAY,SAAS,OAAO,MAAM,GAAG,EAAE,CAAC,CAAC;AAE/C,QAAI,cAAc,MAAM;AACtB,aAAO,EAAE,GAAG,YAAY,GAAG,WAAW;AAAA,IACxC;AAEA,QAAI,cAAc,MAAM;AACtB,aAAO,EAAE,GAAG,YAAY,GAAG,WAAW;AAAA,IACxC;AACA,WAAO,EAAE,GAAG,OAAO,GAAG,MAAM;AAAA,EAC9B;AAEA,MAAI,WAAW,2BAA2B,WAAW,yBAAyB;AAC5E,WAAO,EAAE,GAAG,YAAY,GAAG,WAAW;AAAA,EACxC;AAEA,SAAO,EAAE,GAAG,OAAO,GAAG,MAAM;AAC9B;AAUO,SAAS,0BAA0B,cAA4B;AACpE,QAAM,mBAAmB,aAAa;AACtC,QAAM,6BAA6B;AAAA,IACjC,aAAa;AAAA,IACb,iBAAiB;AAAA,IACjB,iBAAiB;AAAA,EACnB;AACA,QAAM,EAAE,GAAG,EAAE,IAAI,SAAS,0BAAgD;AAE1E,SAAO;AAAA,IACL,QAAQ;AAAA,MACN,aAAa;AAAA,MACb,iBAAiB;AAAA,MACjB,iBAAiB;AAAA,IACnB;AAAA,IACA,WAAW,qBAAqB,cAAc,GAAG,CAAC;AAAA,IAClD;AAAA,EACF;AACF;AAIO,SAAS,8BACd,iBACA,oBACA,eACQ;AACR,QAAM,EAAE,iBAAiB,IAAI;AAC7B,MAAI,uBAAuB,SAAS;AAClC,WAAO,GAAG,kBAAkB,IAAI,aAAa,IAAK,iBAA2C,KAAK,IAAI,iBAAiB,IAAI;AAAA,EAC7H,OAAO;AACL,UAAM,EAAE,SAAS,IAAI;AACrB,WAAO,GAAG,kBAAkB,IAAI,aAAa,IAAI,QAAQ,IAAI,iBAAiB,IAAI;AAAA,EACpF;AACF;","names":["asn1","asn1"]}