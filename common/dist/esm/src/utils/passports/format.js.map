{"version":3,"sources":["../../../../../src/utils/bytes.ts","../../../../../src/utils/passports/format.ts"],"sourcesContent":["import { MAX_BYTES_IN_FIELD } from '../constants/constants.js';\n\nexport function bigIntToChunkedBytes(\n  num: BigInt | bigint,\n  bytesPerChunk: number,\n  numChunks: number\n) {\n  const res: string[] = [];\n  const bigintNum: bigint = typeof num == 'bigint' ? num : num.valueOf();\n  const msk = (1n << BigInt(bytesPerChunk)) - 1n;\n  for (let i = 0; i < numChunks; ++i) {\n    res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());\n  }\n  return res;\n}\nexport function bytesToBigDecimal(arr: number[]): string {\n  let result = BigInt(0);\n  for (let i = 0; i < arr.length; i++) {\n    result = result * BigInt(256) + BigInt(arr[i] & 0xff);\n  }\n  return result.toString();\n}\n\nexport function computeIntChunkLength(byteLength: number) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const remain = byteLength % packSize;\n  let numChunks = (byteLength - remain) / packSize;\n  if (remain > 0) {\n    numChunks += 1;\n  }\n  return numChunks;\n}\n\nexport function derToBytes(derValue: string) {\n  const bytes = [];\n  for (let i = 0; i < derValue.length; i++) {\n    bytes.push(derValue.charCodeAt(i));\n  }\n  return bytes;\n}\n\nexport function hexStringToSignedIntArray(hexString: string) {\n  const result = [];\n  for (let i = 0; i < hexString.length; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    result.push(byte > 127 ? byte - 256 : byte);\n  }\n  return result;\n}\n\nexport function hexToBin(n: string): string {\n  let bin = Number(`0x${n[0]}`).toString(2);\n  for (let i = 1; i < n.length; i += 1) {\n    bin += Number(`0x${n[i]}`).toString(2).padStart(4, '0');\n  }\n  return bin;\n}\n\nexport function hexToDecimal(hex: string): string {\n  return BigInt(`0x${hex}`).toString();\n}\n\nexport function hexToSignedBytes(hexString: string): number[] {\n  const bytes = [];\n  for (let i = 0; i < hexString.length - 1; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    bytes.push(byte >= 128 ? byte - 256 : byte);\n  }\n  return bytes;\n}\n\nexport function num2Bits(n: number, inValue: bigint): bigint[] {\n  const out: bigint[] = new Array(n).fill(BigInt(0));\n  let lc1: bigint = BigInt(0);\n  let e2: bigint = BigInt(1);\n\n  for (let i = 0; i < n; i++) {\n    out[i] = (inValue >> BigInt(i)) & BigInt(1);\n\n    if (out[i] !== BigInt(0) && out[i] !== BigInt(1)) {\n      throw new Error('Bit value is not binary.');\n    }\n\n    lc1 += out[i] * e2;\n    e2 = e2 << BigInt(1);\n  }\n\n  if (lc1 !== inValue) {\n    throw new Error('Reconstructed value does not match the input.');\n  }\n  return out;\n}\n\nexport function packBytes(unpacked) {\n  const bytesCount = [31, 31, 31];\n  const packed = [0n, 0n, 0n];\n\n  let byteIndex = 0;\n  for (let i = 0; i < bytesCount.length; i++) {\n    for (let j = 0; j < bytesCount[i]; j++) {\n      if (byteIndex < unpacked.length) {\n        packed[i] |= BigInt(unpacked[byteIndex]) << (BigInt(j) * 8n);\n      }\n      byteIndex++;\n    }\n  }\n  return packed;\n}\n\nexport function packBytesArray(unpacked: number[]) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const maxBytes = unpacked.length;\n  const maxInts = computeIntChunkLength(maxBytes);\n  const out: bigint[] = new Array(maxInts).fill(0n);\n\n  for (let i = 0; i < maxInts; i++) {\n    let sum = 0n;\n    for (let j = 0; j < packSize; j++) {\n      const idx = packSize * i + j;\n\n      // Copy previous value if out of bounds\n      if (idx >= maxBytes) {\n        continue;\n      }\n      // First item of chunk is byte itself\n      else if (j === 0) {\n        sum = BigInt(unpacked[idx]);\n      }\n      // Every other item is 256^j * byte\n      else {\n        sum += (1n << BigInt(8 * j)) * BigInt(unpacked[idx]);\n      }\n    }\n    out[i] = sum;\n  }\n\n  return out;\n}\n\nexport function splitToWords(number: bigint, wordsize: number, numberElement: number) {\n  let t = number;\n  const words: string[] = [];\n  for (let i = 0; i < numberElement; ++i) {\n    const baseTwo = BigInt(2);\n\n    words.push(`${t % BigInt(Math.pow(Number(baseTwo), wordsize))}`);\n    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), wordsize)));\n  }\n  if (!(t == BigInt(0))) {\n    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;\n  }\n  return words;\n}\n\nexport const toBinaryString = (byte: any) => {\n  const binary = (parseInt(byte, 10) & 0xff).toString(2).padStart(8, '0');\n  return binary;\n};\n\nexport function toSigned(byte: number) {\n  return byte > 127 ? byte - 256 : byte;\n}\nexport function toUnsigned(byte: number) {\n  return byte & 0xff;\n}\nexport function toUnsignedByte(signedByte: number) {\n  return signedByte < 0 ? signedByte + 256 : signedByte;\n}\n","import { toUnsignedByte } from '../bytes.js';\n\nexport function formatAndConcatenateDataHashes(\n  dataHashes: [number, number[]][],\n  dg1HashOffset: number\n) {\n  // concatenating dataHashes :\n  const concat: number[] = [];\n\n  const startingSequence = Array.from(\n    { length: dg1HashOffset },\n    () => Math.floor(Math.random() * 256) - 128\n  );\n\n  // // sha256 with rsa (index of mrzhash is 31)\n  // const startingSequence = [\n  //   // SEQUENCE + long form indicator + length (293 bytes)\n  //   48, -126, 1, 37,\n  //   // length: 1 byte\n  //   2, 1,\n  //   // LDSSecurityObjectVersion v0\n  //   0,\n  //   // padding: size 11 - size 9...\n  //   48, 11, 6, 9,\n  //   // 2.16.840.1.101.3.4.2.1 is sha256\n  //   96, -122, 72, 1, 101, 3, 4, 2, 1,\n  //   // SEQUENCE + long form indicator + length (273 bytes)\n  //   48, -126, 1, 17,\n  // ]\n\n  // rsassaPss (index of mrzhash is 30)\n  // // SEQUENCE + short form indicator + length (137 bytes)\n  // 48, -127, -119,\n  // 2, 1,\n  // 0,\n  // 48, 13, 6, 9,\n  // // 2.16.840.1.101.3.4.2.1 is sha256\n  // 96, -122, 72, 1, 101, 3, 4, 2, 1,\n  // // NULL tag + SEQUENCE + length (117 bytes)\n  // 5, 0, 48, 117,\n\n  // SHA384withECDSA (index of mrzhash is 33)\n  // // SEQUENCE + long form indicator + length (313 bytes)\n  // 48, -126, 1, 57,\n  // 2, 1,\n  // 1,\n  // 48, 13, 6, 9,\n  // // 2.16.840.1.101.3.4.2.1 is sha384\n  // 96, -122, 72, 1, 101, 3, 4, 2, 2,\n  // // NULL tag + SEQUENCE + long form indicator + length (275 bytes)\n  // 5, 0, 48, -126, 1, 19,\n\n  // spain\n  // 48, -127,  -79,\n  // 2,    1,\n  // 0,\n  // 48,    7,   6,   5,\n  // 1.3.14.3.2.26 is sha1\n  // 43,  14, 3,    2,   26,\n  // SEQUENCE + ...\n  // 48, -127, -94,\n\n  // => current conclusion is we should be able to just hardcode indexes\n  // => as they shouldn't change must for same sig alg.\n  // => wrong: our rsassaPss has less datagroups so the length is different (30 rather then 31)\n\n  // console.log(`startingSequence`, startingSequence.map(byte => (byte < 0 ? byte + 256 : byte).toString(16).padStart(2, '0')).join(''));\n\n  concat.push(...startingSequence);\n\n  for (const dataHash of dataHashes) {\n    // console.log(`dataHash ${dataHash[0]}`, dataHash[1].map(byte => (byte < 0 ? byte + 256 : byte).toString(16).padStart(2, '0')).join(''));\n\n    //push 7 padding bytes\n    concat.push(...[0, 0, 0, 0, 0, 0, 0]);\n\n    concat.push(...dataHash[1]);\n    // concat.push(...[48, hashLen + 5, 2, 1, dataHash[0], 4, hashLen, ...dataHash[1]])\n    // 48, 37, 2, 1, 1, 4, 32,\n    // 48, 53, 2, 1, 1, 4, 48,\n  }\n\n  return concat;\n}\n\nexport function formatDG1Attribute(index: number[], value: string) {\n  const max_length = index[1] - index[0] + 1;\n  if (value.length > max_length) {\n    throw new Error(\n      `Value is too long for index ${index[0]}-${index[1]} value: ${value} value.length: ${value.length} maxLength: ${max_length}`\n    );\n  }\n  return value.padEnd(max_length, '<');\n}\n\nexport function formatDg2Hash(dg2Hash: number[]) {\n  const unsignedBytesDg2Hash = dg2Hash.map((x) => toUnsignedByte(x));\n  while (unsignedBytesDg2Hash.length < 64) {\n    // pad it to 64 bytes to correspond to the hash length of sha512 and avoid multiplying circuits\n    unsignedBytesDg2Hash.push(0);\n  }\n  return unsignedBytesDg2Hash;\n}\n\nexport function formatMrz(mrz: string) {\n  const mrzCharcodes = [...mrz].map((char) => char.charCodeAt(0));\n\n  if (mrz.length === 88) {\n    mrzCharcodes.unshift(88); // the length of the mrz data\n    mrzCharcodes.unshift(95, 31); // the MRZ_INFO_TAG\n    mrzCharcodes.unshift(91); // the new length of the whole array\n    mrzCharcodes.unshift(97); // the tag for DG1\n  } else if (mrz.length === 90) {\n    mrzCharcodes.unshift(90); // the length of the mrz data\n    mrzCharcodes.unshift(95, 31); // the MRZ_INFO_TAG\n    mrzCharcodes.unshift(93); // the new length of the whole array\n    mrzCharcodes.unshift(97); // the tag for DG1\n  } else {\n    throw new Error(`Unsupported MRZ length: ${mrz.length}. Expected 88 or 90 characters.`);\n  }\n\n  return mrzCharcodes;\n}\n\nexport function formatName(firstName: string, lastName: string, targetLength: number) {\n  // Split names by spaces and join parts with '<'\n  const formattedLastName = lastName.toUpperCase().split(' ').join('<');\n  const formattedFirstName = firstName.toUpperCase().split(' ').join('<');\n\n  // Combine with '<<' separator\n  let result = `${formattedLastName}<<${formattedFirstName}`;\n\n  // Pad with '<' or truncate to target length\n  if (result.length < targetLength) {\n    result = result.padEnd(targetLength, '<');\n  } else if (result.length > targetLength) {\n    result = result.substring(0, targetLength);\n  }\n\n  return result;\n}\n\nexport function generateSignedAttr(messageDigest: number[]) {\n  const constructedEContent = [];\n\n  // Detailed description is in private file r&d.ts for now\n  // First, the tag and length, assumed to be always the same\n  constructedEContent.push(...[49, 102]);\n\n  // 1.2.840.113549.1.9.3 is RFC_3369_CONTENT_TYPE_OID\n  constructedEContent.push(...[48, 21, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 3]);\n  // 2.23.136.1.1.1 is ldsSecurityObject\n  constructedEContent.push(...[49, 8, 6, 6, 103, -127, 8, 1, 1, 1]);\n\n  // 1.2.840.113549.1.9.5 is signing-time\n  constructedEContent.push(...[48, 28, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 5]);\n  // mock time of signature\n  constructedEContent.push(...[49, 15, 23, 13, 49, 57, 49, 50, 49, 54, 49, 55, 50, 50, 51, 56, 90]);\n  // 1.2.840.113549.1.9.4 is RFC_3369_MESSAGE_DIGEST_OID\n  constructedEContent.push(...[48, 47, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 4]);\n  // TAG and length of the message digest\n  constructedEContent.push(...[49, 34, 4, 32]);\n\n  constructedEContent.push(...messageDigest);\n  return constructedEContent;\n}\n"],"mappings":"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","names":[]}