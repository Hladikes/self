{"version":3,"sources":["../../../../../src/utils/passports/parsing.ts","../../../../../src/utils/passports/passport.ts","../../../../../src/constants/constants.ts","../../../../../src/utils/bytes.ts","../../../../../src/utils/csca.ts","../../../../../src/utils/shaPad.ts"],"sourcesContent":["export {\n  findStartPubKeyIndex,\n  formatCertificatePubKeyDSC,\n  getCertificatePubKey,\n  getNAndKCSCA,\n  pad,\n  padWithZeroes,\n} from './passport.js';\n","import * as forge from 'node-forge';\nimport { poseidon5 } from 'poseidon-lite';\n\nimport type { hashAlgos } from '../../constants/constants.js';\nimport {\n  k_csca,\n  k_dsc,\n  k_dsc_3072,\n  k_dsc_4096,\n  k_dsc_ecdsa,\n  n_csca,\n  n_dsc,\n  n_dsc_3072,\n  n_dsc_4096,\n  n_dsc_ecdsa,\n} from '../../constants/constants.js';\nimport { bytesToBigDecimal, hexToDecimal, splitToWords } from '../bytes.js';\nimport type {\n  CertificateData,\n  PublicKeyDetailsECDSA,\n  PublicKeyDetailsRSA,\n} from '../certificate_parsing/dataStructure.js';\nimport {\n  getCertificateFromPem,\n  parseCertificateSimple,\n} from '../certificate_parsing/parseCertificateSimple.js';\nimport { formatInput } from '../circuits/generateInputs.js';\nimport { findStartIndex, findStartIndexEC } from '../csca.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { sha384_512Pad, shaPad } from '../shaPad.js';\nimport { getLeafDscTree } from '../trees.js';\nimport type { PassportData, SignatureAlgorithm } from '../types.js';\nimport { formatMrz } from './format.js';\nimport { parsePassportData } from './passport_parsing/parsePassportData.js';\n\nexport function extractRSFromSignature(signatureBytes: number[]): { r: string; s: string } {\n  const derSignature = Buffer.from(signatureBytes).toString('binary');\n  const asn1 = forge.asn1.fromDer(derSignature);\n  const signatureAsn1 = asn1.value;\n\n  if (signatureAsn1.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n\n  if (!Array.isArray(asn1.value) || asn1.value.length !== 2) {\n    throw new Error('Invalid signature format');\n  }\n  const r = forge.util.createBuffer(asn1.value[0].value as string).toHex();\n  const s = forge.util.createBuffer(asn1.value[1].value as string).toHex();\n\n  return { r, s };\n}\n\nexport function extractSignatureFromDSC(dscCertificate: string) {\n  const cert = getCertificateFromPem(dscCertificate);\n  const dscSignature = cert.signatureValue.valueBlock.valueHexView;\n  return Array.from(dscSignature);\n}\n\nexport function findStartPubKeyIndex(\n  certificateData: CertificateData,\n  rawCert: any,\n  signatureAlgorithm: string\n): [number, number] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const [x_index, x_totalLength] = findStartIndexEC(x, rawCert);\n    const [y_index, y_totalLength] = findStartIndexEC(y, rawCert);\n\n    return [x_index, x_totalLength + y_totalLength];\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return findStartIndex(modulus, rawCert);\n  }\n}\n\n/// @notice Get the public key from the certificate padded as per the DSC circuit's requirements.\nexport function formatCertificatePubKeyDSC(\n  certificateData: CertificateData,\n  signatureAlgorithm: string\n): string[] {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    // const normalizedX = x.length % 2 === 0 ? x : '0' + x;\n    // const normalizedY = y.length % 2 === 0 ? y : '0' + y;\n    const fullPubKey = x + y;\n\n    // Splits to 525 words of 8 bits each\n    return splitToWords(BigInt(hexToDecimal(fullPubKey)), 8, 525);\n  } else {\n    // Splits to 525 words of 8 bits each\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), 8, 525);\n  }\n}\n\nexport function formatSignatureDSCCircuit(\n  cscaSignatureAlgorithm: string,\n  cscaHashFunction: string,\n  cscaCertificateData: CertificateData,\n  signature: number[]\n): string[] {\n  const cscaSignatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    cscaCertificateData,\n    cscaSignatureAlgorithm,\n    cscaHashFunction\n  );\n  const { n, k } = getNAndK(cscaSignatureAlgorithmFullName as SignatureAlgorithm);\n  if (cscaSignatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(signature);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return formatInput(splitToWords(BigInt(bytesToBigDecimal(signature)), n, k));\n  }\n}\n\nexport function generateCommitment(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData\n) {\n  const passportMetadata = passportData.passportMetadata;\n\n  const dg1_packed_hash = packBytesAndPoseidon(formatMrz(passportData.mrz));\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(passportData.eContent),\n    'bytes'\n  );\n\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_hash = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n  // Log the values used to generate the commitment\n\n  return poseidon5([\n    secret,\n    attestation_id,\n    dg1_packed_hash,\n    eContent_packed_hash,\n    dsc_hash,\n  ]).toString();\n}\n\nfunction getPassportSignature(passportData: PassportData, n: number, k: number): any {\n  const { signatureAlgorithm } = passportData.dsc_parsed;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { r, s } = extractRSFromSignature(passportData.encryptedDigest);\n    const signature_r = splitToWords(BigInt(hexToDecimal(r)), n, k);\n    const signature_s = splitToWords(BigInt(hexToDecimal(s)), n, k);\n    return [...signature_r, ...signature_s];\n  } else {\n    return splitToWords(BigInt(bytesToBigDecimal(passportData.encryptedDigest)), n, k);\n  }\n}\n\nexport function generateNullifier(passportData: PassportData) {\n  const signedAttr_shaBytes = hash(\n    passportData.passportMetadata.signedAttrHashFunction,\n    Array.from(passportData.signedAttr),\n    'bytes'\n  );\n  const signedAttr_packed_hash = packBytesAndPoseidon(\n    (signedAttr_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n  return signedAttr_packed_hash;\n}\n\n/// @notice Get the public key from the certificate\n/// @dev valid for both DSC and CSCA\nexport function getCertificatePubKey(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashFunction: string\n): any {\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    certificateData,\n    signatureAlgorithm,\n    hashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    const { x, y } = publicKeyDetails as PublicKeyDetailsECDSA;\n    const x_dsc = splitToWords(BigInt(hexToDecimal(x)), n, k);\n    const y_dsc = splitToWords(BigInt(hexToDecimal(y)), n, k);\n    return [...x_dsc, ...y_dsc];\n  } else {\n    const { modulus } = publicKeyDetails as PublicKeyDetailsRSA;\n    return splitToWords(BigInt(hexToDecimal(modulus)), n, k);\n  }\n}\n\nexport function getNAndK(sigAlg: SignatureAlgorithm) {\n  if (sigAlg === 'rsa_sha256_65537_3072') {\n    return { n: n_dsc_3072, k: k_dsc }; // 3072/32 = 96\n  }\n\n  if (sigAlg.startsWith('ecdsa_')) {\n    if (sigAlg.endsWith('224')) {\n      return { n: 32, k: 7 };\n    } else if (sigAlg.endsWith('256')) {\n      return { n: n_dsc_ecdsa, k: 4 };\n    } else if (sigAlg.endsWith('384')) {\n      return { n: n_dsc_ecdsa, k: 6 };\n    } else if (sigAlg.endsWith('512')) {\n      return { n: n_dsc_ecdsa, k: 8 };\n    } else if (sigAlg.endsWith('521')) {\n      return { n: 66, k: 8 };\n    } else {\n      throw new Error('invalid key size');\n    }\n  }\n\n  if (sigAlg.startsWith('rsapss_')) {\n    const keyLength = parseInt(sigAlg.split('_')[3]);\n\n    if (keyLength === 3072) {\n      return { n: n_dsc_3072, k: k_dsc_3072 }; // 3072/32 = 96\n    }\n\n    if (keyLength === 4096) {\n      return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n    }\n    return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n  }\n\n  if (sigAlg === 'rsa_sha256_65537_4096' || sigAlg === 'rsa_sha512_65537_4096') {\n    return { n: n_dsc_4096, k: k_dsc_4096 }; // 4096/32 = 128\n  }\n\n  return { n: n_dsc, k: k_dsc }; // 2048/32 = 64\n}\n\nexport function getNAndKCSCA(sigAlg: 'rsa' | 'ecdsa' | 'rsapss') {\n  const n = sigAlg === 'ecdsa' ? n_dsc_ecdsa : n_csca;\n  const k = sigAlg === 'ecdsa' ? k_dsc_ecdsa : k_csca;\n  return { n, k };\n}\n\n/// @notice Get the signature of the passport and the public key of the DSC\n/// @dev valid for only for the passport/dsc chain\nexport function getPassportSignatureInfos(passportData: PassportData) {\n  const passportMetadata = passportData.passportMetadata;\n  const signatureAlgorithmFullName = getSignatureAlgorithmFullName(\n    passportData.dsc_parsed,\n    passportMetadata.signatureAlgorithm,\n    passportMetadata.signedAttrHashFunction\n  );\n  const { n, k } = getNAndK(signatureAlgorithmFullName as SignatureAlgorithm);\n\n  return {\n    pubKey: getCertificatePubKey(\n      passportData.dsc_parsed,\n      passportMetadata.signatureAlgorithm,\n      passportMetadata.signedAttrHashFunction\n    ),\n    signature: getPassportSignature(passportData, n, k),\n    signatureAlgorithmFullName: signatureAlgorithmFullName,\n  };\n}\n\n/// @notice Get the signature algorithm full name\n/// @dev valid for both DSC and CSCA\nexport function getSignatureAlgorithmFullName(\n  certificateData: CertificateData,\n  signatureAlgorithm: string,\n  hashAlgorithm: string\n): string {\n  const { publicKeyDetails } = certificateData;\n  if (signatureAlgorithm === 'ecdsa') {\n    return `${signatureAlgorithm}_${hashAlgorithm}_${(publicKeyDetails as PublicKeyDetailsECDSA).curve}_${publicKeyDetails.bits}`;\n  } else {\n    const { exponent } = publicKeyDetails as PublicKeyDetailsRSA;\n    return `${signatureAlgorithm}_${hashAlgorithm}_${exponent}_${publicKeyDetails.bits}`;\n  }\n}\n\n/// @dev will bruteforce passport and dsc signature\nexport function initPassportDataParsing(passportData: PassportData, skiPem: any = null) {\n  const passportMetadata = parsePassportData(passportData, skiPem);\n  passportData.passportMetadata = passportMetadata;\n  const dscParsed = parseCertificateSimple(passportData.dsc);\n  passportData.dsc_parsed = dscParsed;\n  if (passportData.passportMetadata.csca) {\n    const cscaParsed = parseCertificateSimple(passportData.passportMetadata.csca);\n    passportData.csca_parsed = cscaParsed;\n  }\n  return passportData;\n}\n\nexport function pad(hashFunction: (typeof hashAlgos)[number]) {\n  return hashFunction === 'sha1' || hashFunction === 'sha224' || hashFunction === 'sha256'\n    ? shaPad\n    : sha384_512Pad;\n}\n\nexport function padWithZeroes(bytes: number[], length: number) {\n  return bytes.concat(new Array(length - bytes.length).fill(0));\n}\n","export type Country3LetterCode = keyof typeof countryCodes;\nexport type document_type = 'passport' | 'id_card';\nexport type hashAlgosTypes = 'sha512' | 'sha384' | 'sha256' | 'sha224' | 'sha1';\nexport const API_URL = 'https://api.self.xyz';\nexport const API_URL_STAGING = 'https://api.staging.self.xyz';\n\nexport const CHAIN_NAME = 'celo';\n\n// possible values because of sha1 constaints: 192,320,384, 448, 576, 640\nexport const CIRCUIT_CONSTANTS = {\n  REGISTER_NULLIFIER_INDEX: 0,\n  REGISTER_COMMITMENT_INDEX: 1,\n  REGISTER_MERKLE_ROOT_INDEX: 2,\n\n  DSC_TREE_LEAF_INDEX: 0,\n  DSC_CSCA_ROOT_INDEX: 1,\n\n  VC_AND_DISCLOSE_REVEALED_DATA_PACKED_INDEX: 0,\n  VC_AND_DISCLOSE_FORBIDDEN_COUNTRIES_LIST_PACKED_INDEX: 3,\n  VC_AND_DISCLOSE_NULLIFIER_INDEX: 7,\n  VC_AND_DISCLOSE_ATTESTATION_ID_INDEX: 8,\n  VC_AND_DISCLOSE_MERKLE_ROOT_INDEX: 9,\n  VC_AND_DISCLOSE_CURRENT_DATE_INDEX: 10,\n  VC_AND_DISCLOSE_PASSPORT_NO_SMT_ROOT_INDEX: 16,\n  VC_AND_DISCLOSE_NAME_DOB_SMT_ROOT_INDEX: 17,\n  VC_AND_DISCLOSE_NAME_YOB_SMT_ROOT_INDEX: 18,\n  VC_AND_DISCLOSE_SCOPE_INDEX: 19,\n  VC_AND_DISCLOSE_USER_IDENTIFIER_INDEX: 20,\n};\n\nexport const CIRCUIT_TYPES = ['dsc', 'register', 'vc_and_disclose'];\n\nexport const COMMITMENT_TREE_DEPTH = 33;\n\nexport const CSCA_TREE_DEPTH = 12;\n\nexport const CSCA_TREE_URL = 'https://tree.self.xyz/csca';\n\nexport const CSCA_TREE_URL_ID_CARD = 'https://tree.self.xyz/csca-id';\n\nexport const CSCA_TREE_URL_STAGING = 'https://tree.staging.self.xyz/csca';\n\nexport const CSCA_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/csca-id';\n\nexport const DEFAULT_MAJORITY = '18';\n\nexport const DEFAULT_RPC_URL = 'https://mainnet.optimism.io';\n\nexport const DEFAULT_USER_ID_TYPE = 'uuid';\n\nexport const DEVELOPMENT_MODE = true;\n\nexport const DSC_TREE_DEPTH = 21;\n\nexport const DSC_TREE_URL = 'https://tree.self.xyz/dsc';\n\nexport const DSC_TREE_URL_ID_CARD = 'https://tree.self.xyz/dsc-id';\n\nexport const DSC_TREE_URL_STAGING = 'https://tree.staging.self.xyz/dsc';\n\nexport const DSC_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/dsc-id';\n\nexport enum DscVerifierId {\n  dsc_sha1_ecdsa_brainpoolP256r1 = 0,\n  dsc_sha1_rsa_65537_4096 = 1,\n  dsc_sha256_ecdsa_brainpoolP256r1 = 2,\n  dsc_sha256_ecdsa_brainpoolP384r1 = 3,\n  dsc_sha256_ecdsa_secp256r1 = 4,\n  dsc_sha256_ecdsa_secp384r1 = 5,\n  dsc_sha256_ecdsa_secp521r1 = 6,\n  dsc_sha256_rsa_65537_4096 = 7,\n  dsc_sha256_rsapss_3_32_3072 = 8,\n  dsc_sha256_rsapss_65537_32_3072 = 9,\n  dsc_sha256_rsapss_65537_32_4096 = 10,\n  dsc_sha384_ecdsa_brainpoolP384r1 = 11,\n  dsc_sha384_ecdsa_brainpoolP512r1 = 12,\n  dsc_sha384_ecdsa_secp384r1 = 13,\n  dsc_sha512_ecdsa_brainpoolP512r1 = 14,\n  dsc_sha512_ecdsa_secp521r1 = 15,\n  dsc_sha512_rsa_65537_4096 = 16,\n  dsc_sha512_rsapss_65537_64_4096 = 17,\n  dsc_sha256_rsapss_3_32_4096 = 18,\n  dsc_sha1_ecdsa_secp256r1 = 19,\n}\n\nexport const ECDSA_K_LENGTH_FACTOR = 2;\n\nexport const IDENTITY_TREE_URL = 'https://tree.self.xyz/identity';\n\n//\"8518753152044246090169372947057357973469996808638122125210848696986717482788\"\nexport const IDENTITY_TREE_URL_ID_CARD = 'https://tree.self.xyz/identity-id';\n\nexport const IDENTITY_TREE_URL_STAGING = 'https://tree.staging.self.xyz/identity';\n\nexport const IDENTITY_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/identity-id';\n\nexport const ID_CARD_ATTESTATION_ID = '2';\n\nexport const MAX_BYTES_IN_FIELD = 31;\n\nexport const MAX_CERT_BYTES: Partial<Record<keyof typeof SignatureAlgorithmIndex, number>> = {\n  rsa_sha256_65537_4096: 512,\n  rsa_sha1_65537_4096: 640,\n  rsapss_sha256_65537_2048: 640,\n  rsapss_sha256_65537_3072: 640,\n  rsapss_sha256_65537_4096: 768,\n  rsapss_sha256_3_3072: 768,\n  rsapss_sha256_3_4096: 768,\n  rsapss_sha384_65537_3072: 768,\n};\n\n/**\n * Maximum number of countries in the forbidden countries list.\n *\n * IMPORTANT: This value must match in both backend and frontend SDK.\n * Any mismatch will result in an INVALID_FORBIDDEN_COUNTRIES error.\n */\nexport const MAX_DATAHASHES_LEN = 320;\n\nexport const MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n\nexport const MAX_PADDED_ECONTENT_LEN: Partial<Record<(typeof hashAlgos)[number], number>> = {\n  sha1: 384,\n  sha224: 512,\n  sha256: 512,\n  sha384: 768,\n  sha512: 896,\n};\n\nexport const MAX_PADDED_SIGNED_ATTR_LEN: Record<(typeof hashAlgos)[number], number> = {\n  sha1: 128,\n  sha224: 128,\n  sha256: 128,\n  sha384: 256,\n  sha512: 256,\n};\n\n// Note: Circuit lists are now managed through RegisterVerifierId and DscVerifierId enums below\n// instead of separate arrays for better type safety and maintainability\nexport const MAX_PUBKEY_DSC_BYTES = 525;\n\nexport const OFAC_TREE_LEVELS = 64;\n\n// we make it global here because passing it to generateCircuitInputsRegister caused trouble\nexport const PASSPORT_ATTESTATION_ID = '1';\n\nexport const PCR0_MANAGER_ADDRESS = '0xE36d4EE5Fd3916e703A46C21Bb3837dB7680C8B8';\n\nexport const REDIRECT_URL = 'https://redirect.self.xyz';\n\nexport const REGISTER_CONTRACT_ADDRESS = '0x3F346FFdC5d583e4126AF01A02Ac5b9CdB3f1909';\n\nexport const RPC_URL = 'https://forno.celo.org';\n\nexport enum RegisterVerifierId {\n  register_sha256_sha256_sha256_rsa_65537_4096 = 0,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 1,\n  register_sha256_sha256_sha256_ecdsa_secp256r1 = 2,\n  register_sha256_sha256_sha256_ecdsa_secp384r1 = 3,\n  register_sha256_sha256_sha256_rsa_3_4096 = 4,\n  register_sha256_sha256_sha256_rsapss_3_32_2048 = 5,\n  register_sha256_sha256_sha256_rsapss_65537_32_2048 = 6,\n  register_sha256_sha256_sha256_rsapss_65537_32_3072 = 7,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 8,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 9,\n  register_sha384_sha384_sha384_ecdsa_secp384r1 = 10,\n  register_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 11,\n  register_sha512_sha512_sha512_rsa_65537_4096 = 12,\n  register_sha512_sha512_sha512_rsapss_65537_64_2048 = 13,\n  register_sha1_sha1_sha1_rsa_65537_4096 = 14,\n  register_sha1_sha256_sha256_rsa_65537_4096 = 15,\n  register_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 16,\n  register_sha256_sha224_sha224_ecdsa_secp224r1 = 17,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 18,\n  register_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 19,\n  register_sha384_sha384_sha384_rsapss_65537_48_2048 = 20,\n  register_sha1_sha1_sha1_ecdsa_secp256r1 = 21,\n  register_sha256_sha256_sha256_rsapss_65537_64_2048 = 22,\n  register_sha512_sha512_sha256_rsa_65537_4096 = 23,\n  register_sha512_sha512_sha512_ecdsa_secp521r1 = 24,\n  register_id_sha256_sha256_sha256_rsa_65537_4096 = 25,\n  register_sha256_sha256_sha224_ecdsa_secp224r1 = 26,\n  register_id_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 27,\n  register_id_sha1_sha1_sha1_ecdsa_secp256r1 = 28,\n  register_id_sha1_sha1_sha1_rsa_65537_4096 = 29,\n  register_id_sha1_sha256_sha256_rsa_65537_4096 = 30,\n  register_id_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 31,\n  register_id_sha256_sha224_sha224_ecdsa_secp224r1 = 32,\n  register_id_sha256_sha256_sha224_ecdsa_secp224r1 = 33,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 34,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 35,\n  register_id_sha256_sha256_sha256_ecdsa_secp256r1 = 36,\n  register_id_sha256_sha256_sha256_ecdsa_secp384r1 = 37,\n  register_id_sha256_sha256_sha256_rsa_3_4096 = 38,\n  register_id_sha256_sha256_sha256_rsapss_3_32_2048 = 39,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_2048 = 40,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_3072 = 41,\n  register_id_sha256_sha256_sha256_rsapss_65537_64_2048 = 42,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 43,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 44,\n  register_id_sha384_sha384_sha384_ecdsa_secp384r1 = 45,\n  register_id_sha384_sha384_sha384_rsapss_65537_48_2048 = 46,\n  register_id_sha512_sha512_sha256_rsa_65537_4096 = 47,\n  register_id_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 48,\n  register_id_sha512_sha512_sha512_ecdsa_secp521r1 = 49,\n  register_id_sha512_sha512_sha512_rsa_65537_4096 = 50,\n  register_id_sha512_sha512_sha512_rsapss_65537_64_2048 = 51,\n}\n\nexport const SBT_CONTRACT_ADDRESS = '0x601Fd54FD11C5E77DE84d877e55B829aff20f0A6';\n\nexport enum SignatureAlgorithmIndex {\n  rsa_sha256_65537_2048 = 1,\n  rsa_sha1_65537_2048 = 3,\n  rsapss_sha256_65537_2048 = 4,\n  ecdsa_sha1_secp256r1_256 = 7,\n  ecdsa_sha256_secp256r1_256 = 8,\n  ecdsa_sha384_secp384r1_384 = 9,\n  rsa_sha256_65537_4096 = 10,\n  rsa_sha1_65537_4096 = 11,\n  rsapss_sha256_65537_4096 = 12,\n  rsa_sha256_3_2048 = 13,\n  rsa_sha256_65537_3072 = 14,\n  rsa_sha512_65537_4096 = 15,\n  rsapss_sha256_3_3072 = 16,\n  rsapss_sha256_3_4096 = 17,\n  rsapss_sha384_65537_3072 = 18,\n  rsapss_sha256_65537_3072 = 19,\n  ecdsa_sha256_brainpoolP256r1_256 = 21,\n  ecdsa_sha384_brainpoolP384r1_384 = 22,\n  ecdsa_sha256_secp384r1_384 = 23,\n  ecdsa_sha384_brainpoolP256r1_256 = 24,\n  ecdsa_sha512_brainpoolP256r1_256 = 25,\n  ecdsa_sha512_brainpoolP384r1_384 = 26,\n  ecdsa_sha1_brainpoolP224r1_224 = 27,\n  ecdsa_sha256_brainpoolP224r1_224 = 28,\n  ecdsa_sha512_brainpoolP512r1_512 = 29,\n  ecdsa_sha224_brainpoolP224r1_224 = 30,\n  rsa_sha256_3_4096 = 32,\n  rsa_sha1_3_4096 = 33,\n  rsa_sha384_65537_4096 = 34,\n  rsapss_sha384_65537_4096 = 35,\n  ecdsa_sha1_brainpoolP256r1_256 = 36,\n  ecdsa_sha512_secp521r1_521 = 41,\n}\n\nexport const TREE_TRACKER_URL = 'https://tree.self.xyz';\n\nexport const TREE_URL = 'https://tree.self.xyz';\nexport const TREE_URL_STAGING = 'https://tree.staging.self.xyz';\n\nexport const WS_DB_RELAYER = 'wss://websocket.self.xyz';\n\nexport const WS_DB_RELAYER_STAGING = 'wss://websocket.staging.self.xyz';\n\nexport const WS_RPC_URL_VC_AND_DISCLOSE = 'ws://disclose.proving.self.xyz:8888/';\n\nexport const attributeToPosition = {\n  issuing_state: [2, 4],\n  name: [5, 43],\n  passport_number: [44, 52],\n  nationality: [54, 56],\n  date_of_birth: [57, 62],\n  gender: [64, 64],\n  expiry_date: [65, 70],\n  older_than: [88, 89],\n  ofac: [90, 90],\n};\nexport const attributeToPosition_ID = {\n  issuing_state: [2, 4],\n  name: [60, 89],\n  passport_number: [5, 13],\n  nationality: [45, 47],\n  date_of_birth: [30, 35],\n  gender: [37, 37],\n  expiry_date: [38, 43],\n  older_than: [90, 91],\n  ofac: [92, 92],\n};\n\nexport const circuitNameFromMode = {\n  prove: 'prove',\n  prove_onchain: 'prove',\n  prove_offchain: 'prove',\n  register: 'prove',\n  vc_and_disclose: 'vc_and_disclose',\n  dsc: 'dsc',\n};\nexport const circuitToSelectorMode = {\n  register: [0, 0],\n  prove_onchain: [1, 0],\n  prove_offchain: [1, 1],\n};\n\nexport const contribute_publicKey = `-----BEGIN RSA PUBLIC KEY-----\nMIICCgKCAgEAv/hm7FZZ2KBmaeDHmLoRwuWmCcNKT561RqbsW8ZuYSyPWJUldE9U\nCf0lW3K1H5lsSDkl0Cq84cooL9f6X59Mffb/N24ZKTdL0xdcPwjk4LbcrVm8qubL\n0a/4uCNoZZ1my4nxbpLxYtbr8CNmUGvBOVKf8IcjsY6VghIZrO63G6BN/G44su1Z\nWcHpboGt9SDQK4enCyKxnCD+PbDYlewSA0n3GRajFfZex1bj1EvrS2hTLv8oNH5e\n9H+3TUke0uO6Ttl0bZepoMmPlpAXhJByISqC6SLth4WFIH+G1I/xt9AEM7hOfLMl\nKQv/3wlLEgEueRryKAHB2tqkaDKVJyw+tOyWj2iWA+nVgQKAxO4hOw01ljyVbcx6\nKboXwnamlZPFIx4tjEaZ+ClXCFqvXhE9LDFK11QsYzJZl0aRVfTNqcurhEt7SK0f\nqzOBhID0Nxk4k9sW1uT6ocW1xp1SB2WotORssOKIAOLJM8IbPl6n/DkYNcfvyXI7\n4BlUrf6M2DgZMYATabIy94AvopHJOyiRfh4NpQPDntWnShiI1em2MmtXiWFCdVFV\n6/QfJTKVixJpVfDh386ALXc97EPWDMWIalUwYoV/eRSMnuV8nZ0+Ctp3Qrtk/JYd\n+FWhKbtlPeRjmGVr6mVlvDJ7KqtY5/RqqwfWeXhXezGhQqQ/OoQQCRkCAwEAAQ==\n-----END RSA PUBLIC KEY-----`;\n\n// not using a library for this as the entry countries use can be differnt than the ISO 3166-1 alpha-3 standard\nexport const countryCodes = {\n  AFG: 'Afghanistan',\n  ALA: 'Aland Islands',\n  ALB: 'Albania',\n  DZA: 'Algeria',\n  ASM: 'American Samoa',\n  AND: 'Andorra',\n  AGO: 'Angola',\n  AIA: 'Anguilla',\n  ATA: 'Antarctica',\n  ATG: 'Antigua and Barbuda',\n  ARG: 'Argentina',\n  ARM: 'Armenia',\n  ABW: 'Aruba',\n  AUS: 'Australia',\n  AUT: 'Austria',\n  AZE: 'Azerbaijan',\n  BHS: 'Bahamas',\n  BHR: 'Bahrain',\n  BGD: 'Bangladesh',\n  BRB: 'Barbados',\n  BLR: 'Belarus',\n  BEL: 'Belgium',\n  BLZ: 'Belize',\n  BEN: 'Benin',\n  BMU: 'Bermuda',\n  BTN: 'Bhutan',\n  BOL: 'Bolivia (Plurinational State of)',\n  BES: 'Bonaire, Sint Eustatius and Saba',\n  BIH: 'Bosnia and Herzegovina',\n  BWA: 'Botswana',\n  BVT: 'Bouvet Island',\n  BRA: 'Brazil',\n  IOT: 'British Indian Ocean Territory',\n  BRN: 'Brunei Darussalam',\n  BGR: 'Bulgaria',\n  BFA: 'Burkina Faso',\n  BDI: 'Burundi',\n  CPV: 'Cabo Verde',\n  KHM: 'Cambodia',\n  CMR: 'Cameroon',\n  CAN: 'Canada',\n  CYM: 'Cayman Islands',\n  CAF: 'Central African Republic',\n  TCD: 'Chad',\n  CHL: 'Chile',\n  CHN: 'China',\n  CXR: 'Christmas Island',\n  CCK: 'Cocos (Keeling) Islands',\n  COL: 'Colombia',\n  COM: 'Comoros',\n  COG: 'Congo',\n  COD: 'Congo, Democratic Republic of the',\n  COK: 'Cook Islands',\n  CRI: 'Costa Rica',\n  CIV: \"Cote d'Ivoire\",\n  HRV: 'Croatia',\n  CUB: 'Cuba',\n  CUW: 'Curacao',\n  CYP: 'Cyprus',\n  CZE: 'Czechia',\n  DNK: 'Denmark',\n  DJI: 'Djibouti',\n  DMA: 'Dominica',\n  DOM: 'Dominican Republic',\n  ECU: 'Ecuador',\n  EGY: 'Egypt',\n  SLV: 'El Salvador',\n  GNQ: 'Equatorial Guinea',\n  ERI: 'Eritrea',\n  EST: 'Estonia',\n  SWZ: 'Eswatini',\n  ETH: 'Ethiopia',\n  FLK: 'Falkland Islands (Malvinas)',\n  FRO: 'Faroe Islands',\n  FJI: 'Fiji',\n  FIN: 'Finland',\n  FRA: 'France',\n  GUF: 'French Guiana',\n  PYF: 'French Polynesia',\n  ATF: 'French Southern Territories',\n  GAB: 'Gabon',\n  GMB: 'Gambia',\n  GEO: 'Georgia',\n  DEU: 'Germany',\n  'D<<': 'Germany', // Bundesrepublik Deutschland uses this in passports instead of DEU\n  GHA: 'Ghana',\n  GIB: 'Gibraltar',\n  GRC: 'Greece',\n  GRL: 'Greenland',\n  GRD: 'Grenada',\n  GLP: 'Guadeloupe',\n  GUM: 'Guam',\n  GTM: 'Guatemala',\n  GGY: 'Guernsey',\n  GIN: 'Guinea',\n  GNB: 'Guinea-Bissau',\n  GUY: 'Guyana',\n  HTI: 'Haiti',\n  HMD: 'Heard Island and McDonald Islands',\n  VAT: 'Holy See',\n  HND: 'Honduras',\n  HKG: 'Hong Kong',\n  HUN: 'Hungary',\n  ISL: 'Iceland',\n  IND: 'India',\n  IDN: 'Indonesia',\n  IRN: 'Iran (Islamic Republic of)',\n  IRQ: 'Iraq',\n  IRL: 'Ireland',\n  IMN: 'Isle of Man',\n  ISR: 'Israel',\n  ITA: 'Italy',\n  JAM: 'Jamaica',\n  JPN: 'Japan',\n  JEY: 'Jersey',\n  JOR: 'Jordan',\n  KAZ: 'Kazakhstan',\n  KEN: 'Kenya',\n  KIR: 'Kiribati',\n  PRK: \"Korea (Democratic People's Republic of)\",\n  KOR: 'Korea, Republic of',\n  KWT: 'Kuwait',\n  KGZ: 'Kyrgyzstan',\n  LAO: \"Lao People's Democratic Republic\",\n  LVA: 'Latvia',\n  LBN: 'Lebanon',\n  LSO: 'Lesotho',\n  LBR: 'Liberia',\n  LBY: 'Libya',\n  LIE: 'Liechtenstein',\n  LTU: 'Lithuania',\n  LUX: 'Luxembourg',\n  MAC: 'Macao',\n  MDG: 'Madagascar',\n  MWI: 'Malawi',\n  MYS: 'Malaysia',\n  MDV: 'Maldives',\n  MLI: 'Mali',\n  MLT: 'Malta',\n  MHL: 'Marshall Islands',\n  MTQ: 'Martinique',\n  MRT: 'Mauritania',\n  MUS: 'Mauritius',\n  MYT: 'Mayotte',\n  MEX: 'Mexico',\n  FSM: 'Micronesia (Federated States of)',\n  MDA: 'Moldova, Republic of',\n  MCO: 'Monaco',\n  MNG: 'Mongolia',\n  MNE: 'Montenegro',\n  MSR: 'Montserrat',\n  MAR: 'Morocco',\n  MOZ: 'Mozambique',\n  MMR: 'Myanmar',\n  NAM: 'Namibia',\n  NRU: 'Nauru',\n  NPL: 'Nepal',\n  NLD: 'Netherlands',\n  NCL: 'New Caledonia',\n  NZL: 'New Zealand',\n  NIC: 'Nicaragua',\n  NER: 'Niger',\n  NGA: 'Nigeria',\n  NIU: 'Niue',\n  NFK: 'Norfolk Island',\n  MKD: 'North Macedonia',\n  MNP: 'Northern Mariana Islands',\n  NOR: 'Norway',\n  OMN: 'Oman',\n  PAK: 'Pakistan',\n  PLW: 'Palau',\n  PSE: 'Palestine, State of',\n  PAN: 'Panama',\n  PNG: 'Papua New Guinea',\n  PRY: 'Paraguay',\n  PER: 'Peru',\n  PHL: 'Philippines',\n  PCN: 'Pitcairn',\n  POL: 'Poland',\n  PRT: 'Portugal',\n  PRI: 'Puerto Rico',\n  QAT: 'Qatar',\n  REU: 'Reunion',\n  ROU: 'Romania',\n  RUS: 'Russian Federation',\n  RWA: 'Rwanda',\n  BLM: 'Saint Barthelemy',\n  SHN: 'Saint Helena, Ascension and Tristan da Cunha',\n  KNA: 'Saint Kitts and Nevis',\n  LCA: 'Saint Lucia',\n  MAF: 'Saint Martin (French part)',\n  SPM: 'Saint Pierre and Miquelon',\n  VCT: 'Saint Vincent and the Grenadines',\n  WSM: 'Samoa',\n  SMR: 'San Marino',\n  STP: 'Sao Tome and Principe',\n  SAU: 'Saudi Arabia',\n  SEN: 'Senegal',\n  SRB: 'Serbia',\n  SYC: 'Seychelles',\n  SLE: 'Sierra Leone',\n  SGP: 'Singapore',\n  SXM: 'Sint Maarten (Dutch part)',\n  SVK: 'Slovakia',\n  SVN: 'Slovenia',\n  SLB: 'Solomon Islands',\n  SOM: 'Somalia',\n  ZAF: 'South Africa',\n  SGS: 'South Georgia and the South Sandwich Islands',\n  SSD: 'South Sudan',\n  ESP: 'Spain',\n  LKA: 'Sri Lanka',\n  SDN: 'Sudan',\n  SUR: 'Suriname',\n  SJM: 'Svalbard and Jan Mayen',\n  SWE: 'Sweden',\n  CHE: 'Switzerland',\n  SYR: 'Syrian Arab Republic',\n  TWN: 'Taiwan, Province of China',\n  TJK: 'Tajikistan',\n  TZA: 'Tanzania, United Republic of',\n  THA: 'Thailand',\n  TLS: 'Timor-Leste',\n  TGO: 'Togo',\n  TKL: 'Tokelau',\n  TON: 'Tonga',\n  TTO: 'Trinidad and Tobago',\n  TUN: 'Tunisia',\n  TUR: 'Turkey',\n  TKM: 'Turkmenistan',\n  TCA: 'Turks and Caicos Islands',\n  TUV: 'Tuvalu',\n  UGA: 'Uganda',\n  UKR: 'Ukraine',\n  ARE: 'United Arab Emirates',\n  GBR: 'United Kingdom of Great Britain and Northern Ireland',\n  USA: 'United States of America',\n  UMI: 'United States Minor Outlying Islands',\n  URY: 'Uruguay',\n  UZB: 'Uzbekistan',\n  VUT: 'Vanuatu',\n  VEN: 'Venezuela (Bolivarian Republic of)',\n  VNM: 'Viet Nam',\n  VGB: 'Virgin Islands (British)',\n  VIR: 'Virgin Islands (U.S.)',\n  WLF: 'Wallis and Futuna',\n  ESH: 'Western Sahara',\n  YEM: 'Yemen',\n  ZMB: 'Zambia',\n  ZWE: 'Zimbabwe',\n};\n\nexport function getCountryCode(countryName: string): string {\n  const entries = Object.entries(countryCodes);\n  const found = entries.find(([_, name]) => name.toLowerCase() === countryName.toLowerCase());\n  return found ? found[0] : 'undefined';\n}\n\nexport const hashAlgos = ['sha512', 'sha384', 'sha256', 'sha224', 'sha1'];\n\nexport const k_csca = 35;\n\nexport const k_dsc = 35;\n\n//48;\nexport const k_dsc_3072 = 35;\n\nexport const k_dsc_4096 = 35;\n\nexport const k_dsc_ecdsa = 4;\n\nexport const max_csca_bytes = 1792;\n\nexport const max_dsc_bytes = 1792;\n\nexport const n_csca = 120;\n\nexport const n_dsc = 120;\n\nexport const n_dsc_3072 = 120;\n\nexport const n_dsc_4096 = 120;\n\nexport const n_dsc_ecdsa = 64;\n\n// max formatted and concatenated datagroup hashes length in bytes\nexport const revealedDataTypes = {\n  issuing_state: 0,\n  name: 1,\n  passport_number: 2,\n  nationality: 3,\n  date_of_birth: 4,\n  gender: 5,\n  expiry_date: 6,\n  older_than: 7,\n  passport_no_ofac: 8,\n  name_and_dob_ofac: 9,\n  name_and_yob_ofac: 10,\n};\n\nexport const saltLengths = [64, 48, 32];\n","import { MAX_BYTES_IN_FIELD } from '../constants/constants.js';\n\nexport function bigIntToChunkedBytes(\n  num: BigInt | bigint,\n  bytesPerChunk: number,\n  numChunks: number\n) {\n  const res: string[] = [];\n  const bigintNum: bigint = typeof num == 'bigint' ? num : num.valueOf();\n  const msk = (1n << BigInt(bytesPerChunk)) - 1n;\n  for (let i = 0; i < numChunks; ++i) {\n    res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());\n  }\n  return res;\n}\nexport function bytesToBigDecimal(arr: number[]): string {\n  let result = BigInt(0);\n  for (let i = 0; i < arr.length; i++) {\n    result = result * BigInt(256) + BigInt(arr[i] & 0xff);\n  }\n  return result.toString();\n}\n\nexport function computeIntChunkLength(byteLength: number) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const remain = byteLength % packSize;\n  let numChunks = (byteLength - remain) / packSize;\n  if (remain > 0) {\n    numChunks += 1;\n  }\n  return numChunks;\n}\n\nexport function derToBytes(derValue: string) {\n  const bytes = [];\n  for (let i = 0; i < derValue.length; i++) {\n    bytes.push(derValue.charCodeAt(i));\n  }\n  return bytes;\n}\n\nexport function hexStringToSignedIntArray(hexString: string) {\n  const result = [];\n  for (let i = 0; i < hexString.length; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    result.push(byte > 127 ? byte - 256 : byte);\n  }\n  return result;\n}\n\nexport function hexToBin(n: string): string {\n  let bin = Number(`0x${n[0]}`).toString(2);\n  for (let i = 1; i < n.length; i += 1) {\n    bin += Number(`0x${n[i]}`).toString(2).padStart(4, '0');\n  }\n  return bin;\n}\n\nexport function hexToDecimal(hex: string): string {\n  return BigInt(`0x${hex}`).toString();\n}\n\nexport function hexToSignedBytes(hexString: string): number[] {\n  const bytes = [];\n  for (let i = 0; i < hexString.length - 1; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    bytes.push(byte >= 128 ? byte - 256 : byte);\n  }\n  return bytes;\n}\n\nexport function num2Bits(n: number, inValue: bigint): bigint[] {\n  const out: bigint[] = new Array(n).fill(BigInt(0));\n  let lc1: bigint = BigInt(0);\n  let e2: bigint = BigInt(1);\n\n  for (let i = 0; i < n; i++) {\n    out[i] = (inValue >> BigInt(i)) & BigInt(1);\n\n    if (out[i] !== BigInt(0) && out[i] !== BigInt(1)) {\n      throw new Error('Bit value is not binary.');\n    }\n\n    lc1 += out[i] * e2;\n    e2 = e2 << BigInt(1);\n  }\n\n  if (lc1 !== inValue) {\n    throw new Error('Reconstructed value does not match the input.');\n  }\n  return out;\n}\n\nexport function packBytes(unpacked) {\n  const bytesCount = [31, 31, 31];\n  const packed = [0n, 0n, 0n];\n\n  let byteIndex = 0;\n  for (let i = 0; i < bytesCount.length; i++) {\n    for (let j = 0; j < bytesCount[i]; j++) {\n      if (byteIndex < unpacked.length) {\n        packed[i] |= BigInt(unpacked[byteIndex]) << (BigInt(j) * 8n);\n      }\n      byteIndex++;\n    }\n  }\n  return packed;\n}\n\nexport function packBytesArray(unpacked: number[]) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const maxBytes = unpacked.length;\n  const maxInts = computeIntChunkLength(maxBytes);\n  const out: bigint[] = new Array(maxInts).fill(0n);\n\n  for (let i = 0; i < maxInts; i++) {\n    let sum = 0n;\n    for (let j = 0; j < packSize; j++) {\n      const idx = packSize * i + j;\n\n      // Copy previous value if out of bounds\n      if (idx >= maxBytes) {\n        continue;\n      }\n      // First item of chunk is byte itself\n      else if (j === 0) {\n        sum = BigInt(unpacked[idx]);\n      }\n      // Every other item is 256^j * byte\n      else {\n        sum += (1n << BigInt(8 * j)) * BigInt(unpacked[idx]);\n      }\n    }\n    out[i] = sum;\n  }\n\n  return out;\n}\n\nexport function splitToWords(number: bigint, wordsize: number, numberElement: number) {\n  let t = number;\n  const words: string[] = [];\n  for (let i = 0; i < numberElement; ++i) {\n    const baseTwo = BigInt(2);\n\n    words.push(`${t % BigInt(Math.pow(Number(baseTwo), wordsize))}`);\n    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), wordsize)));\n  }\n  if (!(t == BigInt(0))) {\n    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;\n  }\n  return words;\n}\n\nexport const toBinaryString = (byte: any) => {\n  const binary = (parseInt(byte, 10) & 0xff).toString(2).padStart(8, '0');\n  return binary;\n};\n\nexport function toSigned(byte: number) {\n  return byte > 127 ? byte - 256 : byte;\n}\nexport function toUnsigned(byte: number) {\n  return byte & 0xff;\n}\nexport function toUnsignedByte(signedByte: number) {\n  return signedByte < 0 ? signedByte + 256 : signedByte;\n}\n","import { API_URL, API_URL_STAGING } from '../constants/constants.js';\nimport { SKI_PEM, SKI_PEM_DEV } from '../constants/skiPem.js';\n\nexport function findOIDPosition(\n  oid: string,\n  message: number[]\n): { oid_index: number; oid_length: number } {\n  // Convert OID string like \"1.2.840.113549\" to byte array\n  const oidParts = oid.split('.').map(Number);\n\n  // First byte is 40 * first number + second number\n  const oidBytes = [40 * oidParts[0] + oidParts[1]];\n\n  // Convert remaining parts to ASN.1 DER encoding\n  for (let i = 2; i < oidParts.length; i++) {\n    let value = oidParts[i];\n    const bytes = [];\n\n    // Handle multi-byte values\n    if (value >= 128) {\n      const tempBytes = [];\n      while (value > 0) {\n        tempBytes.unshift(value & 0x7f);\n        value = value >>> 7;\n      }\n      // Set MSB for all bytes except last\n      for (let j = 0; j < tempBytes.length - 1; j++) {\n        bytes.push(tempBytes[j] | 0x80);\n      }\n      bytes.push(tempBytes[tempBytes.length - 1]);\n    } else {\n      bytes.push(value);\n    }\n    oidBytes.push(...bytes);\n  }\n\n  console.log(\n    '\\x1b[33m%s\\x1b[0m',\n    'OID bytes (hex):',\n    oidBytes.map((b) => b.toString(16).padStart(2, '0')).join(' ')\n  );\n\n  // Search for OID in message\n  // OID will be preceded by 0x06 (ASN.1 OID tag) and length byte\n  for (let i = 0; i < message.length - oidBytes.length; i++) {\n    if (message[i] === 0x06) {\n      // OID tag\n      const len = message[i + 1];\n      if (len === oidBytes.length) {\n        let found = true;\n        for (let j = 0; j < len; j++) {\n          if (message[i + 2 + j] !== oidBytes[j]) {\n            found = false;\n            break;\n          }\n        }\n        if (found) {\n          const result = {\n            oid_index: i,\n            oid_length: len + 2, // Add 2 for tag and length bytes\n          };\n          console.log('\\x1b[32m%s\\x1b[0m', 'Found OID at:', result); // Green color\n          return result;\n        }\n      }\n    }\n  }\n\n  throw new Error('OID not found in message');\n}\n\n// @returns [startIndex, length] where startIndex is the index of the first byte of the modulus in the message and length is the length of the modulus in bytes\nexport function findStartIndex(modulus: string, messagePaddedNumber: number[]): [number, number] {\n  const modulusNumArray = [];\n  for (let i = 0; i < modulus.length; i += 2) {\n    const hexPair = modulus.slice(i, i + 2);\n    const number = parseInt(hexPair, 16);\n    modulusNumArray.push(number);\n  }\n\n  // console.log('Modulus length:', modulusNumArray.length);\n  // console.log('Message length:', messagePaddedNumber.length);\n  // console.log('Modulus (hex):', modulusNumArray.map(n => n.toString(16).padStart(2, '0')).join(''));\n  // console.log('Message (hex):', messagePaddedNumber.map(n => n.toString(16).padStart(2, '0')).join(''));\n\n  for (let i = 0; i < messagePaddedNumber.length - modulusNumArray.length + 1; i++) {\n    let matched = true;\n    for (let j = 0; j < modulusNumArray.length; j++) {\n      if (modulusNumArray[j] !== messagePaddedNumber[i + j]) {\n        matched = false;\n        break;\n      }\n    }\n    if (matched) {\n      return [i, modulusNumArray.length];\n    }\n  }\n\n  throw new Error('DSC Pubkey not found in certificate');\n}\n\nexport function findStartIndexEC(point: string, messagePadded: number[]): [number, number] {\n  const pointNumArray = [];\n  for (let i = 0; i < point.length; i += 2) {\n    pointNumArray.push(parseInt(point.slice(i, i + 2), 16));\n  }\n\n  let startIndex = -1;\n\n  for (let i = 0; i < messagePadded.length - pointNumArray.length + 1; i++) {\n    const isMatch = pointNumArray.every((byte, j) => messagePadded[i + j] === byte);\n    if (isMatch) {\n      startIndex = i;\n      break;\n    }\n  }\n\n  if (startIndex === -1) {\n    throw new Error('DSC Pubkey not found in CSCA certificate');\n  }\n  return [startIndex, pointNumArray.length];\n}\n\nexport function getCSCAFromSKI(ski: string, skiPem: any = null): string {\n  const normalizedSki = ski.replace(/\\s+/g, '').toLowerCase();\n  const isSkiProvided = skiPem !== null;\n  console.log('SKI-PEM provided');\n  const cscaPemPROD = (SKI_PEM as any)[normalizedSki];\n  const cscaPemDEV = (SKI_PEM_DEV as any)[normalizedSki];\n  let cscaPem = null;\n  if (isSkiProvided) {\n    cscaPem = skiPem[normalizedSki];\n  } else {\n    cscaPem = cscaPemDEV || cscaPemPROD;\n  }\n  if (!cscaPem) {\n    console.log(\n      '\\x1b[33m%s\\x1b[0m',\n      `[WRN] CSCA with SKI ${ski} not found`,\n      'isSkiProvided: ',\n      isSkiProvided\n    );\n    throw new Error(\n      `CSCA not found, authorityKeyIdentifier: ${ski}, isSkiProvided: ${isSkiProvided}`\n    );\n  }\n  if (!cscaPem.includes('-----BEGIN CERTIFICATE-----')) {\n    cscaPem = `-----BEGIN CERTIFICATE-----\\n${cscaPem}\\n-----END CERTIFICATE-----`;\n  }\n  return cscaPem;\n}\n\nexport async function getSKIPEM(\n  environment: 'staging' | 'production'\n): Promise<{ [key: string]: string }> {\n  const skiPemUrl = (environment === 'staging' ? API_URL_STAGING : API_URL) + '/ski-pem';\n  console.log('Fetching SKI-PEM mapping from:', skiPemUrl);\n  try {\n    const response = await fetch(skiPemUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP error fetching ${skiPemUrl}! status: ${response.status}`);\n    }\n\n    const responseText = await response.text();\n    const jsonData = JSON.parse(responseText);\n\n    if (\n      !jsonData ||\n      typeof jsonData !== 'object' ||\n      !jsonData.data ||\n      typeof jsonData.data !== 'object'\n    ) {\n      console.error('Unexpected JSON structure received:', jsonData);\n      throw new Error('Unexpected JSON structure received from SKI-PEM endpoint.');\n    }\n\n    console.log('Parsed SKI-PEM data received.');\n\n    return jsonData.data;\n  } catch (error) {\n    console.error('Error fetching or parsing ski-pem:', error);\n    throw new Error(\n      `Failed to get SKIPEM: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n","export function assert(cond: boolean, errorMessage: string) {\n  if (!cond) {\n    throw new Error(errorMessage);\n  }\n}\n\n// Works only on 32 bit sha text lengths\nexport function int64toBytes(num: number): Uint8Array {\n  const arr = new ArrayBuffer(8); // an Int32 takes 4 bytes\n  const view = new DataView(arr);\n  view.setInt32(4, num, false); // byteOffset = 0; litteEndian = false\n  return new Uint8Array(arr);\n}\n\n// Helper function to convert 128-bit length to bytes\nfunction int128toBytes(x: number): Uint8Array {\n  const buffer = new ArrayBuffer(16);\n  const view = new DataView(buffer);\n\n  // Write high 64 bits\n  view.setBigUint64(0, BigInt(0), false);\n  // Write low 64 bits\n  view.setBigUint64(8, BigInt(x), false);\n\n  return new Uint8Array(buffer);\n}\n\n// Works only on 32 bit sha text lengths\nexport function int8toBytes(num: number): Uint8Array {\n  const arr = new ArrayBuffer(1); // an Int8 takes 4 bytes\n  const view = new DataView(arr);\n  view.setUint8(0, num); // byteOffset = 0; litteEndian = false\n  return new Uint8Array(arr);\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n  // sum of individual array lengths\n  const mergedArray = new Uint8Array(a1.length + a2.length);\n  mergedArray.set(a1);\n  mergedArray.set(a2, a1.length);\n  return mergedArray;\n}\n\nexport function sha384_512Pad(\n  prehash_prepad_m_array: number[],\n  maxShaBytes: number\n): [number[], number] {\n  let prehash_prepad_m: Uint8Array = new Uint8Array(prehash_prepad_m_array);\n  // Length in bits before padding\n  const length_bits = prehash_prepad_m.length * 8;\n\n  // For SHA-384, length is stored in 128 bits (16 bytes)\n  const length_in_bytes = int128toBytes(length_bits);\n\n  // Add the 1 bit (as a byte with value 128)\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(2 ** 7));\n\n  // Add padding zeros until total length is congruent to 896 mod 1024\n  while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 1024 !== 0) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(0));\n  }\n\n  // Append the length\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, length_in_bytes);\n\n  // Verify padding is correct (multiple of 1024 bits)\n  assert((prehash_prepad_m.length * 8) % 1024 === 0, 'Padding did not complete properly!');\n\n  const messageLen = prehash_prepad_m.length;\n\n  // Pad to max length if needed\n  while (prehash_prepad_m.length < maxShaBytes) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int128toBytes(0));\n  }\n\n  assert(\n    prehash_prepad_m.length === maxShaBytes,\n    `Padding to max length did not complete properly! Your padded message is ${prehash_prepad_m.length} long but max is ${maxShaBytes}!`\n  );\n\n  return [Array.from(prehash_prepad_m), messageLen];\n}\n\n// Copied from zk-email cuz it uses crypto so can't import it here.\n// Puts an end selector, a bunch of 0s, then the length, then fill the rest with 0s.\nexport function shaPad(prehash_prepad_m_array: number[], maxShaBytes: number): [number[], number] {\n  let prehash_prepad_m: Uint8Array = new Uint8Array(prehash_prepad_m_array);\n  const length_bits = prehash_prepad_m.length * 8; // bytes to bits\n  const length_in_bytes = int64toBytes(length_bits);\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(2 ** 7)); // Add the 1 on the end, length 505\n  while ((prehash_prepad_m.length * 8 + length_in_bytes.length * 8) % 512 !== 0) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int8toBytes(0));\n  }\n  prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, length_in_bytes);\n  assert((prehash_prepad_m.length * 8) % 512 === 0, 'Padding did not complete properly!');\n  const messageLen = prehash_prepad_m.length;\n  while (prehash_prepad_m.length < maxShaBytes) {\n    prehash_prepad_m = mergeUInt8Arrays(prehash_prepad_m, int64toBytes(0));\n  }\n  assert(\n    prehash_prepad_m.length === maxShaBytes,\n    `Padding to max length did not complete properly! Your padded message is ${prehash_prepad_m.length} long but max is ${maxShaBytes}!`\n  );\n  return [Array.from(prehash_prepad_m), messageLen];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,YAAuB;AACvB,2BAA0B;;;ACyjBnB,IAAM,SAAS;AAEf,IAAM,QAAQ;AAGd,IAAM,aAAa;AAEnB,IAAM,aAAa;AAEnB,IAAM,cAAc;AAMpB,IAAM,SAAS;AAEf,IAAM,QAAQ;AAEd,IAAM,aAAa;AAEnB,IAAM,aAAa;AAEnB,IAAM,cAAc;;;ACvhBpB,SAAS,aAAa,KAAqB;AAChD,SAAO,OAAO,KAAK,GAAG,EAAE,EAAE,SAAS;AACrC;AA+EO,SAAS,aAAa,QAAgB,UAAkB,eAAuB;AACpF,MAAI,IAAI;AACR,QAAM,QAAkB,CAAC;AACzB,WAAS,IAAI,GAAG,IAAI,eAAe,EAAE,GAAG;AACtC,UAAM,UAAU,OAAO,CAAC;AAExB,UAAM,KAAK,GAAG,IAAI,OAAO,KAAK,IAAI,OAAO,OAAO,GAAG,QAAQ,CAAC,CAAC,EAAE;AAC/D,QAAI,OAAO,IAAI,OAAO,KAAK,IAAI,OAAO,OAAO,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC;AAAA,EAC9D;AACA,MAAI,EAAE,KAAK,OAAO,CAAC,IAAI;AACrB,UAAM,UAAU,MAAM,qBAAqB,WAAW,eAAe,SAAS,CAAC;AAAA,EACjF;AACA,SAAO;AACT;;;AChFO,SAAS,eAAe,SAAiB,qBAAiD;AAC/F,QAAM,kBAAkB,CAAC;AACzB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK,GAAG;AAC1C,UAAM,UAAU,QAAQ,MAAM,GAAG,IAAI,CAAC;AACtC,UAAM,SAAS,SAAS,SAAS,EAAE;AACnC,oBAAgB,KAAK,MAAM;AAAA,EAC7B;AAOA,WAAS,IAAI,GAAG,IAAI,oBAAoB,SAAS,gBAAgB,SAAS,GAAG,KAAK;AAChF,QAAI,UAAU;AACd,aAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC/C,UAAI,gBAAgB,CAAC,MAAM,oBAAoB,IAAI,CAAC,GAAG;AACrD,kBAAU;AACV;AAAA,MACF;AAAA,IACF;AACA,QAAI,SAAS;AACX,aAAO,CAAC,GAAG,gBAAgB,MAAM;AAAA,IACnC;AAAA,EACF;AAEA,QAAM,IAAI,MAAM,qCAAqC;AACvD;AAEO,SAAS,iBAAiB,OAAe,eAA2C;AACzF,QAAM,gBAAgB,CAAC;AACvB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;AACxC,kBAAc,KAAK,SAAS,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;AAAA,EACxD;AAEA,MAAI,aAAa;AAEjB,WAAS,IAAI,GAAG,IAAI,cAAc,SAAS,cAAc,SAAS,GAAG,KAAK;AACxE,UAAM,UAAU,cAAc,MAAM,CAAC,MAAM,MAAM,cAAc,IAAI,CAAC,MAAM,IAAI;AAC9E,QAAI,SAAS;AACX,mBAAa;AACb;AAAA,IACF;AAAA,EACF;AAEA,MAAI,eAAe,IAAI;AACrB,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC5D;AACA,SAAO,CAAC,YAAY,cAAc,MAAM;AAC1C;;;ACzHO,SAAS,OAAO,MAAe,cAAsB;AAC1D,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,YAAY;AAAA,EAC9B;AACF;AAGO,SAAS,aAAa,KAAyB;AACpD,QAAM,MAAM,IAAI,YAAY,CAAC;AAC7B,QAAM,OAAO,IAAI,SAAS,GAAG;AAC7B,OAAK,SAAS,GAAG,KAAK,KAAK;AAC3B,SAAO,IAAI,WAAW,GAAG;AAC3B;AAGA,SAAS,cAAc,GAAuB;AAC5C,QAAM,SAAS,IAAI,YAAY,EAAE;AACjC,QAAM,OAAO,IAAI,SAAS,MAAM;AAGhC,OAAK,aAAa,GAAG,OAAO,CAAC,GAAG,KAAK;AAErC,OAAK,aAAa,GAAG,OAAO,CAAC,GAAG,KAAK;AAErC,SAAO,IAAI,WAAW,MAAM;AAC9B;AAGO,SAAS,YAAY,KAAyB;AACnD,QAAM,MAAM,IAAI,YAAY,CAAC;AAC7B,QAAM,OAAO,IAAI,SAAS,GAAG;AAC7B,OAAK,SAAS,GAAG,GAAG;AACpB,SAAO,IAAI,WAAW,GAAG;AAC3B;AAEO,SAAS,iBAAiB,IAAgB,IAA4B;AAE3E,QAAM,cAAc,IAAI,WAAW,GAAG,SAAS,GAAG,MAAM;AACxD,cAAY,IAAI,EAAE;AAClB,cAAY,IAAI,IAAI,GAAG,MAAM;AAC7B,SAAO;AACT;AAEO,SAAS,cACd,wBACA,aACoB;AACpB,MAAI,mBAA+B,IAAI,WAAW,sBAAsB;AAExE,QAAM,cAAc,iBAAiB,SAAS;AAG9C,QAAM,kBAAkB,cAAc,WAAW;AAGjD,qBAAmB,iBAAiB,kBAAkB,YAAY,KAAK,CAAC,CAAC;AAGzE,UAAQ,iBAAiB,SAAS,IAAI,gBAAgB,SAAS,KAAK,SAAS,GAAG;AAC9E,uBAAmB,iBAAiB,kBAAkB,YAAY,CAAC,CAAC;AAAA,EACtE;AAGA,qBAAmB,iBAAiB,kBAAkB,eAAe;AAGrE,SAAQ,iBAAiB,SAAS,IAAK,SAAS,GAAG,oCAAoC;AAEvF,QAAM,aAAa,iBAAiB;AAGpC,SAAO,iBAAiB,SAAS,aAAa;AAC5C,uBAAmB,iBAAiB,kBAAkB,cAAc,CAAC,CAAC;AAAA,EACxE;AAEA;AAAA,IACE,iBAAiB,WAAW;AAAA,IAC5B,2EAA2E,iBAAiB,MAAM,oBAAoB,WAAW;AAAA,EACnI;AAEA,SAAO,CAAC,MAAM,KAAK,gBAAgB,GAAG,UAAU;AAClD;AAIO,SAAS,OAAO,wBAAkC,aAAyC;AAChG,MAAI,mBAA+B,IAAI,WAAW,sBAAsB;AACxE,QAAM,cAAc,iBAAiB,SAAS;AAC9C,QAAM,kBAAkB,aAAa,WAAW;AAChD,qBAAmB,iBAAiB,kBAAkB,YAAY,KAAK,CAAC,CAAC;AACzE,UAAQ,iBAAiB,SAAS,IAAI,gBAAgB,SAAS,KAAK,QAAQ,GAAG;AAC7E,uBAAmB,iBAAiB,kBAAkB,YAAY,CAAC,CAAC;AAAA,EACtE;AACA,qBAAmB,iBAAiB,kBAAkB,eAAe;AACrE,SAAQ,iBAAiB,SAAS,IAAK,QAAQ,GAAG,oCAAoC;AACtF,QAAM,aAAa,iBAAiB;AACpC,SAAO,iBAAiB,SAAS,aAAa;AAC5C,uBAAmB,iBAAiB,kBAAkB,aAAa,CAAC,CAAC;AAAA,EACvE;AACA;AAAA,IACE,iBAAiB,WAAW;AAAA,IAC5B,2EAA2E,iBAAiB,MAAM,oBAAoB,WAAW;AAAA,EACnI;AACA,SAAO,CAAC,MAAM,KAAK,gBAAgB,GAAG,UAAU;AAClD;;;AJ7CO,SAAS,qBACd,iBACA,SACA,oBACkB;AAClB,QAAM,EAAE,iBAAiB,IAAI;AAC7B,MAAI,uBAAuB,SAAS;AAClC,UAAM,EAAE,GAAG,EAAE,IAAI;AACjB,UAAM,CAAC,SAAS,aAAa,IAAI,iBAAiB,GAAG,OAAO;AAC5D,UAAM,CAAC,SAAS,aAAa,IAAI,iBAAiB,GAAG,OAAO;AAE5D,WAAO,CAAC,SAAS,gBAAgB,aAAa;AAAA,EAChD,OAAO;AAEL,UAAM,EAAE,QAAQ,IAAI;AACpB,WAAO,eAAe,SAAS,OAAO;AAAA,EACxC;AACF;AAGO,SAAS,2BACd,iBACA,oBACU;AACV,QAAM,EAAE,iBAAiB,IAAI;AAC7B,MAAI,uBAAuB,SAAS;AAClC,UAAM,EAAE,GAAG,EAAE,IAAI;AAGjB,UAAM,aAAa,IAAI;AAGvB,WAAO,aAAa,OAAO,aAAa,UAAU,CAAC,GAAG,GAAG,GAAG;AAAA,EAC9D,OAAO;AAEL,UAAM,EAAE,QAAQ,IAAI;AACpB,WAAO,aAAa,OAAO,aAAa,OAAO,CAAC,GAAG,GAAG,GAAG;AAAA,EAC3D;AACF;AAiFO,SAAS,qBACd,iBACA,oBACA,cACK;AACL,QAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,EAAE,GAAG,EAAE,IAAI,SAAS,0BAAgD;AAC1E,QAAM,EAAE,iBAAiB,IAAI;AAC7B,MAAI,uBAAuB,SAAS;AAClC,UAAM,EAAE,GAAG,EAAE,IAAI;AACjB,UAAM,QAAQ,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AACxD,UAAM,QAAQ,aAAa,OAAO,aAAa,CAAC,CAAC,GAAG,GAAG,CAAC;AACxD,WAAO,CAAC,GAAG,OAAO,GAAG,KAAK;AAAA,EAC5B,OAAO;AACL,UAAM,EAAE,QAAQ,IAAI;AACpB,WAAO,aAAa,OAAO,aAAa,OAAO,CAAC,GAAG,GAAG,CAAC;AAAA,EACzD;AACF;AAEO,SAAS,SAAS,QAA4B;AACnD,MAAI,WAAW,yBAAyB;AACtC,WAAO,EAAE,GAAG,YAAY,GAAG,MAAM;AAAA,EACnC;AAEA,MAAI,OAAO,WAAW,QAAQ,GAAG;AAC/B,QAAI,OAAO,SAAS,KAAK,GAAG;AAC1B,aAAO,EAAE,GAAG,IAAI,GAAG,EAAE;AAAA,IACvB,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,aAAa,GAAG,EAAE;AAAA,IAChC,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,aAAa,GAAG,EAAE;AAAA,IAChC,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,aAAa,GAAG,EAAE;AAAA,IAChC,WAAW,OAAO,SAAS,KAAK,GAAG;AACjC,aAAO,EAAE,GAAG,IAAI,GAAG,EAAE;AAAA,IACvB,OAAO;AACL,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AAAA,EACF;AAEA,MAAI,OAAO,WAAW,SAAS,GAAG;AAChC,UAAM,YAAY,SAAS,OAAO,MAAM,GAAG,EAAE,CAAC,CAAC;AAE/C,QAAI,cAAc,MAAM;AACtB,aAAO,EAAE,GAAG,YAAY,GAAG,WAAW;AAAA,IACxC;AAEA,QAAI,cAAc,MAAM;AACtB,aAAO,EAAE,GAAG,YAAY,GAAG,WAAW;AAAA,IACxC;AACA,WAAO,EAAE,GAAG,OAAO,GAAG,MAAM;AAAA,EAC9B;AAEA,MAAI,WAAW,2BAA2B,WAAW,yBAAyB;AAC5E,WAAO,EAAE,GAAG,YAAY,GAAG,WAAW;AAAA,EACxC;AAEA,SAAO,EAAE,GAAG,OAAO,GAAG,MAAM;AAC9B;AAEO,SAAS,aAAa,QAAoC;AAC/D,QAAM,IAAI,WAAW,UAAU,cAAc;AAC7C,QAAM,IAAI,WAAW,UAAU,cAAc;AAC7C,SAAO,EAAE,GAAG,EAAE;AAChB;AA0BO,SAAS,8BACd,iBACA,oBACA,eACQ;AACR,QAAM,EAAE,iBAAiB,IAAI;AAC7B,MAAI,uBAAuB,SAAS;AAClC,WAAO,GAAG,kBAAkB,IAAI,aAAa,IAAK,iBAA2C,KAAK,IAAI,iBAAiB,IAAI;AAAA,EAC7H,OAAO;AACL,UAAM,EAAE,SAAS,IAAI;AACrB,WAAO,GAAG,kBAAkB,IAAI,aAAa,IAAI,QAAQ,IAAI,iBAAiB,IAAI;AAAA,EACpF;AACF;AAeO,SAAS,IAAI,cAA0C;AAC5D,SAAO,iBAAiB,UAAU,iBAAiB,YAAY,iBAAiB,WAC5E,SACA;AACN;AAEO,SAAS,cAAc,OAAiB,QAAgB;AAC7D,SAAO,MAAM,OAAO,IAAI,MAAM,SAAS,MAAM,MAAM,EAAE,KAAK,CAAC,CAAC;AAC9D;","names":[]}