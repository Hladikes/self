{"version":3,"sources":["../../../../../src/utils/circuits/ofacInputs.ts","../../../../../src/constants/constants.ts","../../../../../src/utils/passports/format.ts","../../../../../src/utils/trees.ts","../../../../../src/utils/circuits/generateInputs.ts"],"sourcesContent":["export { generateCircuitInputsOfac } from './generateInputs.js';\n","export type Country3LetterCode = keyof typeof countryCodes;\nexport type document_type = 'passport' | 'id_card';\nexport type hashAlgosTypes = 'sha512' | 'sha384' | 'sha256' | 'sha224' | 'sha1';\nexport const API_URL = 'https://api.self.xyz';\nexport const API_URL_STAGING = 'https://api.staging.self.xyz';\n\nexport const CHAIN_NAME = 'celo';\n\n// possible values because of sha1 constaints: 192,320,384, 448, 576, 640\nexport const CIRCUIT_CONSTANTS = {\n  REGISTER_NULLIFIER_INDEX: 0,\n  REGISTER_COMMITMENT_INDEX: 1,\n  REGISTER_MERKLE_ROOT_INDEX: 2,\n\n  DSC_TREE_LEAF_INDEX: 0,\n  DSC_CSCA_ROOT_INDEX: 1,\n\n  VC_AND_DISCLOSE_REVEALED_DATA_PACKED_INDEX: 0,\n  VC_AND_DISCLOSE_FORBIDDEN_COUNTRIES_LIST_PACKED_INDEX: 3,\n  VC_AND_DISCLOSE_NULLIFIER_INDEX: 7,\n  VC_AND_DISCLOSE_ATTESTATION_ID_INDEX: 8,\n  VC_AND_DISCLOSE_MERKLE_ROOT_INDEX: 9,\n  VC_AND_DISCLOSE_CURRENT_DATE_INDEX: 10,\n  VC_AND_DISCLOSE_PASSPORT_NO_SMT_ROOT_INDEX: 16,\n  VC_AND_DISCLOSE_NAME_DOB_SMT_ROOT_INDEX: 17,\n  VC_AND_DISCLOSE_NAME_YOB_SMT_ROOT_INDEX: 18,\n  VC_AND_DISCLOSE_SCOPE_INDEX: 19,\n  VC_AND_DISCLOSE_USER_IDENTIFIER_INDEX: 20,\n};\n\nexport const CIRCUIT_TYPES = ['dsc', 'register', 'vc_and_disclose'];\n\nexport const COMMITMENT_TREE_DEPTH = 33;\n\nexport const CSCA_TREE_DEPTH = 12;\n\nexport const CSCA_TREE_URL = 'https://tree.self.xyz/csca';\n\nexport const CSCA_TREE_URL_ID_CARD = 'https://tree.self.xyz/csca-id';\n\nexport const CSCA_TREE_URL_STAGING = 'https://tree.staging.self.xyz/csca';\n\nexport const CSCA_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/csca-id';\n\nexport const DEFAULT_MAJORITY = '18';\n\nexport const DEFAULT_RPC_URL = 'https://mainnet.optimism.io';\n\nexport const DEFAULT_USER_ID_TYPE = 'uuid';\n\nexport const DEVELOPMENT_MODE = true;\n\nexport const DSC_TREE_DEPTH = 21;\n\nexport const DSC_TREE_URL = 'https://tree.self.xyz/dsc';\n\nexport const DSC_TREE_URL_ID_CARD = 'https://tree.self.xyz/dsc-id';\n\nexport const DSC_TREE_URL_STAGING = 'https://tree.staging.self.xyz/dsc';\n\nexport const DSC_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/dsc-id';\n\nexport enum DscVerifierId {\n  dsc_sha1_ecdsa_brainpoolP256r1 = 0,\n  dsc_sha1_rsa_65537_4096 = 1,\n  dsc_sha256_ecdsa_brainpoolP256r1 = 2,\n  dsc_sha256_ecdsa_brainpoolP384r1 = 3,\n  dsc_sha256_ecdsa_secp256r1 = 4,\n  dsc_sha256_ecdsa_secp384r1 = 5,\n  dsc_sha256_ecdsa_secp521r1 = 6,\n  dsc_sha256_rsa_65537_4096 = 7,\n  dsc_sha256_rsapss_3_32_3072 = 8,\n  dsc_sha256_rsapss_65537_32_3072 = 9,\n  dsc_sha256_rsapss_65537_32_4096 = 10,\n  dsc_sha384_ecdsa_brainpoolP384r1 = 11,\n  dsc_sha384_ecdsa_brainpoolP512r1 = 12,\n  dsc_sha384_ecdsa_secp384r1 = 13,\n  dsc_sha512_ecdsa_brainpoolP512r1 = 14,\n  dsc_sha512_ecdsa_secp521r1 = 15,\n  dsc_sha512_rsa_65537_4096 = 16,\n  dsc_sha512_rsapss_65537_64_4096 = 17,\n  dsc_sha256_rsapss_3_32_4096 = 18,\n  dsc_sha1_ecdsa_secp256r1 = 19,\n}\n\nexport const ECDSA_K_LENGTH_FACTOR = 2;\n\nexport const IDENTITY_TREE_URL = 'https://tree.self.xyz/identity';\n\n//\"8518753152044246090169372947057357973469996808638122125210848696986717482788\"\nexport const IDENTITY_TREE_URL_ID_CARD = 'https://tree.self.xyz/identity-id';\n\nexport const IDENTITY_TREE_URL_STAGING = 'https://tree.staging.self.xyz/identity';\n\nexport const IDENTITY_TREE_URL_STAGING_ID_CARD = 'https://tree.staging.self.xyz/identity-id';\n\nexport const ID_CARD_ATTESTATION_ID = '2';\n\nexport const MAX_BYTES_IN_FIELD = 31;\n\nexport const MAX_CERT_BYTES: Partial<Record<keyof typeof SignatureAlgorithmIndex, number>> = {\n  rsa_sha256_65537_4096: 512,\n  rsa_sha1_65537_4096: 640,\n  rsapss_sha256_65537_2048: 640,\n  rsapss_sha256_65537_3072: 640,\n  rsapss_sha256_65537_4096: 768,\n  rsapss_sha256_3_3072: 768,\n  rsapss_sha256_3_4096: 768,\n  rsapss_sha384_65537_3072: 768,\n};\n\n/**\n * Maximum number of countries in the forbidden countries list.\n *\n * IMPORTANT: This value must match in both backend and frontend SDK.\n * Any mismatch will result in an INVALID_FORBIDDEN_COUNTRIES error.\n */\nexport const MAX_DATAHASHES_LEN = 320;\n\nexport const MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n\nexport const MAX_PADDED_ECONTENT_LEN: Partial<Record<(typeof hashAlgos)[number], number>> = {\n  sha1: 384,\n  sha224: 512,\n  sha256: 512,\n  sha384: 768,\n  sha512: 896,\n};\n\nexport const MAX_PADDED_SIGNED_ATTR_LEN: Record<(typeof hashAlgos)[number], number> = {\n  sha1: 128,\n  sha224: 128,\n  sha256: 128,\n  sha384: 256,\n  sha512: 256,\n};\n\n// Note: Circuit lists are now managed through RegisterVerifierId and DscVerifierId enums below\n// instead of separate arrays for better type safety and maintainability\nexport const MAX_PUBKEY_DSC_BYTES = 525;\n\nexport const OFAC_TREE_LEVELS = 64;\n\n// we make it global here because passing it to generateCircuitInputsRegister caused trouble\nexport const PASSPORT_ATTESTATION_ID = '1';\n\nexport const PCR0_MANAGER_ADDRESS = '0xE36d4EE5Fd3916e703A46C21Bb3837dB7680C8B8';\n\nexport const REDIRECT_URL = 'https://redirect.self.xyz';\n\nexport const REGISTER_CONTRACT_ADDRESS = '0x3F346FFdC5d583e4126AF01A02Ac5b9CdB3f1909';\n\nexport const RPC_URL = 'https://forno.celo.org';\n\nexport enum RegisterVerifierId {\n  register_sha256_sha256_sha256_rsa_65537_4096 = 0,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 1,\n  register_sha256_sha256_sha256_ecdsa_secp256r1 = 2,\n  register_sha256_sha256_sha256_ecdsa_secp384r1 = 3,\n  register_sha256_sha256_sha256_rsa_3_4096 = 4,\n  register_sha256_sha256_sha256_rsapss_3_32_2048 = 5,\n  register_sha256_sha256_sha256_rsapss_65537_32_2048 = 6,\n  register_sha256_sha256_sha256_rsapss_65537_32_3072 = 7,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 8,\n  register_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 9,\n  register_sha384_sha384_sha384_ecdsa_secp384r1 = 10,\n  register_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 11,\n  register_sha512_sha512_sha512_rsa_65537_4096 = 12,\n  register_sha512_sha512_sha512_rsapss_65537_64_2048 = 13,\n  register_sha1_sha1_sha1_rsa_65537_4096 = 14,\n  register_sha1_sha256_sha256_rsa_65537_4096 = 15,\n  register_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 16,\n  register_sha256_sha224_sha224_ecdsa_secp224r1 = 17,\n  register_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 18,\n  register_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 19,\n  register_sha384_sha384_sha384_rsapss_65537_48_2048 = 20,\n  register_sha1_sha1_sha1_ecdsa_secp256r1 = 21,\n  register_sha256_sha256_sha256_rsapss_65537_64_2048 = 22,\n  register_sha512_sha512_sha256_rsa_65537_4096 = 23,\n  register_sha512_sha512_sha512_ecdsa_secp521r1 = 24,\n  register_id_sha256_sha256_sha256_rsa_65537_4096 = 25,\n  register_sha256_sha256_sha224_ecdsa_secp224r1 = 26,\n  register_id_sha1_sha1_sha1_ecdsa_brainpoolP224r1 = 27,\n  register_id_sha1_sha1_sha1_ecdsa_secp256r1 = 28,\n  register_id_sha1_sha1_sha1_rsa_65537_4096 = 29,\n  register_id_sha1_sha256_sha256_rsa_65537_4096 = 30,\n  register_id_sha224_sha224_sha224_ecdsa_brainpoolP224r1 = 31,\n  register_id_sha256_sha224_sha224_ecdsa_secp224r1 = 32,\n  register_id_sha256_sha256_sha224_ecdsa_secp224r1 = 33,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP256r1 = 34,\n  register_id_sha256_sha256_sha256_ecdsa_brainpoolP384r1 = 35,\n  register_id_sha256_sha256_sha256_ecdsa_secp256r1 = 36,\n  register_id_sha256_sha256_sha256_ecdsa_secp384r1 = 37,\n  register_id_sha256_sha256_sha256_rsa_3_4096 = 38,\n  register_id_sha256_sha256_sha256_rsapss_3_32_2048 = 39,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_2048 = 40,\n  register_id_sha256_sha256_sha256_rsapss_65537_32_3072 = 41,\n  register_id_sha256_sha256_sha256_rsapss_65537_64_2048 = 42,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP384r1 = 43,\n  register_id_sha384_sha384_sha384_ecdsa_brainpoolP512r1 = 44,\n  register_id_sha384_sha384_sha384_ecdsa_secp384r1 = 45,\n  register_id_sha384_sha384_sha384_rsapss_65537_48_2048 = 46,\n  register_id_sha512_sha512_sha256_rsa_65537_4096 = 47,\n  register_id_sha512_sha512_sha512_ecdsa_brainpoolP512r1 = 48,\n  register_id_sha512_sha512_sha512_ecdsa_secp521r1 = 49,\n  register_id_sha512_sha512_sha512_rsa_65537_4096 = 50,\n  register_id_sha512_sha512_sha512_rsapss_65537_64_2048 = 51,\n}\n\nexport const SBT_CONTRACT_ADDRESS = '0x601Fd54FD11C5E77DE84d877e55B829aff20f0A6';\n\nexport enum SignatureAlgorithmIndex {\n  rsa_sha256_65537_2048 = 1,\n  rsa_sha1_65537_2048 = 3,\n  rsapss_sha256_65537_2048 = 4,\n  ecdsa_sha1_secp256r1_256 = 7,\n  ecdsa_sha256_secp256r1_256 = 8,\n  ecdsa_sha384_secp384r1_384 = 9,\n  rsa_sha256_65537_4096 = 10,\n  rsa_sha1_65537_4096 = 11,\n  rsapss_sha256_65537_4096 = 12,\n  rsa_sha256_3_2048 = 13,\n  rsa_sha256_65537_3072 = 14,\n  rsa_sha512_65537_4096 = 15,\n  rsapss_sha256_3_3072 = 16,\n  rsapss_sha256_3_4096 = 17,\n  rsapss_sha384_65537_3072 = 18,\n  rsapss_sha256_65537_3072 = 19,\n  ecdsa_sha256_brainpoolP256r1_256 = 21,\n  ecdsa_sha384_brainpoolP384r1_384 = 22,\n  ecdsa_sha256_secp384r1_384 = 23,\n  ecdsa_sha384_brainpoolP256r1_256 = 24,\n  ecdsa_sha512_brainpoolP256r1_256 = 25,\n  ecdsa_sha512_brainpoolP384r1_384 = 26,\n  ecdsa_sha1_brainpoolP224r1_224 = 27,\n  ecdsa_sha256_brainpoolP224r1_224 = 28,\n  ecdsa_sha512_brainpoolP512r1_512 = 29,\n  ecdsa_sha224_brainpoolP224r1_224 = 30,\n  rsa_sha256_3_4096 = 32,\n  rsa_sha1_3_4096 = 33,\n  rsa_sha384_65537_4096 = 34,\n  rsapss_sha384_65537_4096 = 35,\n  ecdsa_sha1_brainpoolP256r1_256 = 36,\n  ecdsa_sha512_secp521r1_521 = 41,\n}\n\nexport const TREE_TRACKER_URL = 'https://tree.self.xyz';\n\nexport const TREE_URL = 'https://tree.self.xyz';\nexport const TREE_URL_STAGING = 'https://tree.staging.self.xyz';\n\nexport const WS_DB_RELAYER = 'wss://websocket.self.xyz';\n\nexport const WS_DB_RELAYER_STAGING = 'wss://websocket.staging.self.xyz';\n\nexport const WS_RPC_URL_VC_AND_DISCLOSE = 'ws://disclose.proving.self.xyz:8888/';\n\nexport const attributeToPosition = {\n  issuing_state: [2, 4],\n  name: [5, 43],\n  passport_number: [44, 52],\n  nationality: [54, 56],\n  date_of_birth: [57, 62],\n  gender: [64, 64],\n  expiry_date: [65, 70],\n  older_than: [88, 89],\n  ofac: [90, 90],\n};\nexport const attributeToPosition_ID = {\n  issuing_state: [2, 4],\n  name: [60, 89],\n  passport_number: [5, 13],\n  nationality: [45, 47],\n  date_of_birth: [30, 35],\n  gender: [37, 37],\n  expiry_date: [38, 43],\n  older_than: [90, 91],\n  ofac: [92, 92],\n};\n\nexport const circuitNameFromMode = {\n  prove: 'prove',\n  prove_onchain: 'prove',\n  prove_offchain: 'prove',\n  register: 'prove',\n  vc_and_disclose: 'vc_and_disclose',\n  dsc: 'dsc',\n};\nexport const circuitToSelectorMode = {\n  register: [0, 0],\n  prove_onchain: [1, 0],\n  prove_offchain: [1, 1],\n};\n\nexport const contribute_publicKey = `-----BEGIN RSA PUBLIC KEY-----\nMIICCgKCAgEAv/hm7FZZ2KBmaeDHmLoRwuWmCcNKT561RqbsW8ZuYSyPWJUldE9U\nCf0lW3K1H5lsSDkl0Cq84cooL9f6X59Mffb/N24ZKTdL0xdcPwjk4LbcrVm8qubL\n0a/4uCNoZZ1my4nxbpLxYtbr8CNmUGvBOVKf8IcjsY6VghIZrO63G6BN/G44su1Z\nWcHpboGt9SDQK4enCyKxnCD+PbDYlewSA0n3GRajFfZex1bj1EvrS2hTLv8oNH5e\n9H+3TUke0uO6Ttl0bZepoMmPlpAXhJByISqC6SLth4WFIH+G1I/xt9AEM7hOfLMl\nKQv/3wlLEgEueRryKAHB2tqkaDKVJyw+tOyWj2iWA+nVgQKAxO4hOw01ljyVbcx6\nKboXwnamlZPFIx4tjEaZ+ClXCFqvXhE9LDFK11QsYzJZl0aRVfTNqcurhEt7SK0f\nqzOBhID0Nxk4k9sW1uT6ocW1xp1SB2WotORssOKIAOLJM8IbPl6n/DkYNcfvyXI7\n4BlUrf6M2DgZMYATabIy94AvopHJOyiRfh4NpQPDntWnShiI1em2MmtXiWFCdVFV\n6/QfJTKVixJpVfDh386ALXc97EPWDMWIalUwYoV/eRSMnuV8nZ0+Ctp3Qrtk/JYd\n+FWhKbtlPeRjmGVr6mVlvDJ7KqtY5/RqqwfWeXhXezGhQqQ/OoQQCRkCAwEAAQ==\n-----END RSA PUBLIC KEY-----`;\n\n// not using a library for this as the entry countries use can be differnt than the ISO 3166-1 alpha-3 standard\nexport const countryCodes = {\n  AFG: 'Afghanistan',\n  ALA: 'Aland Islands',\n  ALB: 'Albania',\n  DZA: 'Algeria',\n  ASM: 'American Samoa',\n  AND: 'Andorra',\n  AGO: 'Angola',\n  AIA: 'Anguilla',\n  ATA: 'Antarctica',\n  ATG: 'Antigua and Barbuda',\n  ARG: 'Argentina',\n  ARM: 'Armenia',\n  ABW: 'Aruba',\n  AUS: 'Australia',\n  AUT: 'Austria',\n  AZE: 'Azerbaijan',\n  BHS: 'Bahamas',\n  BHR: 'Bahrain',\n  BGD: 'Bangladesh',\n  BRB: 'Barbados',\n  BLR: 'Belarus',\n  BEL: 'Belgium',\n  BLZ: 'Belize',\n  BEN: 'Benin',\n  BMU: 'Bermuda',\n  BTN: 'Bhutan',\n  BOL: 'Bolivia (Plurinational State of)',\n  BES: 'Bonaire, Sint Eustatius and Saba',\n  BIH: 'Bosnia and Herzegovina',\n  BWA: 'Botswana',\n  BVT: 'Bouvet Island',\n  BRA: 'Brazil',\n  IOT: 'British Indian Ocean Territory',\n  BRN: 'Brunei Darussalam',\n  BGR: 'Bulgaria',\n  BFA: 'Burkina Faso',\n  BDI: 'Burundi',\n  CPV: 'Cabo Verde',\n  KHM: 'Cambodia',\n  CMR: 'Cameroon',\n  CAN: 'Canada',\n  CYM: 'Cayman Islands',\n  CAF: 'Central African Republic',\n  TCD: 'Chad',\n  CHL: 'Chile',\n  CHN: 'China',\n  CXR: 'Christmas Island',\n  CCK: 'Cocos (Keeling) Islands',\n  COL: 'Colombia',\n  COM: 'Comoros',\n  COG: 'Congo',\n  COD: 'Congo, Democratic Republic of the',\n  COK: 'Cook Islands',\n  CRI: 'Costa Rica',\n  CIV: \"Cote d'Ivoire\",\n  HRV: 'Croatia',\n  CUB: 'Cuba',\n  CUW: 'Curacao',\n  CYP: 'Cyprus',\n  CZE: 'Czechia',\n  DNK: 'Denmark',\n  DJI: 'Djibouti',\n  DMA: 'Dominica',\n  DOM: 'Dominican Republic',\n  ECU: 'Ecuador',\n  EGY: 'Egypt',\n  SLV: 'El Salvador',\n  GNQ: 'Equatorial Guinea',\n  ERI: 'Eritrea',\n  EST: 'Estonia',\n  SWZ: 'Eswatini',\n  ETH: 'Ethiopia',\n  FLK: 'Falkland Islands (Malvinas)',\n  FRO: 'Faroe Islands',\n  FJI: 'Fiji',\n  FIN: 'Finland',\n  FRA: 'France',\n  GUF: 'French Guiana',\n  PYF: 'French Polynesia',\n  ATF: 'French Southern Territories',\n  GAB: 'Gabon',\n  GMB: 'Gambia',\n  GEO: 'Georgia',\n  DEU: 'Germany',\n  'D<<': 'Germany', // Bundesrepublik Deutschland uses this in passports instead of DEU\n  GHA: 'Ghana',\n  GIB: 'Gibraltar',\n  GRC: 'Greece',\n  GRL: 'Greenland',\n  GRD: 'Grenada',\n  GLP: 'Guadeloupe',\n  GUM: 'Guam',\n  GTM: 'Guatemala',\n  GGY: 'Guernsey',\n  GIN: 'Guinea',\n  GNB: 'Guinea-Bissau',\n  GUY: 'Guyana',\n  HTI: 'Haiti',\n  HMD: 'Heard Island and McDonald Islands',\n  VAT: 'Holy See',\n  HND: 'Honduras',\n  HKG: 'Hong Kong',\n  HUN: 'Hungary',\n  ISL: 'Iceland',\n  IND: 'India',\n  IDN: 'Indonesia',\n  IRN: 'Iran (Islamic Republic of)',\n  IRQ: 'Iraq',\n  IRL: 'Ireland',\n  IMN: 'Isle of Man',\n  ISR: 'Israel',\n  ITA: 'Italy',\n  JAM: 'Jamaica',\n  JPN: 'Japan',\n  JEY: 'Jersey',\n  JOR: 'Jordan',\n  KAZ: 'Kazakhstan',\n  KEN: 'Kenya',\n  KIR: 'Kiribati',\n  PRK: \"Korea (Democratic People's Republic of)\",\n  KOR: 'Korea, Republic of',\n  KWT: 'Kuwait',\n  KGZ: 'Kyrgyzstan',\n  LAO: \"Lao People's Democratic Republic\",\n  LVA: 'Latvia',\n  LBN: 'Lebanon',\n  LSO: 'Lesotho',\n  LBR: 'Liberia',\n  LBY: 'Libya',\n  LIE: 'Liechtenstein',\n  LTU: 'Lithuania',\n  LUX: 'Luxembourg',\n  MAC: 'Macao',\n  MDG: 'Madagascar',\n  MWI: 'Malawi',\n  MYS: 'Malaysia',\n  MDV: 'Maldives',\n  MLI: 'Mali',\n  MLT: 'Malta',\n  MHL: 'Marshall Islands',\n  MTQ: 'Martinique',\n  MRT: 'Mauritania',\n  MUS: 'Mauritius',\n  MYT: 'Mayotte',\n  MEX: 'Mexico',\n  FSM: 'Micronesia (Federated States of)',\n  MDA: 'Moldova, Republic of',\n  MCO: 'Monaco',\n  MNG: 'Mongolia',\n  MNE: 'Montenegro',\n  MSR: 'Montserrat',\n  MAR: 'Morocco',\n  MOZ: 'Mozambique',\n  MMR: 'Myanmar',\n  NAM: 'Namibia',\n  NRU: 'Nauru',\n  NPL: 'Nepal',\n  NLD: 'Netherlands',\n  NCL: 'New Caledonia',\n  NZL: 'New Zealand',\n  NIC: 'Nicaragua',\n  NER: 'Niger',\n  NGA: 'Nigeria',\n  NIU: 'Niue',\n  NFK: 'Norfolk Island',\n  MKD: 'North Macedonia',\n  MNP: 'Northern Mariana Islands',\n  NOR: 'Norway',\n  OMN: 'Oman',\n  PAK: 'Pakistan',\n  PLW: 'Palau',\n  PSE: 'Palestine, State of',\n  PAN: 'Panama',\n  PNG: 'Papua New Guinea',\n  PRY: 'Paraguay',\n  PER: 'Peru',\n  PHL: 'Philippines',\n  PCN: 'Pitcairn',\n  POL: 'Poland',\n  PRT: 'Portugal',\n  PRI: 'Puerto Rico',\n  QAT: 'Qatar',\n  REU: 'Reunion',\n  ROU: 'Romania',\n  RUS: 'Russian Federation',\n  RWA: 'Rwanda',\n  BLM: 'Saint Barthelemy',\n  SHN: 'Saint Helena, Ascension and Tristan da Cunha',\n  KNA: 'Saint Kitts and Nevis',\n  LCA: 'Saint Lucia',\n  MAF: 'Saint Martin (French part)',\n  SPM: 'Saint Pierre and Miquelon',\n  VCT: 'Saint Vincent and the Grenadines',\n  WSM: 'Samoa',\n  SMR: 'San Marino',\n  STP: 'Sao Tome and Principe',\n  SAU: 'Saudi Arabia',\n  SEN: 'Senegal',\n  SRB: 'Serbia',\n  SYC: 'Seychelles',\n  SLE: 'Sierra Leone',\n  SGP: 'Singapore',\n  SXM: 'Sint Maarten (Dutch part)',\n  SVK: 'Slovakia',\n  SVN: 'Slovenia',\n  SLB: 'Solomon Islands',\n  SOM: 'Somalia',\n  ZAF: 'South Africa',\n  SGS: 'South Georgia and the South Sandwich Islands',\n  SSD: 'South Sudan',\n  ESP: 'Spain',\n  LKA: 'Sri Lanka',\n  SDN: 'Sudan',\n  SUR: 'Suriname',\n  SJM: 'Svalbard and Jan Mayen',\n  SWE: 'Sweden',\n  CHE: 'Switzerland',\n  SYR: 'Syrian Arab Republic',\n  TWN: 'Taiwan, Province of China',\n  TJK: 'Tajikistan',\n  TZA: 'Tanzania, United Republic of',\n  THA: 'Thailand',\n  TLS: 'Timor-Leste',\n  TGO: 'Togo',\n  TKL: 'Tokelau',\n  TON: 'Tonga',\n  TTO: 'Trinidad and Tobago',\n  TUN: 'Tunisia',\n  TUR: 'Turkey',\n  TKM: 'Turkmenistan',\n  TCA: 'Turks and Caicos Islands',\n  TUV: 'Tuvalu',\n  UGA: 'Uganda',\n  UKR: 'Ukraine',\n  ARE: 'United Arab Emirates',\n  GBR: 'United Kingdom of Great Britain and Northern Ireland',\n  USA: 'United States of America',\n  UMI: 'United States Minor Outlying Islands',\n  URY: 'Uruguay',\n  UZB: 'Uzbekistan',\n  VUT: 'Vanuatu',\n  VEN: 'Venezuela (Bolivarian Republic of)',\n  VNM: 'Viet Nam',\n  VGB: 'Virgin Islands (British)',\n  VIR: 'Virgin Islands (U.S.)',\n  WLF: 'Wallis and Futuna',\n  ESH: 'Western Sahara',\n  YEM: 'Yemen',\n  ZMB: 'Zambia',\n  ZWE: 'Zimbabwe',\n};\n\nexport function getCountryCode(countryName: string): string {\n  const entries = Object.entries(countryCodes);\n  const found = entries.find(([_, name]) => name.toLowerCase() === countryName.toLowerCase());\n  return found ? found[0] : 'undefined';\n}\n\nexport const hashAlgos = ['sha512', 'sha384', 'sha256', 'sha224', 'sha1'];\n\nexport const k_csca = 35;\n\nexport const k_dsc = 35;\n\n//48;\nexport const k_dsc_3072 = 35;\n\nexport const k_dsc_4096 = 35;\n\nexport const k_dsc_ecdsa = 4;\n\nexport const max_csca_bytes = 1792;\n\nexport const max_dsc_bytes = 1792;\n\nexport const n_csca = 120;\n\nexport const n_dsc = 120;\n\nexport const n_dsc_3072 = 120;\n\nexport const n_dsc_4096 = 120;\n\nexport const n_dsc_ecdsa = 64;\n\n// max formatted and concatenated datagroup hashes length in bytes\nexport const revealedDataTypes = {\n  issuing_state: 0,\n  name: 1,\n  passport_number: 2,\n  nationality: 3,\n  date_of_birth: 4,\n  gender: 5,\n  expiry_date: 6,\n  older_than: 7,\n  passport_no_ofac: 8,\n  name_and_dob_ofac: 9,\n  name_and_yob_ofac: 10,\n};\n\nexport const saltLengths = [64, 48, 32];\n","import { toUnsignedByte } from '../bytes.js';\n\nexport function formatAndConcatenateDataHashes(\n  dataHashes: [number, number[]][],\n  dg1HashOffset: number\n) {\n  // concatenating dataHashes :\n  const concat: number[] = [];\n\n  const startingSequence = Array.from(\n    { length: dg1HashOffset },\n    () => Math.floor(Math.random() * 256) - 128\n  );\n\n  // // sha256 with rsa (index of mrzhash is 31)\n  // const startingSequence = [\n  //   // SEQUENCE + long form indicator + length (293 bytes)\n  //   48, -126, 1, 37,\n  //   // length: 1 byte\n  //   2, 1,\n  //   // LDSSecurityObjectVersion v0\n  //   0,\n  //   // padding: size 11 - size 9...\n  //   48, 11, 6, 9,\n  //   // 2.16.840.1.101.3.4.2.1 is sha256\n  //   96, -122, 72, 1, 101, 3, 4, 2, 1,\n  //   // SEQUENCE + long form indicator + length (273 bytes)\n  //   48, -126, 1, 17,\n  // ]\n\n  // rsassaPss (index of mrzhash is 30)\n  // // SEQUENCE + short form indicator + length (137 bytes)\n  // 48, -127, -119,\n  // 2, 1,\n  // 0,\n  // 48, 13, 6, 9,\n  // // 2.16.840.1.101.3.4.2.1 is sha256\n  // 96, -122, 72, 1, 101, 3, 4, 2, 1,\n  // // NULL tag + SEQUENCE + length (117 bytes)\n  // 5, 0, 48, 117,\n\n  // SHA384withECDSA (index of mrzhash is 33)\n  // // SEQUENCE + long form indicator + length (313 bytes)\n  // 48, -126, 1, 57,\n  // 2, 1,\n  // 1,\n  // 48, 13, 6, 9,\n  // // 2.16.840.1.101.3.4.2.1 is sha384\n  // 96, -122, 72, 1, 101, 3, 4, 2, 2,\n  // // NULL tag + SEQUENCE + long form indicator + length (275 bytes)\n  // 5, 0, 48, -126, 1, 19,\n\n  // spain\n  // 48, -127,  -79,\n  // 2,    1,\n  // 0,\n  // 48,    7,   6,   5,\n  // 1.3.14.3.2.26 is sha1\n  // 43,  14, 3,    2,   26,\n  // SEQUENCE + ...\n  // 48, -127, -94,\n\n  // => current conclusion is we should be able to just hardcode indexes\n  // => as they shouldn't change must for same sig alg.\n  // => wrong: our rsassaPss has less datagroups so the length is different (30 rather then 31)\n\n  // console.log(`startingSequence`, startingSequence.map(byte => (byte < 0 ? byte + 256 : byte).toString(16).padStart(2, '0')).join(''));\n\n  concat.push(...startingSequence);\n\n  for (const dataHash of dataHashes) {\n    // console.log(`dataHash ${dataHash[0]}`, dataHash[1].map(byte => (byte < 0 ? byte + 256 : byte).toString(16).padStart(2, '0')).join(''));\n\n    //push 7 padding bytes\n    concat.push(...[0, 0, 0, 0, 0, 0, 0]);\n\n    concat.push(...dataHash[1]);\n    // concat.push(...[48, hashLen + 5, 2, 1, dataHash[0], 4, hashLen, ...dataHash[1]])\n    // 48, 37, 2, 1, 1, 4, 32,\n    // 48, 53, 2, 1, 1, 4, 48,\n  }\n\n  return concat;\n}\n\nexport function formatDG1Attribute(index: number[], value: string) {\n  const max_length = index[1] - index[0] + 1;\n  if (value.length > max_length) {\n    throw new Error(\n      `Value is too long for index ${index[0]}-${index[1]} value: ${value} value.length: ${value.length} maxLength: ${max_length}`\n    );\n  }\n  return value.padEnd(max_length, '<');\n}\n\nexport function formatDg2Hash(dg2Hash: number[]) {\n  const unsignedBytesDg2Hash = dg2Hash.map((x) => toUnsignedByte(x));\n  while (unsignedBytesDg2Hash.length < 64) {\n    // pad it to 64 bytes to correspond to the hash length of sha512 and avoid multiplying circuits\n    unsignedBytesDg2Hash.push(0);\n  }\n  return unsignedBytesDg2Hash;\n}\n\nexport function formatMrz(mrz: string) {\n  const mrzCharcodes = [...mrz].map((char) => char.charCodeAt(0));\n\n  if (mrz.length === 88) {\n    mrzCharcodes.unshift(88); // the length of the mrz data\n    mrzCharcodes.unshift(95, 31); // the MRZ_INFO_TAG\n    mrzCharcodes.unshift(91); // the new length of the whole array\n    mrzCharcodes.unshift(97); // the tag for DG1\n  } else if (mrz.length === 90) {\n    mrzCharcodes.unshift(90); // the length of the mrz data\n    mrzCharcodes.unshift(95, 31); // the MRZ_INFO_TAG\n    mrzCharcodes.unshift(93); // the new length of the whole array\n    mrzCharcodes.unshift(97); // the tag for DG1\n  } else {\n    throw new Error(`Unsupported MRZ length: ${mrz.length}. Expected 88 or 90 characters.`);\n  }\n\n  return mrzCharcodes;\n}\n\nexport function formatName(firstName: string, lastName: string, targetLength: number) {\n  // Split names by spaces and join parts with '<'\n  const formattedLastName = lastName.toUpperCase().split(' ').join('<');\n  const formattedFirstName = firstName.toUpperCase().split(' ').join('<');\n\n  // Combine with '<<' separator\n  let result = `${formattedLastName}<<${formattedFirstName}`;\n\n  // Pad with '<' or truncate to target length\n  if (result.length < targetLength) {\n    result = result.padEnd(targetLength, '<');\n  } else if (result.length > targetLength) {\n    result = result.substring(0, targetLength);\n  }\n\n  return result;\n}\n\nexport function generateSignedAttr(messageDigest: number[]) {\n  const constructedEContent = [];\n\n  // Detailed description is in private file r&d.ts for now\n  // First, the tag and length, assumed to be always the same\n  constructedEContent.push(...[49, 102]);\n\n  // 1.2.840.113549.1.9.3 is RFC_3369_CONTENT_TYPE_OID\n  constructedEContent.push(...[48, 21, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 3]);\n  // 2.23.136.1.1.1 is ldsSecurityObject\n  constructedEContent.push(...[49, 8, 6, 6, 103, -127, 8, 1, 1, 1]);\n\n  // 1.2.840.113549.1.9.5 is signing-time\n  constructedEContent.push(...[48, 28, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 5]);\n  // mock time of signature\n  constructedEContent.push(...[49, 15, 23, 13, 49, 57, 49, 50, 49, 54, 49, 55, 50, 50, 51, 56, 90]);\n  // 1.2.840.113549.1.9.4 is RFC_3369_MESSAGE_DIGEST_OID\n  constructedEContent.push(...[48, 47, 6, 9, 42, -122, 72, -122, -9, 13, 1, 9, 4]);\n  // TAG and length of the message digest\n  constructedEContent.push(...[49, 34, 4, 32]);\n\n  constructedEContent.push(...messageDigest);\n  return constructedEContent;\n}\n","import countries from 'i18n-iso-countries';\n// @ts-ignore\nimport en from 'i18n-iso-countries/langs/en.json' with { type: 'json' };\nimport { poseidon2, poseidon3, poseidon6, poseidon10, poseidon12, poseidon13 } from 'poseidon-lite';\n\nimport {\n  CSCA_TREE_DEPTH,\n  DSC_TREE_DEPTH,\n  max_csca_bytes,\n  max_dsc_bytes,\n  OFAC_TREE_LEVELS,\n} from '../constants/constants.js';\nimport type { CertificateData } from './certificate_parsing/dataStructure.js';\nimport { parseCertificateSimple } from './certificate_parsing/parseCertificateSimple.js';\nimport { stringToAsciiBigIntArray } from './circuits/uuid.js';\nimport { packBytesAndPoseidon } from './hash.js';\nimport { pad } from './passports/passport.js';\nimport type { DscCertificateMetaData } from './passports/passport_parsing/parseDscCertificateData.js';\nimport { parseDscCertificateData } from './passports/passport_parsing/parseDscCertificateData.js';\n\nimport { IMT } from '@openpassport/zk-kit-imt';\nimport { LeanIMT } from '@openpassport/zk-kit-lean-imt';\nimport type { ChildNodes } from '@openpassport/zk-kit-smt';\nimport { SMT } from '@openpassport/zk-kit-smt';\n\n// SideEffect here\ncountries.registerLocale(en);\n\n// SMT trees for 3 levels of matching :\n// 1. Passport Number and Nationality tree : level 3 (Absolute Match)\n// 2. Name and date of birth combo tree : level 2 (High Probability Match)\n// 3. Name and year of birth combo tree : level 1 (Partial Match)\n// NEW: ID card specific trees\nexport function buildSMT(field: any[], treetype: string): [number, number, SMT] {\n  let count = 0;\n  const startTime = performance.now();\n\n  const hash2 = (childNodes: ChildNodes) =>\n    childNodes.length === 2 ? poseidon2(childNodes) : poseidon3(childNodes);\n  const tree = new SMT(hash2, true);\n\n  for (let i = 0; i < field.length; i++) {\n    const entry = field[i];\n\n    // Optimization: Log progress less frequently\n    if (i !== 0 && i % 100 === 0) {\n      console.log('Processing', treetype, 'number', i, 'out of', field.length);\n    }\n\n    let leaf = BigInt(0);\n    // Determine document type based on treetype for name processing\n    let docType: 'passport' | 'id_card' = 'passport'; // Default to passport\n    if (treetype.endsWith('_id_card')) {\n      docType = 'id_card';\n    }\n\n    if (treetype == 'passport_no_and_nationality') {\n      leaf = processPassportNoAndNationality(entry.Pass_No, entry.Pass_Country, i);\n    } else if (treetype == 'name_and_dob') {\n      leaf = processNameAndDob(entry, i, 'passport'); // Explicitly passport\n    } else if (treetype == 'name_and_yob') {\n      leaf = processNameAndYob(entry, i, 'passport'); // Explicitly passport\n    } else if (treetype == 'name_and_dob_id_card') {\n      // New ID card type\n      leaf = processNameAndDob(entry, i, 'id_card');\n    } else if (treetype == 'name_and_yob_id_card') {\n      // New ID card type\n      leaf = processNameAndYob(entry, i, 'id_card');\n    } else if (treetype == 'country') {\n      const keys = Object.keys(entry);\n      leaf = processCountry(keys[0], entry[keys[0]], i);\n    }\n\n    if (leaf == BigInt(0)) {\n      // Skip entries that couldn't be processed (e.g., missing data)\n      continue;\n    }\n\n    // Check for duplicates *after* processing, as different inputs might yield the same hash\n    if (tree.createProof(leaf).membership) {\n      // console.log('Duplicate leaf generated, skipping entry:', i, entry); // Optional: log duplicates\n      continue;\n    }\n\n    count += 1;\n    tree.add(leaf, BigInt(1));\n  }\n\n  console.log('Total', treetype, 'entries added:', count, 'out of', field.length);\n  console.log(treetype, 'tree built in', (performance.now() - startTime).toFixed(2), 'ms');\n  return [count, performance.now() - startTime, tree];\n}\n\nexport function formatRoot(root: string): string {\n  const rootHex = BigInt(root).toString(16);\n  return rootHex.length % 2 === 0 ? '0x' + rootHex : '0x0' + rootHex;\n}\n\nexport function generateMerkleProof(imt: LeanIMT, _index: number, maxleaf_depth: number) {\n  const { siblings: siblings, index } = imt.generateProof(_index);\n  const leaf_depth = siblings.length;\n  // The index must be converted to a list of indices, 1 for each tree level.\n  // The circuit tree leaf_depth is 20, so the number of siblings must be 20, even if\n  // the tree leaf_depth is actually 3. The missing siblings can be set to 0, as they\n  // won't be used to calculate the root in the circuit.\n  const path: number[] = [];\n\n  for (let i = 0; i < maxleaf_depth; i += 1) {\n    path.push((index >> i) & 1);\n    if (siblings[i] === undefined) {\n      siblings[i] = BigInt(0);\n    }\n  }\n  return { siblings, path, leaf_depth };\n}\n\nexport function generateSMTProof(smt: SMT, leaf: bigint) {\n  const { entry, matchingEntry, siblings, root, membership } = smt.createProof(leaf);\n  const leaf_depth = siblings.length;\n\n  let closestleaf;\n  if (!matchingEntry) {\n    // we got the 0 leaf or membership\n    // then check if entry[1] exists\n    if (!entry[1]) {\n      // non membership proof\n      closestleaf = BigInt(0); // 0 leaf\n    } else {\n      closestleaf = BigInt(entry[0]); // leaf itself (memb proof)\n    }\n  } else {\n    // non membership proof\n    closestleaf = BigInt(matchingEntry[0]); // actual closest\n  }\n\n  // PATH, SIBLINGS manipulation as per binary tree in the circuit\n  siblings.reverse();\n  while (siblings.length < OFAC_TREE_LEVELS) siblings.push(BigInt(0));\n\n  // ----- Useful for debugging hence leaving as comments -----\n  // const binary = entry[0].toString(2)\n  // const bits = binary.slice(-leaf_depth);\n  // let indices = bits.padEnd(256, \"0\").split(\"\").map(Number)\n  // const pathToMatch = num2Bits(256,BigInt(entry[0]))\n  // while(indices.length < 256) indices.push(0);\n  // // CALCULATED ROOT FOR TESTING\n  // // closestleaf, leaf_depth, siblings, indices, root : needed\n  // let calculatedNode = poseidon3([closestleaf,1,1]);\n  // console.log(\"Initial node while calculating\",calculatedNode)\n  // console.log(smt.verifyProof(smt.createProof(leaf)))\n  // for (let i= 0; i < leaf_depth ; i++) {\n  //   const childNodes: any = indices[i] ? [siblings[i], calculatedNode] : [calculatedNode, siblings[i]]\n  //   console.log(indices[i],childNodes)\n  //   calculatedNode = poseidon2(childNodes)\n  // }\n  // console.log(\"Actual node\", root)\n  // console.log(\"calculated node\", calculatedNode)\n  // -----------------------------------------------------------\n\n  return {\n    root,\n    leaf_depth,\n    closestleaf,\n    siblings,\n  };\n}\n\nexport function getCountryLeaf(\n  country_by: (bigint | number)[],\n  country_to: (bigint | number)[],\n  i?: number\n): bigint {\n  if (country_by.length !== 3 || country_to.length !== 3) {\n    console.log('parsed passport length is not 3:', i, country_to, country_by);\n    return;\n  }\n  try {\n    const country = country_by.concat(country_to);\n    return poseidon6(country);\n  } catch (err) {\n    console.log('err : sanc_country hash', err, i, country_by, country_to);\n  }\n}\n\nexport function getCscaTreeInclusionProof(leaf: string, _serialized_csca_tree: any[][]) {\n  const tree = new IMT(poseidon2, CSCA_TREE_DEPTH, 0, 2);\n  tree.setNodes(_serialized_csca_tree);\n  const index = tree.indexOf(leaf);\n  if (index === -1) {\n    throw new Error('Your public key was not found in the registry');\n  }\n  const proof = tree.createProof(index);\n  return [\n    tree.root,\n    proof.pathIndices.map((index) => index.toString()),\n    proof.siblings.flat().map((sibling) => sibling.toString()),\n  ];\n}\n\nexport function getCscaTreeRoot(serialized_csca_tree: any[][]) {\n  const tree = new IMT(poseidon2, CSCA_TREE_DEPTH, 0, 2);\n  tree.setNodes(serialized_csca_tree);\n  return tree.root;\n}\n\nexport function getDobLeaf(dobMrz: (bigint | number)[], i?: number): bigint {\n  if (dobMrz.length !== 6) {\n    // console.log('parsed dob length is not 6:', i, dobMrz); // Corrected length check message\n    return BigInt(0); // Return 0 for invalid length\n  }\n  try {\n    return poseidon6(dobMrz);\n  } catch (err) {\n    console.error('Error in getDobLeaf:', err, 'Index:', i, 'DOB MRZ:', dobMrz); // Use console.error\n    return BigInt(0); // Return 0 on error\n  }\n}\n\nexport function getDscTreeInclusionProof(\n  leaf: string,\n  serialized_dsc_tree: string\n): [string, number[], bigint[], number] {\n  const hashFunction = (a: any, b: any) => poseidon2([a, b]);\n  const tree = LeanIMT.import(hashFunction, serialized_dsc_tree);\n  const index = tree.indexOf(BigInt(leaf));\n  if (index === -1) {\n    throw new Error('Your public key was not found in the registry');\n  }\n  const { siblings, path, leaf_depth } = generateMerkleProof(tree, index, DSC_TREE_DEPTH);\n  return [tree.root, path, siblings, leaf_depth];\n}\n\n/** get leaf for DSC and CSCA Trees */\nexport function getLeaf(parsed: CertificateData, type: 'dsc' | 'csca'): string {\n  if (type === 'dsc') {\n    // for now, we pad it for sha\n    const tbsArray = Object.keys(parsed.tbsBytes).map((key) => parsed.tbsBytes[key]);\n    const [paddedTbsBytes, tbsBytesPaddedLength] = pad(parsed.hashAlgorithm)(\n      tbsArray,\n      max_dsc_bytes\n    );\n    const dsc_hash = packBytesAndPoseidon(Array.from(paddedTbsBytes));\n\n    return poseidon2([dsc_hash, tbsArray.length]).toString();\n  } else {\n    const tbsBytesArray = Array.from(parsed.tbsBytes);\n    const paddedTbsBytesArray = tbsBytesArray.concat(\n      new Array(max_csca_bytes - tbsBytesArray.length).fill(0)\n    );\n    const csca_hash = packBytesAndPoseidon(paddedTbsBytesArray);\n    return poseidon2([csca_hash, tbsBytesArray.length]).toString();\n  }\n}\n\nexport function getLeafCscaTree(csca_parsed: CertificateData): string {\n  return getLeaf(csca_parsed, 'csca');\n}\n\nexport function getLeafDscTree(dsc_parsed: CertificateData, csca_parsed: CertificateData): string {\n  const dscLeaf = getLeaf(dsc_parsed, 'dsc');\n  const cscaLeaf = getLeaf(csca_parsed, 'csca');\n  return poseidon2([dscLeaf, cscaLeaf]).toString();\n}\n\nfunction processPassportNoAndNationality(\n  passno: string,\n  nationality: string,\n  index: number\n): bigint {\n  if (passno.length > 9) {\n    console.log('passport number length is greater than 9:', index, passno);\n  } else if (passno.length < 9) {\n    while (passno.length != 9) {\n      passno += '<';\n    }\n  }\n\n  const countryCode = getCountryCode(nationality);\n  if (!countryCode) {\n    console.log('Error getting country code', index, nationality);\n    return BigInt(0);\n  }\n  console.log('nationality and countryCode', nationality, countryCode);\n\n  const leaf = getPassportNumberAndNationalityLeaf(\n    stringToAsciiBigIntArray(passno),\n    stringToAsciiBigIntArray(countryCode),\n    index\n  );\n  if (!leaf) {\n    console.log('Error creating leaf value', index, passno, nationality);\n    return BigInt(0);\n  }\n  return leaf;\n}\n\n// this is a temporary workaround for some of the country name,\n// will be removed once we parse the OFAC list better, starting from the XML file.\nconst normalizeCountryName = (country: string): string => {\n  const mapping: Record<string, string> = {\n    palestinian: 'Palestine',\n    'korea, north': 'North Korea',\n    'korea, south': 'Korea, Republic of',\n    'united kingdom': 'United Kingdom',\n    syria: 'Syrian Arab Republic',\n    burma: 'Myanmar',\n    'cabo verde': 'Cape Verde',\n    'congo, democratic republic of the': 'Democratic Republic of the Congo',\n    macau: 'Macao',\n  };\n  return mapping[country.toLowerCase()] || country;\n};\n\nconst getCountryCode = (countryName: string): string | undefined => {\n  return countries.getAlpha3Code(normalizeCountryName(countryName), 'en');\n};\n\nfunction generateSmallKey(input: bigint): bigint {\n  return input % (BigInt(1) << BigInt(OFAC_TREE_LEVELS));\n}\n\nfunction processNameAndDob(entry: any, i: number, docType: 'passport' | 'id_card'): bigint {\n  const firstName = entry.First_Name;\n  const lastName = entry.Last_Name;\n  const day = entry.day;\n  const month = entry.month;\n  const year = entry.year;\n  if (day == null || month == null || year == null || !firstName || !lastName) {\n    // Added checks for name presence\n    // console.log('Name or DOB data missing for name_and_dob', i, entry); // Optional: log missing data\n    return BigInt(0);\n  }\n  const targetLength = docType === 'passport' ? 39 : 30;\n  const nameHash = processName(firstName, lastName, targetLength, i);\n  if (nameHash === BigInt(0)) return BigInt(0); // Propagate error\n  const dobHash = processDob(day, month, year, i);\n  if (dobHash === BigInt(0)) return BigInt(0); // Propagate error\n\n  return generateSmallKey(poseidon2([dobHash, nameHash]));\n}\n\nfunction processNameAndYob(entry: any, i: number, docType: 'passport' | 'id_card'): bigint {\n  const firstName = entry.First_Name;\n  const lastName = entry.Last_Name;\n  const year = entry.year;\n  if (year == null || !firstName || !lastName) {\n    // Added checks for name presence\n    // console.log('Name or YOB data missing for name_and_yob', i, entry); // Optional: log missing data\n    return BigInt(0);\n  }\n  const targetLength = docType === 'passport' ? 39 : 30;\n  const nameHash = processName(firstName, lastName, targetLength, i);\n  if (nameHash === BigInt(0)) return BigInt(0); // Propagate error\n  const yearHash = processYear(year, i);\n  if (yearHash === BigInt(0)) return BigInt(0); // Propagate error\n\n  return generateSmallKey(poseidon2([yearHash, nameHash]));\n}\n\nfunction processYear(year: string, i: number): bigint {\n  if (!year || typeof year !== 'string' || year.length < 2) {\n    // console.log('Invalid year format for processYear', i, year); // Optional: log error\n    return BigInt(0);\n  }\n  const yearSuffix = year.slice(-2);\n  const yearArr = stringToAsciiBigIntArray(yearSuffix);\n  return getYearLeaf(yearArr);\n}\n\nfunction getYearLeaf(yearArr: (bigint | number)[]): bigint {\n  if (yearArr.length !== 2) {\n    // console.log('Invalid year array length for getYearLeaf', yearArr); // Optional: log error\n    return BigInt(0);\n  }\n  try {\n    return poseidon2(yearArr);\n  } catch (err) {\n    // console.log('err : Year hash', err, yearArr); // Optional: log error\n    return BigInt(0);\n  }\n}\n\nfunction processName(\n  firstName: string,\n  lastName: string,\n  targetLength: 30 | 39,\n  i: number\n): bigint {\n  // LASTNAME<<FIRSTNAME<MIDDLENAME<<<...\n  // Ensure names are strings before processing\n  const cleanFirstName =\n    typeof firstName === 'string'\n      ? firstName.replace(/'/g, '').replace(/\\./g, '').replace(/[- ]/g, '<')\n      : '';\n  const cleanLastName =\n    typeof lastName === 'string'\n      ? lastName.replace(/'/g, '').replace(/[- ]/g, '<').replace(/\\./g, '')\n      : '';\n\n  // Handle cases where one name might be missing\n  let arr = (cleanLastName ? cleanLastName + '<<' : '') + cleanFirstName;\n\n  if (arr.length === 0) {\n    // console.log('Cannot process empty name string', i); // Optional: log error\n    return BigInt(0);\n  }\n\n  // Pad or truncate to target length\n  if (arr.length > targetLength) {\n    arr = arr.substring(0, targetLength);\n  } else {\n    while (arr.length < targetLength) {\n      arr += '<';\n    }\n  }\n  console.log('arr', arr, 'arr.length', arr.length);\n  const nameArr = stringToAsciiBigIntArray(arr);\n  // getNameLeaf will select the correct Poseidon hash based on nameArr.length\n  return getNameLeaf(nameArr, i);\n}\n\nfunction processDob(day: string, month: string, year: string, i: number): bigint {\n  // YYMMDD\n  const monthMap: { [key: string]: string } = {\n    jan: '01',\n    feb: '02',\n    mar: '03',\n    apr: '04',\n    may: '05',\n    jun: '06',\n    jul: '07',\n    aug: '08',\n    sep: '09',\n    oct: '10',\n    nov: '11',\n    dec: '12',\n  };\n\n  const lowerMonth = typeof month === 'string' ? month.toLowerCase() : '';\n  const mappedMonth = monthMap[lowerMonth];\n\n  if (\n    !mappedMonth ||\n    !day ||\n    typeof day !== 'string' ||\n    day.length !== 2 ||\n    !year ||\n    typeof year !== 'string' ||\n    year.length < 2\n  ) {\n    // console.log('Invalid DOB component format for processDob', i, {day, month, year}); // Optional: log error\n    return BigInt(0);\n  }\n\n  const yearSuffix = year.slice(-2);\n  const dob = yearSuffix + mappedMonth + day;\n  const arr = stringToAsciiBigIntArray(dob);\n  return getDobLeaf(arr, i);\n}\n\nfunction processCountry(country1: string, country2: string, i: number) {\n  const arr = stringToAsciiBigIntArray(country1);\n  const arr2 = stringToAsciiBigIntArray(country2);\n\n  const leaf = getCountryLeaf(arr, arr2, i);\n  if (!leaf) {\n    console.log('Error creating leaf value', i, country1, country2);\n    return BigInt(0);\n  }\n  return leaf;\n}\n\nexport function getLeafDscTreeFromDscCertificateMetadata(\n  dscParsed: CertificateData,\n  dscMetaData: DscCertificateMetaData\n): string {\n  // TODO: WRONG  change this function using raw dsc and hashfunctions from passportMetadata\n  const cscaParsed = parseCertificateSimple(dscMetaData.csca);\n  return getLeafDscTree(dscParsed, cscaParsed);\n}\n\nexport function getLeafDscTreeFromParsedDsc(dscParsed: CertificateData): string {\n  return getLeafDscTreeFromDscCertificateMetadata(dscParsed, parseDscCertificateData(dscParsed));\n}\n\nexport function getNameDobLeaf(\n  nameMrz: (bigint | number)[],\n  dobMrz: (bigint | number)[],\n  i?: number\n): bigint {\n  return generateSmallKey(poseidon2([getDobLeaf(dobMrz), getNameLeaf(nameMrz)]));\n}\n\nexport function getNameLeaf(nameMrz: (bigint | number)[], i?: number): bigint {\n  const middleChunks: bigint[] = [];\n  const chunks: (number | bigint)[][] = [];\n  try {\n    // Add try-catch block\n    if (nameMrz.length == 39) {\n      // passport\n      chunks.push(nameMrz.slice(0, 13), nameMrz.slice(13, 26), nameMrz.slice(26, 39));\n      for (const chunk of chunks) {\n        if (chunk.length !== 13)\n          throw new Error(`Invalid chunk length for Poseidon13: ${chunk.length}`);\n        middleChunks.push(poseidon13(chunk));\n      }\n    } else if (nameMrz.length == 30) {\n      // id_card\n      chunks.push(nameMrz.slice(0, 10), nameMrz.slice(10, 20), nameMrz.slice(20, 30)); // Corrected comment: 30/3 for poseidon10\n      for (const chunk of chunks) {\n        if (chunk.length !== 10)\n          throw new Error(`Invalid chunk length for Poseidon10: ${chunk.length}`);\n        middleChunks.push(poseidon10(chunk));\n      }\n    } else {\n      throw new Error(`Unsupported name MRZ length: ${nameMrz.length}`); // Handle unexpected lengths\n    }\n\n    if (middleChunks.length !== 3)\n      throw new Error(`Invalid number of middle chunks: ${middleChunks.length}`);\n    return poseidon3(middleChunks);\n  } catch (err) {\n    console.error('Error in getNameLeaf:', err, 'Index:', i, 'MRZ Length:', nameMrz.length); // Use console.error for errors\n    // console.log('MRZ data:', nameMrz); // Optional: log failing data\n    return BigInt(0); // Return 0 on error\n  }\n}\n\nexport function getNameYobLeaf(\n  nameMrz: (bigint | number)[],\n  yobMrz: (bigint | number)[],\n  i?: number\n): bigint {\n  return generateSmallKey(poseidon2([getYearLeaf(yobMrz), getNameLeaf(nameMrz)]));\n}\n\nexport function getPassportNumberAndNationalityLeaf(\n  passport: (bigint | number)[],\n  nationality: (bigint | number)[],\n  i?: number\n): bigint {\n  if (passport.length !== 9) {\n    console.log('parsed passport length is not 9:', i, passport);\n    return;\n  }\n  if (nationality.length !== 3) {\n    console.log('parsed nationality length is not 3:', i, nationality);\n    return;\n  }\n  try {\n    const fullHash = poseidon12(passport.concat(nationality));\n    return generateSmallKey(fullHash);\n  } catch (err) {\n    console.log('err : passport', err, i, passport);\n  }\n}\n","import {\n  COMMITMENT_TREE_DEPTH,\n  max_csca_bytes,\n  max_dsc_bytes,\n  MAX_PADDED_ECONTENT_LEN,\n  MAX_PADDED_SIGNED_ATTR_LEN,\n  OFAC_TREE_LEVELS,\n} from '../../constants/constants.js';\nimport { getCurrentDateYYMMDD } from '../date.js';\nimport { hash, packBytesAndPoseidon } from '../hash.js';\nimport { formatMrz } from '../passports/format.js';\nimport {\n  extractSignatureFromDSC,\n  findStartPubKeyIndex,\n  formatSignatureDSCCircuit,\n  generateCommitment,\n  getCertificatePubKey,\n  getPassportSignatureInfos,\n  pad,\n  padWithZeroes,\n} from '../passports/passport.js';\nimport {\n  generateMerkleProof,\n  generateSMTProof,\n  getCountryLeaf,\n  getCscaTreeInclusionProof,\n  getDscTreeInclusionProof,\n  getLeafCscaTree,\n  getLeafDscTree,\n  getNameDobLeaf,\n  getNameYobLeaf,\n  getPassportNumberAndNationalityLeaf,\n} from '../trees.js';\nimport type { PassportData } from '../types.js';\nimport { formatCountriesList } from './formatInputs.js';\nimport { stringToAsciiBigIntArray } from './uuid.js';\n\nimport type { LeanIMT } from '@openpassport/zk-kit-lean-imt';\nimport type { SMT } from '@openpassport/zk-kit-smt';\n\n// this get the commitment index whether it is a string or a bigint\n// this is necessary rn because when the tree is send from the server in a serialized form,\n// the bigints are converted to strings and I can't figure out how to use tree.import to load bigints there\nexport function findIndexInTree(tree: LeanIMT, commitment: bigint): number {\n  let index = tree.indexOf(commitment);\n  if (index === -1) {\n    index = tree.indexOf(commitment.toString() as unknown as bigint);\n  }\n  if (index === -1) {\n    throw new Error('This commitment was not found in the tree');\n  } else {\n    //  console.log(`Index of commitment in the registry: ${index}`);\n  }\n  return index;\n}\n\nexport function formatInput(input: any) {\n  if (Array.isArray(input)) {\n    return input.map((item) => BigInt(item).toString());\n  } else if (input instanceof Uint8Array) {\n    return Array.from(input).map((num) => BigInt(num).toString());\n  } else if (typeof input === 'string' && input.includes(',')) {\n    const numbers = input\n      .split(',')\n      .map((s) => s.trim())\n      .filter((s) => s !== '' && !isNaN(Number(s)))\n      .map(Number);\n\n    try {\n      return numbers.map((num) => BigInt(num).toString());\n    } catch (e) {\n      throw e;\n    }\n  } else {\n    return [BigInt(input).toString()];\n  }\n}\n\nexport function generateCircuitInputsCountryVerifier(\n  passportData: PassportData,\n  sparsemerkletree: SMT\n) {\n  const mrz_bytes = formatMrz(passportData.mrz);\n  const usa_ascii = stringToAsciiBigIntArray('USA');\n  const country_leaf = getCountryLeaf(usa_ascii, mrz_bytes.slice(7, 10));\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, country_leaf);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    hostCountry: formatInput(usa_ascii),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsDSC(\n  passportData: PassportData,\n  serializedCscaTree: string[][]\n) {\n  const passportMetadata = passportData.passportMetadata;\n  const cscaParsed = passportData.csca_parsed;\n  const dscParsed = passportData.dsc_parsed;\n  const raw_dsc = passportData.dsc;\n  // CSCA is padded with 0s to max_csca_bytes\n  const cscaTbsBytesPadded = padWithZeroes(cscaParsed.tbsBytes, max_csca_bytes);\n  const dscTbsBytes = dscParsed.tbsBytes;\n\n  // DSC is padded using sha padding because it will be hashed in the circuit\n  const [dscTbsBytesPadded, dscTbsBytesLen] = pad(passportMetadata.cscaHashFunction)(\n    dscTbsBytes,\n    max_dsc_bytes\n  );\n  const leaf = getLeafCscaTree(cscaParsed);\n  const [root, path, siblings] = getCscaTreeInclusionProof(leaf, serializedCscaTree);\n  // Parse CSCA certificate and get its public key\n  const csca_pubKey_formatted = getCertificatePubKey(\n    cscaParsed,\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction\n  );\n\n  const signatureRaw = extractSignatureFromDSC(raw_dsc);\n  const signature = formatSignatureDSCCircuit(\n    passportMetadata.cscaSignatureAlgorithm,\n    passportMetadata.cscaHashFunction,\n    cscaParsed,\n    signatureRaw\n  );\n  // Get start index of CSCA pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    cscaParsed,\n    cscaTbsBytesPadded,\n    passportMetadata.cscaSignatureAlgorithm\n  );\n  return {\n    raw_csca: cscaTbsBytesPadded.map((x) => x.toString()),\n    raw_csca_actual_length: BigInt(cscaParsed.tbsBytes.length).toString(),\n    csca_pubKey_offset: startIndex.toString(),\n    csca_pubKey_actual_size: BigInt(keyLength).toString(),\n    raw_dsc: Array.from(dscTbsBytesPadded).map((x) => x.toString()),\n    raw_dsc_padded_length: BigInt(dscTbsBytesLen).toString(), // with the sha padding actually\n    csca_pubKey: csca_pubKey_formatted,\n    signature,\n    merkle_root: root,\n    path: path,\n    siblings: siblings,\n  };\n}\n\nexport function generateCircuitInputsOfac(\n  passportData: PassportData,\n  sparsemerkletree: SMT,\n  proofLevel: number\n) {\n  const { mrz, documentType } = passportData;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const mrz_bytes = formatMrz(mrz); // Assume formatMrz handles basic formatting\n  const nameSlice = isPassportType\n    ? mrz_bytes.slice(5 + 5, 44 + 5)\n    : mrz_bytes.slice(60 + 5, 90 + 5);\n  const dobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 63 + 5)\n    : mrz_bytes.slice(30 + 5, 36 + 5);\n  const yobSlice = isPassportType\n    ? mrz_bytes.slice(57 + 5, 59 + 5)\n    : mrz_bytes.slice(30 + 5, 32 + 5);\n  const nationalitySlice = isPassportType\n    ? mrz_bytes.slice(54 + 5, 57 + 5)\n    : mrz_bytes.slice(45 + 5, 48 + 5);\n  const passNoSlice = isPassportType\n    ? mrz_bytes.slice(44 + 5, 53 + 5)\n    : mrz_bytes.slice(5 + 5, 14 + 5);\n\n  let leafToProve: bigint;\n\n  if (proofLevel == 3) {\n    if (!isPassportType) {\n      throw new Error(\n        'Proof level 3 (Passport Number) is only applicable to passport document types.'\n      );\n    }\n    leafToProve = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n  } else if (proofLevel == 2) {\n    leafToProve = getNameDobLeaf(nameSlice, dobSlice);\n  } else if (proofLevel == 1) {\n    leafToProve = getNameYobLeaf(nameSlice, yobSlice);\n  } else {\n    throw new Error('Invalid proof level specified for OFAC check.');\n  }\n\n  const { root, closestleaf, siblings } = generateSMTProof(sparsemerkletree, leafToProve);\n\n  return {\n    dg1: formatInput(mrz_bytes),\n    smt_leaf_key: formatInput(closestleaf),\n    smt_root: formatInput(root),\n    smt_siblings: formatInput(siblings),\n  };\n}\n\nexport function generateCircuitInputsRegister(\n  secret: string,\n  passportData: PassportData,\n  serializedDscTree: string\n) {\n  const { mrz, eContent, signedAttr } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const dscParsed = passportData.dsc_parsed;\n\n  const [dscTbsBytesPadded] = pad(dscParsed.hashAlgorithm)(dscParsed.tbsBytes, max_dsc_bytes);\n\n  const { pubKey, signature, signatureAlgorithmFullName } = getPassportSignatureInfos(passportData);\n  const mrz_formatted = formatMrz(mrz);\n\n  if (eContent.length > MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]) {\n    console.error(\n      `eContent too long (${eContent.length} bytes). Max length is ${MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]} bytes.`\n    );\n    throw new Error(\n      `This length of datagroups (${eContent.length} bytes) is currently unsupported. Please contact us so we add support!`\n    );\n  }\n\n  const [eContentPadded, eContentLen] = pad(passportMetadata.eContentHashFunction)(\n    eContent,\n    MAX_PADDED_ECONTENT_LEN[passportMetadata.dg1HashFunction]\n  );\n  const [signedAttrPadded, signedAttrPaddedLen] = pad(passportMetadata.signedAttrHashFunction)(\n    signedAttr,\n    MAX_PADDED_SIGNED_ATTR_LEN[passportMetadata.eContentHashFunction]\n  );\n\n  const dsc_leaf = getLeafDscTree(dscParsed, passportData.csca_parsed); // TODO: WRONG\n  const [root, path, siblings, leaf_depth] = getDscTreeInclusionProof(dsc_leaf, serializedDscTree);\n  const csca_tree_leaf = getLeafCscaTree(passportData.csca_parsed);\n\n  // Get start index of DSC pubkey based on algorithm\n  const [startIndex, keyLength] = findStartPubKeyIndex(\n    dscParsed,\n    dscTbsBytesPadded,\n    dscParsed.signatureAlgorithm\n  );\n\n  const inputs = {\n    raw_dsc: dscTbsBytesPadded.map((x) => x.toString()),\n    raw_dsc_actual_length: [BigInt(dscParsed.tbsBytes.length).toString()],\n    dsc_pubKey_offset: startIndex,\n    dsc_pubKey_actual_size: [BigInt(keyLength).toString()],\n    dg1: mrz_formatted,\n    dg1_hash_offset: passportMetadata.dg1HashOffset,\n    eContent: eContentPadded,\n    eContent_padded_length: eContentLen,\n    signed_attr: signedAttrPadded,\n    signed_attr_padded_length: signedAttrPaddedLen,\n    signed_attr_econtent_hash_offset: passportMetadata.eContentHashOffset,\n    pubKey_dsc: pubKey,\n    signature_passport: signature,\n    merkle_root: [BigInt(root).toString()],\n    leaf_depth: leaf_depth,\n    path: path,\n    siblings: siblings,\n    csca_tree_leaf: csca_tree_leaf,\n    secret: secret,\n  };\n\n  return Object.entries(inputs)\n    .map(([key, value]) => ({\n      [key]: formatInput(value),\n    }))\n    .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n}\n\nexport function generateCircuitInputsVCandDisclose(\n  secret: string,\n  attestation_id: string,\n  passportData: PassportData,\n  scope: string,\n  selector_dg1: string[],\n  selector_older_than: string | number,\n  merkletree: LeanIMT,\n  majority: string,\n  passportNo_smt: SMT | null,\n  nameAndDob_smt: SMT,\n  nameAndYob_smt: SMT,\n  selector_ofac: string | number,\n  forbidden_countries_list: string[],\n  user_identifier: string\n) {\n  const { mrz, eContent, signedAttr, documentType } = passportData;\n  const passportMetadata = passportData.passportMetadata;\n  const isPassportType = documentType === 'passport' || documentType === 'mock_passport';\n\n  const formattedMrz = formatMrz(mrz);\n\n  const eContent_shaBytes = hash(\n    passportMetadata.eContentHashFunction,\n    Array.from(eContent),\n    'bytes'\n  );\n  const eContent_packed_hash = packBytesAndPoseidon(\n    (eContent_shaBytes as number[]).map((byte) => byte & 0xff)\n  );\n\n  const dsc_tree_leaf = getLeafDscTree(passportData.dsc_parsed, passportData.csca_parsed);\n\n  const commitment = generateCommitment(secret, attestation_id, passportData);\n  const index = findIndexInTree(merkletree, BigInt(commitment));\n  const { siblings, path, leaf_depth } = generateMerkleProof(\n    merkletree,\n    index,\n    COMMITMENT_TREE_DEPTH\n  );\n  const formattedMajority = majority.length === 1 ? `0${majority}` : majority;\n  const majority_ascii = formattedMajority.split('').map((char) => char.charCodeAt(0));\n\n  // Define default values for SMT proofs (BigInt(0) for roots/keys, array of 0s for siblings)\n  const defaultSiblings = Array(OFAC_TREE_LEVELS).fill(BigInt(0));\n  let passportNoProof = {\n    root: BigInt(0),\n    closestleaf: BigInt(0),\n    siblings: defaultSiblings,\n  };\n  let nameDobProof;\n  let nameYobProof;\n\n  // Calculate leaves based on document type (using OFAC logic for slicing)\n  const nameSlice = isPassportType ? formattedMrz.slice(10, 49) : formattedMrz.slice(65, 95);\n  const dobSlice = isPassportType ? formattedMrz.slice(62, 68) : formattedMrz.slice(35, 41);\n  const yobSlice = isPassportType ? formattedMrz.slice(62, 64) : formattedMrz.slice(35, 37);\n  const nationalitySlice = isPassportType ? formattedMrz.slice(59, 62) : formattedMrz.slice(50, 53);\n  const passNoSlice = isPassportType ? formattedMrz.slice(49, 58) : formattedMrz.slice(10, 19);\n\n  const namedob_leaf = getNameDobLeaf(nameSlice, dobSlice);\n  const nameyob_leaf = getNameYobLeaf(nameSlice, yobSlice);\n\n  // Generate Name/DOB and Name/YOB proofs (always needed)\n  nameDobProof = generateSMTProof(nameAndDob_smt, namedob_leaf);\n  nameYobProof = generateSMTProof(nameAndYob_smt, nameyob_leaf);\n\n  // Generate Passport Number proof only if it's a passport type and SMT is provided\n  if (isPassportType) {\n    if (!passportNo_smt) {\n      console.warn('Document type is passport, but passportNo_smt tree was not provided.');\n    } else {\n      const passportNo_leaf = getPassportNumberAndNationalityLeaf(passNoSlice, nationalitySlice);\n      const proofResult = generateSMTProof(passportNo_smt, passportNo_leaf);\n      // Explicitly cast root and closestleaf to bigint\n      passportNoProof = {\n        root: BigInt(proofResult.root),\n        closestleaf: BigInt(proofResult.closestleaf),\n        siblings: proofResult.siblings,\n      };\n    }\n  }\n  // Build Final Input Object\n  const baseInputs = {\n    secret: formatInput(secret),\n    attestation_id: formatInput(attestation_id),\n    dg1: formatInput(formattedMrz),\n    eContent_shaBytes_packed_hash: formatInput(eContent_packed_hash),\n    dsc_tree_leaf: formatInput(dsc_tree_leaf),\n    merkle_root: formatInput(merkletree.root),\n    leaf_depth: formatInput(leaf_depth),\n    path: formatInput(path),\n    siblings: formatInput(siblings),\n    selector_dg1: formatInput(selector_dg1),\n    selector_older_than: formatInput(selector_older_than),\n    scope: formatInput(scope),\n    current_date: formatInput(getCurrentDateYYMMDD()),\n    majority: formatInput(majority_ascii),\n    user_identifier: formatInput(user_identifier),\n    selector_ofac: formatInput(selector_ofac),\n    forbidden_countries_list: formatInput(formatCountriesList(forbidden_countries_list)),\n  };\n\n  const ofacNameInputs = {\n    ofac_namedob_smt_root: formatInput(nameDobProof.root),\n    ofac_namedob_smt_leaf_key: formatInput(nameDobProof.closestleaf),\n    ofac_namedob_smt_siblings: formatInput(nameDobProof.siblings),\n    ofac_nameyob_smt_root: formatInput(nameYobProof.root),\n    ofac_nameyob_smt_leaf_key: formatInput(nameYobProof.closestleaf),\n    ofac_nameyob_smt_siblings: formatInput(nameYobProof.siblings),\n  };\n\n  // Conditionally include passport OFAC inputs\n  const finalInputs = {\n    ...baseInputs,\n    ...ofacNameInputs,\n    ...(isPassportType && {\n      ofac_passportno_smt_root: formatInput(passportNoProof.root),\n      ofac_passportno_smt_leaf_key: formatInput(passportNoProof.closestleaf),\n      ofac_passportno_smt_siblings: formatInput(passportNoProof.siblings),\n    }),\n  };\n\n  return finalInputs;\n}\n"],"mappings":"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","names":["countries","en"]}