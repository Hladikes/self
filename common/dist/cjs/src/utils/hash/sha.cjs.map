{"version":3,"sources":["../../../../../src/utils/hash/sha.ts","../../../../../src/utils/hash.ts","../../../../../src/utils/bytes.ts"],"sourcesContent":["export { getHashLen, hash } from '../hash.js';\n","import { ethers } from 'ethers';\n// @ts-ignore - ESLint incorrectly flags this as needing default import, but TypeScript definitions use named export\nimport { sha1 } from 'js-sha1';\nimport { sha224, sha256 } from 'js-sha256';\nimport { sha384, sha512 } from 'js-sha512';\nimport * as forge from 'node-forge';\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from 'poseidon-lite';\n\nimport { hexToSignedBytes, packBytesArray } from './bytes.js';\n\nexport function calculateUserIdentifierHash(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): BigInt {\n  const solidityPackedUserContextData = getSolidityPackedUserContextData(\n    destChainID,\n    userID,\n    userDefinedData\n  );\n  const inputBytes = Buffer.from(solidityPackedUserContextData.slice(2), 'hex');\n  const sha256Hash = ethers.sha256(inputBytes);\n  const ripemdHash = ethers.ripemd160(sha256Hash);\n  return BigInt(ripemdHash);\n}\n\nexport function customHasher(pubKeyFormatted: string[]) {\n  if (pubKeyFormatted.length < 16) {\n    // if k is less than 16, we can use a single poseidon hash\n    return flexiblePoseidon(pubKeyFormatted.map(BigInt)).toString();\n  } else {\n    const rounds = Math.ceil(pubKeyFormatted.length / 16); // do up to 16 rounds of poseidon\n    if (rounds > 16) {\n      throw new Error('Number of rounds is greater than 16');\n    }\n    const hash = new Array(rounds);\n    for (let i = 0; i < rounds; i++) {\n      hash[i] = { inputs: new Array(16).fill(BigInt(0)) };\n    }\n    for (let i = 0; i < rounds; i++) {\n      for (let j = 0; j < 16; j++) {\n        if (i * 16 + j < pubKeyFormatted.length) {\n          hash[i].inputs[j] = BigInt(pubKeyFormatted[i * 16 + j]);\n        }\n      }\n    }\n    const finalHash = flexiblePoseidon(hash.map((h) => poseidon16(h.inputs)));\n    return finalHash.toString();\n  }\n}\n\nexport function flexiblePoseidon(inputs: bigint[]): bigint {\n  switch (inputs.length) {\n    case 1:\n      return poseidon1(inputs);\n    case 2:\n      return poseidon2(inputs);\n    case 3:\n      return poseidon3(inputs);\n    case 4:\n      return poseidon4(inputs);\n    case 5:\n      return poseidon5(inputs);\n    case 6:\n      return poseidon6(inputs);\n    case 7:\n      return poseidon7(inputs);\n    case 8:\n      return poseidon8(inputs);\n    case 9:\n      return poseidon9(inputs);\n    case 10:\n      return poseidon10(inputs);\n    case 11:\n      return poseidon11(inputs);\n    case 12:\n      return poseidon12(inputs);\n    case 13:\n      return poseidon13(inputs);\n    case 14:\n      return poseidon14(inputs);\n    case 15:\n      return poseidon15(inputs);\n    case 16:\n      return poseidon16(inputs);\n    default:\n      throw new Error(`Unsupported number of inputs: ${inputs.length}`);\n  }\n}\n\nexport function getHashLen(hashFunction: string) {\n  switch (hashFunction) {\n    case 'sha1':\n      return 20;\n    case 'sha224':\n      return 28;\n    case 'sha256':\n      return 32;\n    case 'sha384':\n      return 48;\n    case 'sha512':\n      return 64;\n    default:\n      console.log(`${hashFunction} not found in getHashLen`);\n      return 32;\n  }\n}\n\nexport function getSolidityPackedUserContextData(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): string {\n  const userIdHex = userID.replace(/-/g, '');\n  return ethers.solidityPacked(\n    ['bytes32', 'bytes32', 'bytes'],\n    [\n      ethers.zeroPadValue(ethers.toBeHex(destChainID), 32),\n      ethers.zeroPadValue('0x' + userIdHex, 32),\n      ethers.toUtf8Bytes(userDefinedData),\n    ]\n  );\n}\n\n// hash function - crypto is not supported in react native\nexport function hash(\n  hashFunction: string,\n  bytesArray: number[],\n  format: string = 'bytes'\n): string | number[] {\n  const unsignedBytesArray = bytesArray.map((byte) => byte & 0xff);\n  let hashResult: string;\n\n  switch (hashFunction) {\n    case 'sha1':\n      hashResult = sha1(unsignedBytesArray);\n      break;\n    case 'sha224':\n      hashResult = sha224(unsignedBytesArray);\n      break;\n    case 'sha256':\n      hashResult = sha256(unsignedBytesArray);\n      break;\n    case 'sha384':\n      hashResult = sha384(unsignedBytesArray);\n      break;\n    case 'sha512':\n      hashResult = sha512(unsignedBytesArray);\n      break;\n    default:\n      console.log('\\x1b[31m%s\\x1b[0m', `${hashFunction} not found in hash`); // Log in red\n      hashResult = sha256(unsignedBytesArray); // Default to sha256\n  }\n  if (format === 'hex') {\n    return hashResult;\n  }\n  if (format === 'bytes') {\n    return hexToSignedBytes(hashResult);\n  }\n  const actualForgeUtil = forge.util ? forge.util : (forge as any).default.util;\n  if (format === 'binary') {\n    return actualForgeUtil.binary.raw.encode(new Uint8Array(hexToSignedBytes(hashResult)));\n  }\n  throw new Error(`Invalid format: ${format}`);\n}\n\nexport function packBytesAndPoseidon(unpacked: number[]) {\n  const packed = packBytesArray(unpacked);\n  return customHasher(packed.map(String)).toString();\n}\n","import { MAX_BYTES_IN_FIELD } from '../constants/constants.js';\n\nexport function bigIntToChunkedBytes(\n  num: BigInt | bigint,\n  bytesPerChunk: number,\n  numChunks: number\n) {\n  const res: string[] = [];\n  const bigintNum: bigint = typeof num == 'bigint' ? num : num.valueOf();\n  const msk = (1n << BigInt(bytesPerChunk)) - 1n;\n  for (let i = 0; i < numChunks; ++i) {\n    res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());\n  }\n  return res;\n}\nexport function bytesToBigDecimal(arr: number[]): string {\n  let result = BigInt(0);\n  for (let i = 0; i < arr.length; i++) {\n    result = result * BigInt(256) + BigInt(arr[i] & 0xff);\n  }\n  return result.toString();\n}\n\nexport function computeIntChunkLength(byteLength: number) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const remain = byteLength % packSize;\n  let numChunks = (byteLength - remain) / packSize;\n  if (remain > 0) {\n    numChunks += 1;\n  }\n  return numChunks;\n}\n\nexport function derToBytes(derValue: string) {\n  const bytes = [];\n  for (let i = 0; i < derValue.length; i++) {\n    bytes.push(derValue.charCodeAt(i));\n  }\n  return bytes;\n}\n\nexport function hexStringToSignedIntArray(hexString: string) {\n  const result = [];\n  for (let i = 0; i < hexString.length; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    result.push(byte > 127 ? byte - 256 : byte);\n  }\n  return result;\n}\n\nexport function hexToBin(n: string): string {\n  let bin = Number(`0x${n[0]}`).toString(2);\n  for (let i = 1; i < n.length; i += 1) {\n    bin += Number(`0x${n[i]}`).toString(2).padStart(4, '0');\n  }\n  return bin;\n}\n\nexport function hexToDecimal(hex: string): string {\n  return BigInt(`0x${hex}`).toString();\n}\n\nexport function hexToSignedBytes(hexString: string): number[] {\n  const bytes = [];\n  for (let i = 0; i < hexString.length - 1; i += 2) {\n    const byte = parseInt(hexString.substr(i, 2), 16);\n    bytes.push(byte >= 128 ? byte - 256 : byte);\n  }\n  return bytes;\n}\n\nexport function num2Bits(n: number, inValue: bigint): bigint[] {\n  const out: bigint[] = new Array(n).fill(BigInt(0));\n  let lc1: bigint = BigInt(0);\n  let e2: bigint = BigInt(1);\n\n  for (let i = 0; i < n; i++) {\n    out[i] = (inValue >> BigInt(i)) & BigInt(1);\n\n    if (out[i] !== BigInt(0) && out[i] !== BigInt(1)) {\n      throw new Error('Bit value is not binary.');\n    }\n\n    lc1 += out[i] * e2;\n    e2 = e2 << BigInt(1);\n  }\n\n  if (lc1 !== inValue) {\n    throw new Error('Reconstructed value does not match the input.');\n  }\n  return out;\n}\n\nexport function packBytes(unpacked) {\n  const bytesCount = [31, 31, 31];\n  const packed = [0n, 0n, 0n];\n\n  let byteIndex = 0;\n  for (let i = 0; i < bytesCount.length; i++) {\n    for (let j = 0; j < bytesCount[i]; j++) {\n      if (byteIndex < unpacked.length) {\n        packed[i] |= BigInt(unpacked[byteIndex]) << (BigInt(j) * 8n);\n      }\n      byteIndex++;\n    }\n  }\n  return packed;\n}\n\nexport function packBytesArray(unpacked: number[]) {\n  const packSize = MAX_BYTES_IN_FIELD;\n  const maxBytes = unpacked.length;\n  const maxInts = computeIntChunkLength(maxBytes);\n  const out: bigint[] = new Array(maxInts).fill(0n);\n\n  for (let i = 0; i < maxInts; i++) {\n    let sum = 0n;\n    for (let j = 0; j < packSize; j++) {\n      const idx = packSize * i + j;\n\n      // Copy previous value if out of bounds\n      if (idx >= maxBytes) {\n        continue;\n      }\n      // First item of chunk is byte itself\n      else if (j === 0) {\n        sum = BigInt(unpacked[idx]);\n      }\n      // Every other item is 256^j * byte\n      else {\n        sum += (1n << BigInt(8 * j)) * BigInt(unpacked[idx]);\n      }\n    }\n    out[i] = sum;\n  }\n\n  return out;\n}\n\nexport function splitToWords(number: bigint, wordsize: number, numberElement: number) {\n  let t = number;\n  const words: string[] = [];\n  for (let i = 0; i < numberElement; ++i) {\n    const baseTwo = BigInt(2);\n\n    words.push(`${t % BigInt(Math.pow(Number(baseTwo), wordsize))}`);\n    t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), wordsize)));\n  }\n  if (!(t == BigInt(0))) {\n    throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;\n  }\n  return words;\n}\n\nexport const toBinaryString = (byte: any) => {\n  const binary = (parseInt(byte, 10) & 0xff).toString(2).padStart(8, '0');\n  return binary;\n};\n\nexport function toSigned(byte: number) {\n  return byte > 127 ? byte - 256 : byte;\n}\nexport function toUnsigned(byte: number) {\n  return byte & 0xff;\n}\nexport function toUnsignedByte(signedByte: number) {\n  return signedByte < 0 ? signedByte + 256 : signedByte;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,oBAAuB;AAEvB,qBAAqB;AACrB,uBAA+B;AAC/B,uBAA+B;AAC/B,YAAuB;AACvB,2BAiBO;;;ACuCA,SAAS,iBAAiB,WAA6B;AAC5D,QAAM,QAAQ,CAAC;AACf,WAAS,IAAI,GAAG,IAAI,UAAU,SAAS,GAAG,KAAK,GAAG;AAChD,UAAM,OAAO,SAAS,UAAU,OAAO,GAAG,CAAC,GAAG,EAAE;AAChD,UAAM,KAAK,QAAQ,MAAM,OAAO,MAAM,IAAI;AAAA,EAC5C;AACA,SAAO;AACT;;;ADsCO,SAAS,WAAW,cAAsB;AAC/C,UAAQ,cAAc;AAAA,IACpB,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,cAAQ,IAAI,GAAG,YAAY,0BAA0B;AACrD,aAAO;AAAA,EACX;AACF;AAmBO,SAAS,KACd,cACA,YACA,SAAiB,SACE;AACnB,QAAM,qBAAqB,WAAW,IAAI,CAAC,SAAS,OAAO,GAAI;AAC/D,MAAI;AAEJ,UAAQ,cAAc;AAAA,IACpB,KAAK;AACH,uBAAa,qBAAK,kBAAkB;AACpC;AAAA,IACF,KAAK;AACH,uBAAa,yBAAO,kBAAkB;AACtC;AAAA,IACF,KAAK;AACH,uBAAa,yBAAO,kBAAkB;AACtC;AAAA,IACF,KAAK;AACH,uBAAa,yBAAO,kBAAkB;AACtC;AAAA,IACF,KAAK;AACH,uBAAa,yBAAO,kBAAkB;AACtC;AAAA,IACF;AACE,cAAQ,IAAI,qBAAqB,GAAG,YAAY,oBAAoB;AACpE,uBAAa,yBAAO,kBAAkB;AAAA,EAC1C;AACA,MAAI,WAAW,OAAO;AACpB,WAAO;AAAA,EACT;AACA,MAAI,WAAW,SAAS;AACtB,WAAO,iBAAiB,UAAU;AAAA,EACpC;AACA,QAAM,kBAAwB,aAAa,aAAsB,cAAQ;AACzE,MAAI,WAAW,UAAU;AACvB,WAAO,gBAAgB,OAAO,IAAI,OAAO,IAAI,WAAW,iBAAiB,UAAU,CAAC,CAAC;AAAA,EACvF;AACA,QAAM,IAAI,MAAM,mBAAmB,MAAM,EAAE;AAC7C;","names":[]}