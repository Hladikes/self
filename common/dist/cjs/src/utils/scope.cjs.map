{"version":3,"sources":["../../../../src/utils/scope.ts","../../../../src/utils/hash.ts"],"sourcesContent":["import { poseidon2 } from 'poseidon-lite';\n\nimport { flexiblePoseidon } from './hash.js';\n\nexport function bigIntToString(bigInt: bigint): string {\n  if (bigInt === 0n) return '';\n\n  let result = '';\n  let tempBigInt = bigInt;\n\n  while (tempBigInt > 0n) {\n    const charCode = Number(tempBigInt & 0xffn);\n    result = String.fromCharCode(charCode) + result;\n    tempBigInt = tempBigInt >> 8n;\n  }\n\n  return result;\n}\n\nexport function formatEndpoint(endpoint: string): string {\n  if (!endpoint) return '';\n  return endpoint.replace(/^https?:\\/\\//, '').split('/')[0];\n}\n\nexport function hashEndpointWithScope(endpoint: string, scope: string): string {\n  const formattedEndpoint = formatEndpoint(endpoint);\n  const endpointChunks: string[] = [];\n  let remaining = formattedEndpoint;\n  while (remaining.length > 0) {\n    const chunk = remaining.slice(0, 31);\n    endpointChunks.push(chunk);\n    remaining = remaining.slice(31);\n  }\n  if (endpointChunks.length > 16) {\n    throw new Error('Endpoint must be less than 496 characters');\n  }\n  const chunkedEndpointBigInts = endpointChunks.map(stringToBigInt);\n  const endpointHash = flexiblePoseidon(chunkedEndpointBigInts);\n  const scopeBigInt = stringToBigInt(scope);\n  return poseidon2([endpointHash, scopeBigInt]).toString();\n}\n\nexport function stringToBigInt(str: string): bigint {\n  // Validate input contains only ASCII characters\n  if (!/^[\\x00-\\x7F]*$/.test(str)) {\n    throw new Error('Input must contain only ASCII characters (0-127)');\n  }\n\n  let result = 0n;\n  for (let i = 0; i < str.length; i++) {\n    result = (result << 8n) | BigInt(str.charCodeAt(i));\n  }\n\n  // Check size limit\n  const MAX_VALUE = (1n << 248n) - 1n;\n  if (result > MAX_VALUE) {\n    console.log(`str: ${str}, str.length: ${str.length}`);\n    throw new Error('Resulting BigInt exceeds maximum size of 31 bytes');\n  }\n\n  return result;\n}\n","import { ethers } from 'ethers';\n// @ts-ignore - ESLint incorrectly flags this as needing default import, but TypeScript definitions use named export\nimport { sha1 } from 'js-sha1';\nimport { sha224, sha256 } from 'js-sha256';\nimport { sha384, sha512 } from 'js-sha512';\nimport * as forge from 'node-forge';\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from 'poseidon-lite';\n\nimport { hexToSignedBytes, packBytesArray } from './bytes.js';\n\nexport function calculateUserIdentifierHash(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): BigInt {\n  const solidityPackedUserContextData = getSolidityPackedUserContextData(\n    destChainID,\n    userID,\n    userDefinedData\n  );\n  const inputBytes = Buffer.from(solidityPackedUserContextData.slice(2), 'hex');\n  const sha256Hash = ethers.sha256(inputBytes);\n  const ripemdHash = ethers.ripemd160(sha256Hash);\n  return BigInt(ripemdHash);\n}\n\nexport function customHasher(pubKeyFormatted: string[]) {\n  if (pubKeyFormatted.length < 16) {\n    // if k is less than 16, we can use a single poseidon hash\n    return flexiblePoseidon(pubKeyFormatted.map(BigInt)).toString();\n  } else {\n    const rounds = Math.ceil(pubKeyFormatted.length / 16); // do up to 16 rounds of poseidon\n    if (rounds > 16) {\n      throw new Error('Number of rounds is greater than 16');\n    }\n    const hash = new Array(rounds);\n    for (let i = 0; i < rounds; i++) {\n      hash[i] = { inputs: new Array(16).fill(BigInt(0)) };\n    }\n    for (let i = 0; i < rounds; i++) {\n      for (let j = 0; j < 16; j++) {\n        if (i * 16 + j < pubKeyFormatted.length) {\n          hash[i].inputs[j] = BigInt(pubKeyFormatted[i * 16 + j]);\n        }\n      }\n    }\n    const finalHash = flexiblePoseidon(hash.map((h) => poseidon16(h.inputs)));\n    return finalHash.toString();\n  }\n}\n\nexport function flexiblePoseidon(inputs: bigint[]): bigint {\n  switch (inputs.length) {\n    case 1:\n      return poseidon1(inputs);\n    case 2:\n      return poseidon2(inputs);\n    case 3:\n      return poseidon3(inputs);\n    case 4:\n      return poseidon4(inputs);\n    case 5:\n      return poseidon5(inputs);\n    case 6:\n      return poseidon6(inputs);\n    case 7:\n      return poseidon7(inputs);\n    case 8:\n      return poseidon8(inputs);\n    case 9:\n      return poseidon9(inputs);\n    case 10:\n      return poseidon10(inputs);\n    case 11:\n      return poseidon11(inputs);\n    case 12:\n      return poseidon12(inputs);\n    case 13:\n      return poseidon13(inputs);\n    case 14:\n      return poseidon14(inputs);\n    case 15:\n      return poseidon15(inputs);\n    case 16:\n      return poseidon16(inputs);\n    default:\n      throw new Error(`Unsupported number of inputs: ${inputs.length}`);\n  }\n}\n\nexport function getHashLen(hashFunction: string) {\n  switch (hashFunction) {\n    case 'sha1':\n      return 20;\n    case 'sha224':\n      return 28;\n    case 'sha256':\n      return 32;\n    case 'sha384':\n      return 48;\n    case 'sha512':\n      return 64;\n    default:\n      console.log(`${hashFunction} not found in getHashLen`);\n      return 32;\n  }\n}\n\nexport function getSolidityPackedUserContextData(\n  destChainID: number,\n  userID: string,\n  userDefinedData: string\n): string {\n  const userIdHex = userID.replace(/-/g, '');\n  return ethers.solidityPacked(\n    ['bytes32', 'bytes32', 'bytes'],\n    [\n      ethers.zeroPadValue(ethers.toBeHex(destChainID), 32),\n      ethers.zeroPadValue('0x' + userIdHex, 32),\n      ethers.toUtf8Bytes(userDefinedData),\n    ]\n  );\n}\n\n// hash function - crypto is not supported in react native\nexport function hash(\n  hashFunction: string,\n  bytesArray: number[],\n  format: string = 'bytes'\n): string | number[] {\n  const unsignedBytesArray = bytesArray.map((byte) => byte & 0xff);\n  let hashResult: string;\n\n  switch (hashFunction) {\n    case 'sha1':\n      hashResult = sha1(unsignedBytesArray);\n      break;\n    case 'sha224':\n      hashResult = sha224(unsignedBytesArray);\n      break;\n    case 'sha256':\n      hashResult = sha256(unsignedBytesArray);\n      break;\n    case 'sha384':\n      hashResult = sha384(unsignedBytesArray);\n      break;\n    case 'sha512':\n      hashResult = sha512(unsignedBytesArray);\n      break;\n    default:\n      console.log('\\x1b[31m%s\\x1b[0m', `${hashFunction} not found in hash`); // Log in red\n      hashResult = sha256(unsignedBytesArray); // Default to sha256\n  }\n  if (format === 'hex') {\n    return hashResult;\n  }\n  if (format === 'bytes') {\n    return hexToSignedBytes(hashResult);\n  }\n  const actualForgeUtil = forge.util ? forge.util : (forge as any).default.util;\n  if (format === 'binary') {\n    return actualForgeUtil.binary.raw.encode(new Uint8Array(hexToSignedBytes(hashResult)));\n  }\n  throw new Error(`Invalid format: ${format}`);\n}\n\nexport function packBytesAndPoseidon(unpacked: number[]) {\n  const packed = packBytesArray(unpacked);\n  return customHasher(packed.map(String)).toString();\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,wBAA0B;;;ACA1B,oBAAuB;AAEvB,qBAAqB;AACrB,uBAA+B;AAC/B,uBAA+B;AAC/B,YAAuB;AACvB,2BAiBO;AA6CA,SAAS,iBAAiB,QAA0B;AACzD,UAAQ,OAAO,QAAQ;AAAA,IACrB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,gCAAU,MAAM;AAAA,IACzB,KAAK;AACH,iBAAO,iCAAW,MAAM;AAAA,IAC1B,KAAK;AACH,iBAAO,iCAAW,MAAM;AAAA,IAC1B,KAAK;AACH,iBAAO,iCAAW,MAAM;AAAA,IAC1B,KAAK;AACH,iBAAO,iCAAW,MAAM;AAAA,IAC1B,KAAK;AACH,iBAAO,iCAAW,MAAM;AAAA,IAC1B,KAAK;AACH,iBAAO,iCAAW,MAAM;AAAA,IAC1B,KAAK;AACH,iBAAO,iCAAW,MAAM;AAAA,IAC1B;AACE,YAAM,IAAI,MAAM,iCAAiC,OAAO,MAAM,EAAE;AAAA,EACpE;AACF;;;ADrGO,SAAS,eAAe,QAAwB;AACrD,MAAI,WAAW,GAAI,QAAO;AAE1B,MAAI,SAAS;AACb,MAAI,aAAa;AAEjB,SAAO,aAAa,IAAI;AACtB,UAAM,WAAW,OAAO,aAAa,KAAK;AAC1C,aAAS,OAAO,aAAa,QAAQ,IAAI;AACzC,iBAAa,cAAc;AAAA,EAC7B;AAEA,SAAO;AACT;AAEO,SAAS,eAAe,UAA0B;AACvD,MAAI,CAAC,SAAU,QAAO;AACtB,SAAO,SAAS,QAAQ,gBAAgB,EAAE,EAAE,MAAM,GAAG,EAAE,CAAC;AAC1D;AAEO,SAAS,sBAAsB,UAAkB,OAAuB;AAC7E,QAAM,oBAAoB,eAAe,QAAQ;AACjD,QAAM,iBAA2B,CAAC;AAClC,MAAI,YAAY;AAChB,SAAO,UAAU,SAAS,GAAG;AAC3B,UAAM,QAAQ,UAAU,MAAM,GAAG,EAAE;AACnC,mBAAe,KAAK,KAAK;AACzB,gBAAY,UAAU,MAAM,EAAE;AAAA,EAChC;AACA,MAAI,eAAe,SAAS,IAAI;AAC9B,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC7D;AACA,QAAM,yBAAyB,eAAe,IAAI,cAAc;AAChE,QAAM,eAAe,iBAAiB,sBAAsB;AAC5D,QAAM,cAAc,eAAe,KAAK;AACxC,aAAO,iCAAU,CAAC,cAAc,WAAW,CAAC,EAAE,SAAS;AACzD;AAEO,SAAS,eAAe,KAAqB;AAElD,MAAI,CAAC,iBAAiB,KAAK,GAAG,GAAG;AAC/B,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACpE;AAEA,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,aAAU,UAAU,KAAM,OAAO,IAAI,WAAW,CAAC,CAAC;AAAA,EACpD;AAGA,QAAM,aAAa,MAAM,QAAQ;AACjC,MAAI,SAAS,WAAW;AACtB,YAAQ,IAAI,QAAQ,GAAG,iBAAiB,IAAI,MAAM,EAAE;AACpD,UAAM,IAAI,MAAM,mDAAmD;AAAA,EACrE;AAEA,SAAO;AACT;","names":["import_poseidon_lite"]}