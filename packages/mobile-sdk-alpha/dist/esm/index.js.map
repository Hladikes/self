{"version":3,"sources":["../../src/errors/SdkError.ts","../../src/errors/InitError.ts","../../src/errors/LivenessError.ts","../../src/errors/MrzParseError.ts","../../src/errors/NfcParseError.ts","../../src/errors/index.ts","../../src/components/screens/NFCScannerScreen.tsx","../../src/context.tsx","../../src/config/defaults.ts","../../src/config/merge.ts","../../src/processing/mrz.ts","../../src/client.ts","../../src/components/flows/OnboardingFlow.tsx","../../src/components/screens/PassportCameraScreen.tsx","../../src/components/screens/QRCodeScreen.tsx","../../src/entry/index.tsx","../../src/mrz/index.ts","../../src/validation/document.ts","../../src/processing/nfc.ts","../../src/nfc/index.ts","../../src/qr/index.ts","../../src/hooks/useDocumentManager.ts","../../src/adapters/web/shims.ts"],"sourcesContent":["interface ErrorOptions {\n  cause?: unknown;\n}\n\nexport type SdkErrorCategory =\n  | 'scanner'\n  | 'network'\n  | 'protocol'\n  | 'proof'\n  | 'crypto'\n  | 'validation'\n  | 'config'\n  | 'init'\n  | 'liveness';\n\n/**\n * Base class for all SDK errors.\n */\nexport class SdkError extends Error {\n  readonly code: string;\n  readonly category: SdkErrorCategory;\n  readonly retryable: boolean;\n  declare cause?: Error;\n\n  constructor(message: string, code: string, category: SdkErrorCategory, retryable = false, options?: ErrorOptions) {\n    super(message);\n    this.name = 'SdkError';\n    this.code = code;\n    this.category = category;\n    this.retryable = retryable;\n    if (options?.cause) {\n      this.cause = options.cause as Error;\n    }\n  }\n}\n\n/**\n * Helper to create an SDK error for an adapter that has not been provided.\n *\n * @param name - human-readable adapter name.\n * @returns configured {@link SdkError} instance.\n */\nexport function notImplemented(name: string) {\n  return new SdkError(`${name} adapter not provided`, 'SELF_ERR_ADAPTER_MISSING', 'config', false);\n}\n\n/**\n * Convenience factory for {@link SdkError}.\n *\n * @param message - error description.\n * @param code - unique error code.\n * @param category - high level error category.\n * @param retryable - whether the operation may be retried.\n * @returns configured {@link SdkError} instance.\n */\nexport function sdkError(message: string, code: string, category: SdkErrorCategory, retryable = false) {\n  return new SdkError(message, code, category, retryable);\n}\n","import { SdkError } from './SdkError';\n\n/**\n * Error thrown when the SDK fails to initialize correctly.\n *\n * @param message - description of the initialization failure.\n * @param options - optional underlying error details.\n */\nexport class InitError extends SdkError {\n  constructor(message: string, options?: { cause?: unknown }) {\n    super(message, 'SELF_ERR_INIT', 'init', false, options);\n    this.name = 'InitError';\n  }\n}\n","import { SdkError } from './SdkError';\n\n/**\n * Error thrown when liveness checks detect an issue.\n *\n * @param message - description of the liveness failure.\n * @param options - optional underlying error details.\n */\nexport class LivenessError extends SdkError {\n  constructor(message: string, options?: { cause?: unknown }) {\n    super(message, 'SELF_ERR_LIVENESS', 'liveness', false, options);\n    this.name = 'LivenessError';\n  }\n}\n","import { SdkError } from './SdkError';\n\n/**\n * Error thrown when an MRZ string fails validation or parsing.\n *\n * @param message - description of the MRZ parsing failure.\n * @param options - optional underlying error details.\n */\nexport class MrzParseError extends SdkError {\n  constructor(message: string, options?: { cause?: unknown }) {\n    super(message, 'SELF_ERR_MRZ_PARSE', 'validation', false, options);\n    this.name = 'MrzParseError';\n  }\n}\n","import { SdkError } from './SdkError';\n\n/**\n * Error thrown when NFC data cannot be parsed.\n *\n * @param message - description of the parsing failure.\n * @param options - optional underlying error details.\n */\nexport class NfcParseError extends SdkError {\n  constructor(message: string, options?: { cause?: unknown }) {\n    super(message, 'SELF_ERR_NFC_PARSE', 'validation', false, options);\n    this.name = 'NfcParseError';\n  }\n}\n","export { InitError } from './InitError';\n\nexport { LivenessError } from './LivenessError';\nexport { MrzParseError } from './MrzParseError';\nexport { NfcParseError } from './NfcParseError';\nexport const SCANNER_ERROR_CODES = {\n  UNAVAILABLE: 'SELF_ERR_SCANNER_UNAVAILABLE',\n  NFC_NOT_SUPPORTED: 'SELF_ERR_NFC_NOT_SUPPORTED',\n  INVALID_MODE: 'SELF_ERR_SCANNER_MODE',\n} as const;\n\nexport { SdkError, type SdkErrorCategory, notImplemented, sdkError } from './SdkError';\n","import { useCallback } from 'react';\nimport { Button, Text, YStack } from 'tamagui';\n\nimport { useSelfClient } from '../../context';\nimport type { ScreenProps } from '../../types/ui';\n\nexport const NFCScannerScreen = ({ onSuccess, onFailure }: ScreenProps) => {\n  const client = useSelfClient();\n\n  const onNFCScan = useCallback(\n    async (_nfcData: any) => {\n      try {\n        // scan the document\n        // register the document\n        onSuccess();\n      } catch (error) {\n        onFailure(error as Error);\n      }\n    },\n    [client, onSuccess, onFailure],\n  );\n\n  return (\n    <YStack space=\"$4\" padding=\"$4\">\n      <Text fontSize=\"$6\" fontWeight=\"bold\">\n        NFC Scanner\n      </Text>\n      <Button onPress={() => onNFCScan({})}>Simulate NFC Scan</Button>\n    </YStack>\n  );\n};\n","import { createContext, type PropsWithChildren, useContext, useMemo } from 'react';\n\nimport { createSelfClient } from './client';\nimport type { Adapters, Config, SelfClient } from './types/public';\n\n/**\n * React context holding a {@link SelfClient} instance.\n *\n * The context is intentionally initialised with `null` so that consumers\n * outside of a {@link SelfClientProvider} can be detected and an informative\n * error can be thrown.\n */\nconst SelfClientContext = createContext<SelfClient | null>(null);\n\n/**\n * Props for {@link SelfClientProvider}.\n *\n * @public\n */\nexport interface SelfClientProviderProps {\n  /** SDK configuration options. */\n  config: Config;\n  /**\n   * Partial set of adapter implementations. Any missing optional adapters will\n   * be replaced with default no-op implementations.\n   */\n  adapters?: Partial<Adapters>;\n}\n\nexport { SelfClientContext };\n\n/**\n * Provides a memoised {@link SelfClient} instance to all descendant components\n * via {@link SelfClientContext}.\n *\n * Consumers should ensure that `config` and `adapters` are referentially stable\n * (e.g. wrapped in `useMemo`) to avoid recreating the client on every render.\n */\nexport function SelfClientProvider({ config, adapters = {}, children }: PropsWithChildren<SelfClientProviderProps>) {\n  const client = useMemo(() => createSelfClient({ config, adapters }), [config, adapters]);\n\n  return <SelfClientContext.Provider value={client}>{children}</SelfClientContext.Provider>;\n}\n\n/**\n * Retrieves the current {@link SelfClient} from context.\n *\n * @throws If used outside of a {@link SelfClientProvider}.\n */\nexport function useSelfClient(): SelfClient {\n  const ctx = useContext(SelfClientContext);\n  if (!ctx) throw new Error('useSelfClient must be used within a SelfClientProvider');\n  return ctx;\n}\n","import type { Config } from '../types/public';\n\nexport const defaultConfig: Required<Config> = {\n  endpoints: { api: '', teeWs: '', artifactsCdn: '' },\n  timeouts: { httpMs: 30000, wsMs: 60000, scanMs: 60000, proofMs: 120000 },\n  features: {},\n  tlsPinning: { enabled: false },\n};\n","import type { Config } from '../types/public';\n\nexport function mergeConfig(base: Required<Config>, override: Config): Required<Config> {\n  return {\n    ...base,\n    ...override,\n    endpoints: { ...base.endpoints, ...(override.endpoints ?? {}) },\n    timeouts: { ...base.timeouts, ...(override.timeouts ?? {}) },\n    features: { ...base.features, ...(override.features ?? {}) },\n    tlsPinning: { ...base.tlsPinning, ...(override.tlsPinning ?? {}) },\n  };\n}\n","import { MrzParseError } from '../errors';\nimport type { MRZInfo, MRZValidation } from '../types/public';\n\n/**\n * Calculate check digit for MRZ fields using ICAO 9303 standard\n */\nfunction calculateCheckDigit(input: string): number {\n  const weights = [7, 3, 1];\n  let sum = 0;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    let value: number;\n\n    if (char >= '0' && char <= '9') {\n      value = parseInt(char, 10);\n    } else if (char >= 'A' && char <= 'Z') {\n      value = char.charCodeAt(0) - 'A'.charCodeAt(0) + 10;\n    } else if (char === '<') {\n      value = 0;\n    } else {\n      throw new MrzParseError(`Invalid character in MRZ: ${char}`);\n    }\n\n    sum += value * weights[i % 3];\n  }\n\n  return sum % 10;\n}\n\n/**\n * Verify check digit for a given field\n */\nfunction verifyCheckDigit(field: string, expectedCheckDigit: string): boolean {\n  // Only numeric check digits are valid per ICAO 9303\n  if (!/^\\d$/.test(expectedCheckDigit)) {\n    return false;\n  }\n  const expected = parseInt(expectedCheckDigit, 10);\n  try {\n    const calculated = calculateCheckDigit(field);\n    return calculated === expected;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Parse names from MRZ format (surname<<given<names<<<)\n * Handles complex cases like: VAN<<DER<<BERG<<MARIA<ELENA\n * Expected: surname=\"VAN  DER  BERG\", givenNames=\"MARIA ELENA\"\n */\nfunction parseNames(nameField: string): { surname: string; givenNames: string } {\n  const parts = nameField.split('<<');\n\n  if (parts.length === 1) {\n    // No '<<' found, entire field is surname\n    return {\n      surname: nameField.replace(/</g, ' ').trim(),\n      givenNames: '',\n    };\n  }\n\n  // Find the boundary between surname and given names\n  // Look for the last part that contains '<' (indicating given names with spaces)\n  let givenNamesStartIndex = parts.length; // Default to all surname\n\n  for (let i = parts.length - 1; i >= 0; i--) {\n    const part = parts[i];\n    // If a part contains '<' within it (not just trailing '<'), it's likely given names\n    if (part.includes('<') && !part.endsWith('<'.repeat(part.length))) {\n      givenNamesStartIndex = i;\n      break;\n    }\n  }\n\n  // If we didn't find a clear given names section, use the first << as boundary\n  if (givenNamesStartIndex >= parts.length) {\n    const firstDoubleSeparator = nameField.indexOf('<<');\n    if (firstDoubleSeparator === -1) {\n      return {\n        surname: nameField.replace(/</g, ' ').trim(),\n        givenNames: '',\n      };\n    }\n\n    const surnameField = nameField.slice(0, firstDoubleSeparator);\n    const givenNamesField = nameField.slice(firstDoubleSeparator + 2);\n\n    return {\n      surname: surnameField.replace(/</g, ' ').trim(),\n      givenNames: givenNamesField.replace(/</g, ' ').trim(),\n    };\n  }\n\n  // Build surname from parts before the given names (join with double spaces to reflect <<)\n  const surnameParts = parts.slice(0, givenNamesStartIndex);\n  const surname = surnameParts.join('  ').replace(/</g, ' ').trim();\n\n  // Build given names from remaining parts\n  const givenNamesParts = parts.slice(givenNamesStartIndex);\n  const givenNames = givenNamesParts.join(' ').replace(/</g, ' ').trim();\n\n  return { surname, givenNames };\n}\n\n/**\n * Validate TD3 MRZ format (passport/travel document)\n */\nfunction validateTD3Format(lines: string[]): boolean {\n  if (lines.length !== 2) {\n    return false;\n  }\n\n  // TD3 format: 2 lines, 44 characters each\n  return lines[0].length === 44 && lines[1].length === 44;\n}\n\n/**\n * Extract MRZ information from TD3 format\n * TD3 Line 1: DOCUMENTTYPE(1)SUBTYPE(1)ISSUINGCOUNTRY(3)SURNAME<<GIVENNAMES<<<<<<<<<<<<<<<<<<\n * TD3 Line 2: PASSPORT(9)CHECK(1)NATIONALITY(3)DOB(6)DOBCHECK(1)SEX(1)EXPIRY(6)EXPIRYCHECK(1)OPTIONAL(7)FINALCHECK(1)\n */\nfunction extractTD3Info(lines: string[]): Omit<MRZInfo, 'validation'> {\n  const line1 = lines[0];\n  const line2 = lines[1];\n\n  // Line 1: P<CCCSURNAME<<GIVENNAMES<<<<<<<<<<<<<<<<<<\n  const documentType = line1.slice(0, 1);\n  const issuingCountry = line1\n    .slice(2, 5)\n    .replace(/</g, '')\n    .replace(/[^A-Z]/g, '');\n  const nameField = line1.slice(5, 44);\n  const { surname, givenNames } = parseNames(nameField);\n\n  // Line 2: PASSPORT(9)CHECK(1)NATIONALITY(3)DOB(6)DOBCHECK(1)SEX(1)EXPIRY(6)EXPIRYCHECK(1)OPTIONAL(7)FINALCHECK(1)\n  const passportNumber = line2.slice(0, 9).replace(/</g, '');\n\n  // Robust nationality extraction: scan 4-character window for three contiguous A-Z letters\n  const rawNat = line2.slice(10, 14);\n  let nationality = '';\n\n  // Look for a 3-letter uppercase sequence in the window\n  for (let i = 0; i <= rawNat.length - 3; i++) {\n    const candidate = rawNat.slice(i, i + 3);\n    if (/^[A-Z]{3}$/.test(candidate)) {\n      nationality = candidate;\n      break;\n    }\n  }\n\n  // If no 3-letter sequence found, fall back to original slice(10,13) with non-letters removed\n  if (!nationality) {\n    nationality = rawNat.slice(0, 3).replace(/[^A-Z]/g, '');\n  }\n  const dateOfBirth = line2.slice(13, 19);\n  const sex = line2.slice(20, 21).replace(/</g, '');\n  const dateOfExpiry = line2.slice(21, 27);\n\n  return {\n    documentType,\n    issuingCountry,\n    surname,\n    givenNames,\n    passportNumber,\n    nationality,\n    dateOfBirth,\n    sex,\n    dateOfExpiry,\n  };\n}\n\n/**\n * Validate all check digits for TD3 MRZ\n * TD3 Line 2 format: PASSPORT(9)CHECK(1)NATIONALITY(3)DOB(6)DOBCHECK(1)SEX(1)EXPIRY(6)EXPIRYCHECK(1)PERSONAL(14)PERSONALCHECK(1)FINALCHECK(1)\n */\nfunction validateTD3CheckDigits(lines: string[]): Omit<MRZValidation, 'format' | 'overall'> {\n  const line2 = lines[1];\n\n  const passportNumber = line2.slice(0, 9);\n  const passportCheckDigit = line2.slice(9, 10);\n  const dateOfBirth = line2.slice(13, 19);\n  const dobCheckDigit = line2.slice(19, 20);\n  const dateOfExpiry = line2.slice(21, 27);\n  const expiryCheckDigit = line2.slice(27, 28);\n  // const personalNumber = line2.slice(28, 42); // Personal number (14 characters)\n  // const personalCheckDigit = line2.slice(42, 43); // Personal number check digit\n\n  // TD3 composite check: passport(9) + passportCheck(1) + dob(6) + dobCheck(1) + expiry(6) + expiryCheck(1) + personal(14) + personalCheck(1)\n  const compositeField = line2.slice(0, 10) + line2.slice(13, 20) + line2.slice(21, 28) + line2.slice(28, 43);\n  const compositeCheckDigit = line2.slice(43, 44); // Last character of line 2\n\n  return {\n    passportNumberChecksum: verifyCheckDigit(passportNumber, passportCheckDigit),\n    dateOfBirthChecksum: verifyCheckDigit(dateOfBirth, dobCheckDigit),\n    dateOfExpiryChecksum: verifyCheckDigit(dateOfExpiry, expiryCheckDigit),\n    compositeChecksum: verifyCheckDigit(compositeField, compositeCheckDigit),\n  };\n}\n\n/**\n * Extract and validate MRZ information from a machine-readable zone string\n * Supports TD3 format (passports) with comprehensive validation\n */\nexport function extractMRZInfo(mrzString: string): MRZInfo {\n  if (!mrzString || typeof mrzString !== 'string') {\n    throw new MrzParseError('MRZ string is required and must be a string');\n  }\n\n  const lines = mrzString\n    .trim()\n    .split('\\n')\n    .map(line => line.trim());\n\n  // Validate format\n  const isValidTD3 = validateTD3Format(lines);\n\n  if (!isValidTD3) {\n    throw new MrzParseError(\n      `Invalid MRZ format: Expected TD3 format (2 lines × 44 characters), got ${lines.length} lines with lengths [${lines.map(l => l.length).join(', ')}]`,\n    );\n  }\n\n  // Extract basic information\n  const info = extractTD3Info(lines);\n\n  // Validate check digits\n  const checksums = validateTD3CheckDigits(lines);\n\n  // Create validation result\n  const validation: MRZValidation = {\n    format: isValidTD3,\n    ...checksums,\n    overall: isValidTD3 && Object.values(checksums).every(Boolean),\n  };\n\n  return {\n    ...info,\n    validation,\n  };\n}\n\n/**\n * Format ISO date string (YYYY-MM-DD) to YYMMDD format\n * Handles timezone variations and validates input\n */\nexport function formatDateToYYMMDD(inputDate: string): string {\n  if (!inputDate || typeof inputDate !== 'string') {\n    throw new MrzParseError('Date string is required');\n  }\n\n  // Handle ISO date strings (YYYY-MM-DD format)\n  const isoMatch = inputDate.match(/^(\\d{4})-(\\d{2})-(\\d{2})/);\n  if (isoMatch) {\n    const [, year, month, day] = isoMatch;\n    return year.slice(2) + month + day;\n  }\n\n  // Handle other common formats\n  const dateMatch = inputDate.match(/^(\\d{2,4})[-/]?(\\d{2})[-/]?(\\d{2})/);\n  if (dateMatch) {\n    let [, year] = dateMatch;\n    const [, , month, day] = dateMatch;\n\n    // Handle 2-digit years (assume 20xx for 00-30, 19xx for 31-99)\n    if (year.length === 2) {\n      const yearNum = parseInt(year, 10);\n      year = yearNum <= 30 ? `20${year}` : `19${year}`;\n    }\n\n    return year.slice(2) + month + day;\n  }\n\n  throw new MrzParseError(`Invalid date format: ${inputDate}. Expected ISO format (YYYY-MM-DD) or similar.`);\n}\n","import { defaultConfig } from './config/defaults';\nimport { mergeConfig } from './config/merge';\nimport { notImplemented } from './errors';\nimport { extractMRZInfo as parseMRZInfo } from './processing/mrz';\nimport type {\n  Adapters,\n  Config,\n  Progress,\n  ProofHandle,\n  ProofRequest,\n  RegistrationInput,\n  RegistrationStatus,\n  ScanOpts,\n  ScanResult,\n  SDKEvent,\n  SDKEventMap,\n  SelfClient,\n  Unsubscribe,\n  ValidationInput,\n  ValidationResult,\n} from './types/public';\n\n/**\n * Optional adapter implementations used when a consumer does not provide their\n * own. These defaults are intentionally minimal no-ops suitable for tests and\n * non-production environments.\n */\nconst optionalDefaults: Partial<Adapters> = {\n  storage: {\n    get: async () => null,\n    set: async () => {},\n    remove: async () => {},\n  },\n  clock: {\n    now: () => Date.now(),\n    sleep: async (ms: number) => {\n      await new Promise(r => setTimeout(r, ms));\n    },\n  },\n  logger: {\n    log: () => {},\n  },\n};\n\n/**\n * Creates a fully configured {@link SelfClient} instance.\n *\n * The function validates that all required adapters are supplied and merges the\n * provided configuration with sensible defaults. Missing optional adapters are\n * filled with benign no-op implementations.\n */\nexport function createSelfClient({ config, adapters }: { config: Config; adapters: Partial<Adapters> }): SelfClient {\n  const cfg = mergeConfig(defaultConfig, config);\n  const required: (keyof Adapters)[] = ['scanner', 'network', 'crypto'];\n  for (const name of required) {\n    if (!(name in adapters) || !adapters[name]) throw notImplemented(name);\n  }\n\n  const _adapters = { ...optionalDefaults, ...adapters } as Adapters;\n  const listeners = new Map<SDKEvent, Set<(p: any) => void>>();\n\n  function on<E extends SDKEvent>(event: E, cb: (payload: SDKEventMap[E]) => void): Unsubscribe {\n    const set = listeners.get(event) ?? new Set();\n    set.add(cb as any);\n    listeners.set(event, set);\n    return () => set.delete(cb as any);\n  }\n\n  function emit<E extends SDKEvent>(event: E, payload: SDKEventMap[E]): void {\n    const set = listeners.get(event);\n    if (!set) return;\n    for (const cb of Array.from(set)) {\n      try {\n        (cb as (p: SDKEventMap[E]) => void)(payload);\n      } catch (err) {\n        _adapters.logger.log('error', `event-listener error for event '${event}'`, { event, error: err });\n      }\n    }\n  }\n\n  async function scanDocument(opts: ScanOpts & { signal?: AbortSignal }): Promise<ScanResult> {\n    return _adapters.scanner.scan(opts);\n  }\n\n  async function validateDocument(_input: ValidationInput): Promise<ValidationResult> {\n    return { ok: false, reason: 'SELF_ERR_VALIDATION_STUB' };\n  }\n\n  async function checkRegistration(_input: RegistrationInput): Promise<RegistrationStatus> {\n    return { registered: false, reason: 'SELF_REG_STATUS_STUB' };\n  }\n\n  async function registerDocument(_input: RegistrationInput): Promise<RegistrationStatus> {\n    return { registered: false, reason: 'SELF_REG_STATUS_STUB' };\n  }\n\n  async function generateProof(\n    _req: ProofRequest,\n    opts: {\n      signal?: AbortSignal;\n      onProgress?: (p: Progress) => void;\n      timeoutMs?: number;\n    } = {},\n  ): Promise<ProofHandle> {\n    if (!adapters.network) throw notImplemented('network');\n    if (!adapters.crypto) throw notImplemented('crypto');\n    const timeoutMs = opts.timeoutMs ?? cfg.timeouts?.proofMs ?? defaultConfig.timeouts.proofMs;\n    void _adapters.clock.sleep(timeoutMs!, opts.signal).then(() => emit('error', new Error('timeout')));\n    return {\n      id: 'stub',\n      status: 'pending',\n      result: async () => ({ ok: false, reason: 'SELF_ERR_PROOF_STUB' }),\n      cancel: () => {},\n    };\n  }\n\n  return {\n    scanDocument,\n    validateDocument,\n    checkRegistration,\n    registerDocument,\n    generateProof,\n    extractMRZInfo: parseMRZInfo,\n    on,\n    emit,\n  };\n}\n","import type { ComponentType } from 'react';\nimport { useCallback, useState } from 'react';\n\nimport { useSelfClient } from '../../context';\nimport type { MRZInfo } from '../../types/public';\nimport type { DocumentData, ExternalAdapter, PassportCameraProps, ScreenProps } from '../../types/ui';\nimport { NFCScannerScreen } from '../screens/NFCScannerScreen';\nimport { PassportCameraScreen } from '../screens/PassportCameraScreen';\n\ninterface OnboardingFlowProps {\n  external: ExternalAdapter;\n  setDocument: (doc: DocumentData, documentId: string) => Promise<boolean>;\n  PassportCamera?: ComponentType<PassportCameraProps>;\n  NFCScanner?: ComponentType<ScreenProps>;\n}\n\nexport const OnboardingFlow = ({ external, setDocument, PassportCamera, NFCScanner }: OnboardingFlowProps) => {\n  const [mrzData, setMrzData] = useState<MRZInfo | null>(null);\n  const client = useSelfClient();\n\n  const handleMRZDetected = useCallback(\n    async (mrzData: MRZInfo) => {\n      try {\n        const status = await client.registerDocument({\n          scan: {\n            mode: 'mrz',\n            passportNumber: mrzData.passportNumber,\n            dateOfBirth: mrzData.dateOfBirth,\n            dateOfExpiry: mrzData.dateOfExpiry,\n            issuingCountry: mrzData.issuingCountry,\n          },\n        });\n\n        if (status.registered) {\n          setMrzData(mrzData);\n        } else {\n          external.onOnboardingFailure(new Error('Registration failed'));\n        }\n      } catch (error) {\n        external.onOnboardingFailure(error as Error);\n      }\n    },\n    [client, external, setDocument],\n  );\n\n  if (!mrzData) {\n    if (PassportCamera) {\n      const PCam = PassportCamera as ComponentType<PassportCameraProps>;\n      return <PCam onMRZDetected={handleMRZDetected} />;\n    }\n    return <PassportCameraScreen onMRZDetected={handleMRZDetected} />;\n  }\n\n  if (NFCScanner) {\n    const NFC = NFCScanner as ComponentType<ScreenProps>;\n    return <NFC onSuccess={external.onOnboardingSuccess} onFailure={external.onOnboardingFailure} />;\n  }\n  return <NFCScannerScreen onSuccess={external.onOnboardingSuccess} onFailure={external.onOnboardingFailure} />;\n};\n","import { Button, Text, YStack } from 'tamagui';\n\nimport type { PassportCameraProps } from '../../types/ui';\n\n// Simple placeholder component - this would be replaced with actual camera UI\nexport const PassportCameraScreen = ({ onMRZDetected }: PassportCameraProps) => (\n  <YStack space=\"$4\" padding=\"$4\">\n    <Text fontSize=\"$6\" fontWeight=\"bold\">\n      Passport Camera\n    </Text>\n    <Button\n      onPress={() =>\n        onMRZDetected({\n          passportNumber: 'L898902C3',\n          dateOfBirth: '740812',\n          dateOfExpiry: '120415',\n          surname: 'ERIKSSON',\n          givenNames: 'ANNA MARIA',\n          sex: 'F',\n          nationality: 'UTO',\n          issuingCountry: 'UTO',\n          documentType: 'P',\n          validation: {\n            format: true,\n            passportNumberChecksum: true,\n            dateOfBirthChecksum: true,\n            dateOfExpiryChecksum: true,\n            compositeChecksum: true,\n            overall: true,\n          },\n        })\n      }\n    >\n      Simulate MRZ Detection\n    </Button>\n  </YStack>\n);\n","import { Button, Text, YStack } from 'tamagui';\n\nimport type { ScreenProps } from '../../types/ui';\n\nexport const QRCodeScreen = ({ onSuccess, onFailure }: ScreenProps) => (\n  <YStack space=\"$4\" padding=\"$4\">\n    <Text fontSize=\"$6\" fontWeight=\"bold\">\n      QR Code Scanner\n    </Text>\n    <Button onPress={onSuccess}>Simulate Success</Button>\n    <Button variant=\"outlined\" onPress={() => onFailure(new Error('QR scan failed'))}>\n      Simulate Failure\n    </Button>\n  </YStack>\n);\n","import type { ReactNode } from 'react';\n\nimport { SelfClientProvider } from '../context';\nimport type { Adapters, Config } from '../types/public';\n\nexport interface SelfMobileSdkProps {\n  config: Config;\n  adapters?: Partial<Adapters>;\n  children?: ReactNode;\n}\n\nexport const SelfMobileSdk = ({ config, adapters = {}, children }: SelfMobileSdkProps) => (\n  <SelfClientProvider config={config} adapters={adapters}>\n    {children}\n  </SelfClientProvider>\n);\n","import { notImplemented } from '../errors';\nimport type { ScanResult } from '../types/public';\n\n/**\n * Options for MRZ scanning.\n * Reserved for future use; currently no options are accepted.\n */\nexport type MRZScanOptions = Record<string, never>;\n\n// Re-export processing functions\nexport { extractMRZInfo, formatDateToYYMMDD } from '../processing/mrz';\n\n/**\n * Scan MRZ (Machine Readable Zone) on a passport or ID card.\n * @param _opts MRZ scanning options (currently unused)\n * @returns Promise resolving to scan result\n */\nexport async function scanMRZ(_opts: MRZScanOptions): Promise<ScanResult> {\n  // Surface a consistent, typed error for unimplemented features\n  throw notImplemented('scanMRZ');\n}\n","import { hash } from '@selfxyz/common/utils/hash/sha';\nimport { formatMrz } from '@selfxyz/common/utils/passportFormat';\n\nimport type { PassportData } from '../types/public';\n\n/**\n * Checks if two numeric arrays contain the same values in the same order.\n * @internal\n */\nfunction arraysEqual(a: ArrayLike<number>, b: ArrayLike<number>): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nconst SUPPORTED_HASH_FUNCTIONS = ['sha256', 'sha384', 'sha512'] as const;\n\ntype SupportedHash = (typeof SUPPORTED_HASH_FUNCTIONS)[number];\n\nfunction isSupportedHashAlgorithm(x: string): x is SupportedHash {\n  return (SUPPORTED_HASH_FUNCTIONS as readonly string[]).includes(x);\n}\n\n/**\n * Callbacks fired for specific passport validation failures.\n */\nexport interface PassportValidationCallbacks {\n  /** No passport data was supplied. */\n  onPassportDataNull?: () => void;\n  /** Passport data lacked required metadata. */\n  onPassportMetadataNull?: (data: PassportData) => void;\n  /** DG1 hash function was missing from metadata. */\n  onDg1HashFunctionNull?: (data: PassportData) => void;\n  /** EContent hash function was missing from metadata. */\n  onEContentHashFunctionNull?: (data: PassportData) => void;\n  /** Signed attribute hash function was missing from metadata. */\n  onSignedAttrHashFunctionNull?: (data: PassportData) => void;\n  /** Calculated DG1 hash didn't match the supplied value. */\n  onDg1HashMismatch?: (data: PassportData) => void;\n  /** An unsupported hash algorithm was supplied in metadata. */\n  onUnsupportedHashAlgorithm?: (field: 'dg1' | 'eContent' | 'signedAttr', value: string, data: PassportData) => void;\n  /** DG1 hash missing or empty; nothing to validate against. */\n  onDg1HashMissing?: (data: PassportData) => void;\n}\n\n/**\n * Validates passport data by ensuring required metadata and hash values match.\n * Invokes per-error callbacks when validation fails.\n *\n * @param passportData - Parsed passport data to validate.\n * @param callbacks - Optional hooks for tracking validation errors.\n * @returns Whether the passport data passed all validation checks.\n */\nexport function isPassportDataValid(\n  passportData: PassportData | undefined,\n  callbacks: PassportValidationCallbacks = {},\n): boolean {\n  const {\n    onPassportDataNull,\n    onPassportMetadataNull,\n    onDg1HashFunctionNull,\n    onEContentHashFunctionNull,\n    onSignedAttrHashFunctionNull,\n    onDg1HashMismatch,\n    onUnsupportedHashAlgorithm,\n    onDg1HashMissing,\n  } = callbacks;\n\n  if (!passportData) {\n    onPassportDataNull?.();\n    return false;\n  }\n\n  const { passportMetadata } = passportData;\n  if (!passportMetadata) {\n    onPassportMetadataNull?.(passportData);\n    return false;\n  }\n\n  const { dg1HashFunction, eContentHashFunction, signedAttrHashFunction } = passportMetadata;\n  if (!dg1HashFunction) {\n    onDg1HashFunctionNull?.(passportData);\n    return false;\n  }\n  if (!eContentHashFunction) {\n    onEContentHashFunctionNull?.(passportData);\n    return false;\n  }\n  if (!signedAttrHashFunction) {\n    onSignedAttrHashFunctionNull?.(passportData);\n    return false;\n  }\n\n  const dg1Algo = dg1HashFunction.toLowerCase();\n  const eContentAlgo = eContentHashFunction.toLowerCase();\n  const signedAttrAlgo = signedAttrHashFunction.toLowerCase();\n\n  if (!isSupportedHashAlgorithm(dg1Algo)) {\n    onUnsupportedHashAlgorithm?.('dg1', dg1Algo, passportData);\n    return false;\n  }\n  if (!isSupportedHashAlgorithm(eContentAlgo)) {\n    onUnsupportedHashAlgorithm?.('eContent', eContentAlgo, passportData);\n    return false;\n  }\n  if (!isSupportedHashAlgorithm(signedAttrAlgo)) {\n    onUnsupportedHashAlgorithm?.('signedAttr', signedAttrAlgo, passportData);\n    return false;\n  }\n\n  if (!passportData.mrz) {\n    return false;\n  }\n\n  if (passportData.dg1Hash && passportData.dg1Hash.length > 0) {\n    try {\n      const hashResult = hash(dg1Algo, formatMrz(passportData.mrz));\n      if (!Array.isArray(hashResult) || !hashResult.every(n => typeof n === 'number' && Number.isFinite(n))) {\n        return false;\n      }\n      const expected = hashResult as number[];\n      if (!arraysEqual(passportData.dg1Hash, expected)) {\n        onDg1HashMismatch?.(passportData);\n        return false;\n      }\n    } catch (e) {\n      // Log the error or handle it appropriately\n      console.error('Error calculating DG1 hash:', e);\n      return false;\n    }\n  } else {\n    onDg1HashMissing?.(passportData);\n  }\n\n  return true;\n}\n","/**\n * Safe TextDecoder factory that works across different JavaScript environments.\n * Handles browser, Node.js, and React Native environments gracefully.\n */\nimport { NfcParseError } from '../errors';\n\nconst createTextDecoder = (): TextDecoder => {\n  // Browser environment - TextDecoder is available globally\n  if (typeof globalThis !== 'undefined' && 'TextDecoder' in globalThis) {\n    return new globalThis.TextDecoder('utf-8', { fatal: true });\n  }\n\n  // React Native environment - TextDecoder should be available on global\n  if (\n    typeof (globalThis as any).global !== 'undefined' &&\n    (globalThis as any).global &&\n    'TextDecoder' in (globalThis as any).global\n  ) {\n    return new ((globalThis as any).global as any).TextDecoder('utf-8', { fatal: true });\n  }\n\n  // Node.js environment - try to import from built-in `node:util` (only if we're in a Node.js context)\n  if (typeof (globalThis as any).process !== 'undefined' && (globalThis as any).process?.versions?.node) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const req = typeof require === 'function' ? require : undefined;\n      const util = req ? req('node:util') : undefined;\n      if (util?.TextDecoder) {\n        return new util.TextDecoder('utf-8', { fatal: true });\n      }\n    } catch {\n      // Fall through to error\n    }\n  }\n\n  throw new NfcParseError(\n    'TextDecoder not available in this environment. ' +\n      'This SDK requires TextDecoder support which is available in modern browsers, Node.js, and React Native.',\n  );\n};\n\nlet DECODER: TextDecoder | undefined;\n\n// Lazily initialize to avoid import-time failures in environments without a decoder.\nconst getDecoder = (): TextDecoder => {\n  if (!DECODER) DECODER = createTextDecoder();\n  return DECODER;\n};\n\n// Known LDS1 tag constants\nconst TAG_DG1 = 0x61;\nconst TAG_DG2 = 0x75;\n\nexport interface DG1 {\n  mrz: string;\n}\n\nexport interface DG2 {\n  image: Uint8Array;\n}\n\nexport interface ParsedNFCResponse {\n  dg1?: DG1;\n  dg2?: DG2;\n}\n\nfunction readLength(view: Uint8Array, offset: number): { length: number; next: number } {\n  if (offset >= view.length) {\n    throw new NfcParseError('Unexpected end of data while reading length');\n  }\n  const first = view[offset];\n  if (first & 0x80) {\n    const bytes = first & 0x7f;\n    if (bytes === 0) {\n      throw new NfcParseError('Indefinite length (0x80) not supported');\n    }\n    if (offset + bytes >= view.length) {\n      throw new NfcParseError('Unexpected end of data while reading long-form length');\n    }\n    let len = 0;\n    for (let j = 1; j <= bytes; j++) {\n      len = (len << 8) | view[offset + j];\n    }\n    return { length: len, next: offset + 1 + bytes };\n  }\n  return { length: first, next: offset + 1 };\n}\n\n/**\n * Parse raw NFC chip bytes into DG1/DG2 structures.\n */\nexport function parseNFCResponse(bytes: Uint8Array): ParsedNFCResponse {\n  const result: ParsedNFCResponse = {};\n  let i = 0;\n  while (i < bytes.length) {\n    const tag = bytes[i++];\n    if (i >= bytes.length) throw new NfcParseError('Unexpected end of data');\n    const { length, next } = readLength(bytes, i);\n    i = next;\n    if (i + length > bytes.length) throw new NfcParseError('Unexpected end of data');\n    const value = bytes.slice(i, i + length);\n    i += length;\n\n    switch (tag) {\n      case TAG_DG1: {\n        result.dg1 = { mrz: getDecoder().decode(value) };\n        break;\n      }\n      case TAG_DG2: {\n        result.dg2 = { image: value };\n        break;\n      }\n      default: {\n        // ignore unknown tags for forward-compatibility\n        break;\n      }\n    }\n  }\n  return result;\n}\n","import { notImplemented } from '../errors';\nimport type { ScanResult } from '../types/public';\n\n// Re-export types from processing\nexport type { DG1, DG2, ParsedNFCResponse } from '../processing/nfc';\n\n/**\n * Options for NFC scanning.\n * Reserved for future use; currently no options are accepted.\n */\nexport type NFCScanOptions = Record<string, never>;\n\n// Re-export processing functions\nexport { parseNFCResponse } from '../processing/nfc';\n\n/**\n * Scan NFC chip on a passport or ID card.\n * @param _opts NFC scanning options (currently unused)\n * @returns Promise resolving to scan result\n */\nexport async function scanNFC(_opts: NFCScanOptions): Promise<ScanResult> {\n  // Surface a consistent, typed error for unimplemented features\n  throw notImplemented('scanNFC');\n}\n","import { notImplemented } from '../errors';\nimport type { ScanResult } from '../types/public';\n\n/**\n * Options for QR proof scanning.\n * Reserved for future use; currently no options are accepted.\n */\nexport type QRProofOptions = Record<string, never>;\n\n/**\n * Scan QR code containing proof data.\n * @param _opts QR proof scanning options (currently unused)\n * @returns Promise resolving to scan result\n */\nexport async function scanQRProof(_opts: QRProofOptions): Promise<ScanResult> {\n  // Surface a consistent, typed error for unimplemented features\n  throw notImplemented('scanQRProof');\n}\n","import { useCallback, useEffect, useState } from 'react';\n\nimport type { DocumentData, ExternalAdapter } from '../types/ui';\n\nexport const useDocumentManager = (external: ExternalAdapter) => {\n  const [documents, setDocuments] = useState<{\n    [documentId: string]: DocumentData;\n  }>({});\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    external\n      .getAllDocuments()\n      .then(documents => {\n        setDocuments(documents);\n        setIsLoading(false);\n      })\n      .catch(error => {\n        console.error('Failed to load documents:', error);\n        setIsLoading(false);\n      });\n  }, [external]);\n\n  const hasRegisteredDocuments = useCallback(() => {\n    return Object.values(documents).some(doc => doc.metadata.isRegistered);\n  }, [documents]);\n\n  return {\n    documents,\n    isLoading,\n    hasRegisteredDocuments,\n    setDocuments,\n  };\n};\n","import { SCANNER_ERROR_CODES, sdkError } from '../../errors';\nimport type { ScannerAdapter, ScanOpts, ScanResult } from '../../types/public';\n\nexport const webScannerShim: ScannerAdapter = {\n  async scan(opts: ScanOpts & { signal?: AbortSignal }): Promise<ScanResult> {\n    switch (opts.mode) {\n      case 'qr':\n        return { mode: 'qr', data: 'self://stub-qr' };\n      case 'mrz':\n        throw sdkError('MRZ scan not supported in web shim', SCANNER_ERROR_CODES.UNAVAILABLE, 'scanner');\n      case 'nfc':\n        throw sdkError('NFC not supported in web shim', SCANNER_ERROR_CODES.NFC_NOT_SUPPORTED, 'scanner');\n      default:\n        throw sdkError('Unknown scan mode', SCANNER_ERROR_CODES.INVALID_MODE, 'scanner');\n    }\n  },\n};\n"],"mappings":"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","names":["jsx","useCallback","Button","Text","YStack","jsx","jsxs","jsx","useCallback","mrzData","Button","Text","YStack","jsx","jsxs","jsx","useCallback","useState","documents"]}